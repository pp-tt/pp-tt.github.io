<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>嵌入式重点总结 on 噗通 🍀</title>
    <link>https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/</link>
    <description>Recent content in 嵌入式重点总结 on 噗通 🍀</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language><atom:link href="https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/c/</guid>
      <description>C 语言中 ## 和 # 的区别 # ## 操作符 # ## 操作符（Token Pasting Operator）：在宏定义中，**## 可以将两个标识符（tokens）粘合在一起，形成一个新的标识符。**例如，如果有以下宏定义：
#define CONCAT(a, b) a##b 那么，当你调用 CONCAT 宏并传递两个参数时，它会将这两个参数的内容合并成一个新的标识符：
CONCAT(foo, bar); // 最终的标识符为 &amp;#34;foobar&amp;#34; # 操作符 # # 操作符（Stringizing Operator）：在宏定义中，# 可以将宏参数转化为字符串常量。例如，如果有以下宏定义：
#define STRINGIFY(x) #x 那么，当你调用 STRINGIFY 宏并传递一个参数时，它会将参数转换为字符串常量：
printf(&amp;#34;%s\n&amp;#34;, STRINGIFY(Hello)); // 输出 &amp;#34;Hello&amp;#34; # 操作符的作用是将参数的内容用双引号包裹起来，将其转化为字符串。
实验 # 实验如下：
#include &amp;lt;stdio.h&amp;gt; #define GENSTR(x) #x #define CONCAT(a, b) a##b int main() { // ## 实验 int foobar = 5; printf(&amp;#34;%d\n&amp;#34;, CONCAT(foo, bar)); // # 实验 printf(&amp;#34;%s\n&amp;#34;, GENSTR(String)); return(0); } 输出结果：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/arm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/arm/</guid>
      <description>什么是异步传输和同步传输? # 异步传输:是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低。 同步传输:需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传 输速度比异步传输快。
哈佛结构和冯诺依曼结构？ # 哈佛结构（Harvard Architecture）和冯诺依曼结构（Von Neumann Architecture）是计算机体系结构的两种主要类型，它们在计算机内部的数据和指令处理方式上有重要的区别。
冯诺依曼结构（Von Neumann Architecture） # 特点：冯诺依曼结构是一种单存储器结构，其中计算机的程序指令和数据都存储在同一个内存中，共享相同的总线。这意味着程序和数据使用相同的通信通道传输到CPU。 工作方式：在冯诺依曼结构中，CPU 从内存中取指令，执行指令，然后将结果存回内存。这种结构是顺序执行的，即一次只执行一个指令。 优点：冯诺依曼结构简单且易于理解，适用于通用计算机和大多数应用。 缺点：由于指令和数据共享同一总线，可能会导致内存瓶颈，限制了计算机性能的提升。此外，它通常不适用于并行计算。 哈佛结构（Harvard Architecture） # 特点：哈佛结构是一种双存储器结构，其中程序指令存储在一个内存单元中，而数据存储在另一个内存单元中。这两个内存单元使用不同的总线。 工作方式：在哈佛结构中，CPU 可以同时从程序存储器中取指令和从数据存储器中获取数据，这使得指令和数据的访问可以并行进行，提高了性能。 优点：哈佛结构具有更高的性能潜力，因为它允许指令和数据并行传输，这对于嵌入式系统和一些特定应用非常有用。 缺点：哈佛结构通常较复杂，因为需要管理两个不同的内存单元和总线。此外，它可能不适用于所有类型的计算机应用。 总之，哈佛结构和冯诺依曼结构是两种不同的计算机体系结构，它们在指令和数据存储以及数据传输方式上有不同的设计和优劣势。选择哪种结构取决于计算机的用途和性能需求。通常，通用计算机采用冯诺依曼结构，而嵌入式系统和某些特定应用采用哈佛结构或改进的哈佛结构。</description>
    </item>
    
  </channel>
</rss>
