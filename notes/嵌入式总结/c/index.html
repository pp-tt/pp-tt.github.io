<!DOCTYPE html>
<html dir="ltr" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content='C 语言中 ## 和 # 的区别 # ## 操作符 # ## 操作符（Token Pasting Operator）：在宏定义中，**## 可以将两个标识符（tokens）粘合在一起，形成一个新的标识符。**例如，如果有以下宏定义：
#define CONCAT(a, b) a##b 那么，当你调用 CONCAT 宏并传递两个参数时，它会将这两个参数的内容合并成一个新的标识符：
CONCAT(foo, bar); // 最终的标识符为 "foobar" # 操作符 # # 操作符（Stringizing Operator）：在宏定义中，# 可以将宏参数转化为字符串常量。例如，如果有以下宏定义：
#define STRINGIFY(x) #x 那么，当你调用 STRINGIFY 宏并传递一个参数时，它会将参数转换为字符串常量：
printf("%s\n", STRINGIFY(Hello)); // 输出 "Hello" # 操作符的作用是将参数的内容用双引号包裹起来，将其转化为字符串。
实验 # 实验如下：
#include &lt;stdio.h&gt; #define GENSTR(x) #x #define CONCAT(a, b) a##b int main() { // ## 实验 int foobar = 5; printf("%d\n", CONCAT(foo, bar)); // # 实验 printf("%s\n", GENSTR(String)); return(0); } 输出结果：' name="description"/>
<meta content="#FFFFFF" name="theme-color"/>
<meta content="light dark" name="color-scheme"/><meta content="" property="og:title"/>
<meta content='C 语言中 ## 和 # 的区别 # ## 操作符 # ## 操作符（Token Pasting Operator）：在宏定义中，**## 可以将两个标识符（tokens）粘合在一起，形成一个新的标识符。**例如，如果有以下宏定义：
#define CONCAT(a, b) a##b 那么，当你调用 CONCAT 宏并传递两个参数时，它会将这两个参数的内容合并成一个新的标识符：
CONCAT(foo, bar); // 最终的标识符为 "foobar" # 操作符 # # 操作符（Stringizing Operator）：在宏定义中，# 可以将宏参数转化为字符串常量。例如，如果有以下宏定义：
#define STRINGIFY(x) #x 那么，当你调用 STRINGIFY 宏并传递一个参数时，它会将参数转换为字符串常量：
printf("%s\n", STRINGIFY(Hello)); // 输出 "Hello" # 操作符的作用是将参数的内容用双引号包裹起来，将其转化为字符串。
实验 # 实验如下：
#include &lt;stdio.h&gt; #define GENSTR(x) #x #define CONCAT(a, b) a##b int main() { // ## 实验 int foobar = 5; printf("%d\n", CONCAT(foo, bar)); // # 实验 printf("%s\n", GENSTR(String)); return(0); } 输出结果：' property="og:description"/>
<meta content="article" property="og:type"/>
<meta content="https://pp-tt.github.io.git/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/c/" property="og:url"/><meta content="notes" property="article:section"/>
<title>C | 噗通 🍀</title>
<link href="/manifest.json" rel="manifest"/>
<link href="/favicon.png" rel="icon" type="image/x-icon"/>
<link crossorigin="anonymous" href="/book.min.a82d7e77ceb134d151c4d7e381eeb30623fbd5a524d58c584d8716ecec0205bd.css" integrity="sha256-qC1+d86xNNFRxNfjge6zBiP71aUk1YxYTYcW7OwCBb0=" rel="stylesheet"/>
<script defer="" src="/flexsearch.min.js"></script>
<script crossorigin="anonymous" defer="" integrity="sha256-jy8niP8Qeyumj3hCJlzGLNlbDC9RW0Fj8fX16a9Dg5A=" src="/zh.search.min.8f2f2788ff107b2ba68f7842265cc62cd95b0c2f515b4163f1f5f5e9af438390.js"></script>
<script crossorigin="anonymous" defer="" integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
</head>
<body dir="ltr">
<input class="hidden toggle" id="menu-control" type="checkbox"/>
<input class="hidden toggle" id="toc-control" type="checkbox"/>
<main class="container flex">
<aside class="book-menu">
<div class="book-menu-content">
<nav>
<h2 class="book-brand">
<a class="flex align-center" href="/"><span>噗通 🍀</span>
</a>
</h2>
<div class="book-search">
<input aria-label="Search" data-hotkeys="s/" id="book-search-input" maxlength="64" placeholder="Search" type="text"/>
<div class="book-search-spinner hidden"></div>
<ul id="book-search-results"></ul>
</div>
<ul>
<li class="book-section-flat">
<span>--学习笔记--👇</span>
<ul>
<li>
<input class="toggle" id="section-0f70934a6e5284fbc93928c61dfe9c83" type="checkbox"/>
<label class="flex justify-between" for="section-0f70934a6e5284fbc93928c61dfe9c83">
<a class="" role="button">Java</a>
</label>
<ul>
<li>
<a class="" href="/notes/java/arraylist-%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99/">Array List 扩容规则</a>
</li>
<li>
<a class="" href="/notes/java/hashmap-%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Hash Map 相关学习总结</a>
</li>
<li>
<a class="" href="/notes/java/java-%E5%8F%8D%E5%B0%84/">Java 反射</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-4364152b7ab5995d509c0b7b811005c4" type="checkbox"/>
<label class="flex justify-between" for="section-4364152b7ab5995d509c0b7b811005c4">
<a class="" role="button">JVM</a>
</label>
<ul>
<li>
<a class="" href="/notes/jvm/%E4%BB%80%E4%B9%88%E6%98%AF-jvm/">什么是 Jvm</a>
</li>
<li>
<a class="" href="/notes/jvm/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/">程序计数器</a>
</li>
<li>
<a class="" href="/notes/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/">虚拟机栈</a>
</li>
<li>
<a class="" href="/notes/jvm/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-/">本地方法栈</a>
</li>
<li>
<a class="" href="/notes/jvm/%E5%A0%86/">堆</a>
</li>
<li>
<a class="" href="/notes/jvm/%E6%96%B9%E6%B3%95%E5%8C%BA/">方法区</a>
</li>
<li>
<a class="" href="/notes/jvm/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/">直接内存</a>
</li>
<li>
<a class="" href="/notes/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a>
</li>
<li>
<a class="" href="/notes/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">垃圾回收器</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-b7444509cb631180897a34f028407c2c" type="checkbox"/>
<label class="flex justify-between" for="section-b7444509cb631180897a34f028407c2c">
<a class="" role="button">设计模式</a>
</label>
<ul>
<li>
<a class="" href="/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml-%E5%9B%BE%E9%BB%91%E9%A9%AC/">Uml 图（黑马）</a>
</li>
<li>
<a class="" href="/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%BB%91%E9%A9%AC/">设计原则（黑马）</a>
</li>
<li>
<a class="" href="/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E9%BB%91%E9%A9%AC/">创建型模式（黑马）</a>
</li>
<li>
<a class="" href="/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E9%BB%91%E9%A9%AC/">结构型模式（黑马）</a>
</li>
<li>
<a class="" href="/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E9%BB%91%E9%A9%AC/">行为型模式（黑马）</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-61661238f18c0095524962a5d1d6e676" type="checkbox"/>
<label class="flex justify-between" for="section-61661238f18c0095524962a5d1d6e676">
<a class="" role="button">Spring</a>
</label>
<ul>
<li>
<a class="" href="/notes/spring/beanfactory%E4%B8%8Eapplicationcontext/">Bean Factory与 Application Context</a>
</li>
<li>
<a class="" href="/notes/spring/nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">Nacos 配置中心</a>
</li>
<li>
<a class="" href="/notes/spring/open-feign-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B/">Open Feign 远程调用示例</a>
</li>
<li>
<a class="" href="/notes/spring/springboot-%E6%95%B4%E5%90%88-mybatis-plus/">Spring Boot 整合 My Batis Plus</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-58f730a0b22fcdc7a886db614d77f88c" type="checkbox"/>
<label class="flex justify-between" for="section-58f730a0b22fcdc7a886db614d77f88c">
<a class="" role="button">代码随想录刷题</a>
</label>
<ul>
<li>
<a class="" href="/notes/leetcode/day001-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%95%B0%E7%BB%84/">Day001 第一章数组</a>
</li>
<li>
<a class="" href="/notes/leetcode/day002-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%95%B0%E7%BB%84/">Day002 第一章数组</a>
</li>
<li>
<a class="" href="/notes/leetcode/day003-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%93%BE%E8%A1%A8/">Day003 第二章链表</a>
</li>
<li>
<a class="" href="/notes/leetcode/day004-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%93%BE%E8%A1%A8/">Day004 第二章链表</a>
</li>
<li>
<a class="" href="/notes/leetcode/day006-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%93%88%E5%B8%8C%E8%A1%A8/">Day006 第三章哈希表</a>
</li>
<li>
<a class="" href="/notes/leetcode/day007-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%93%88%E5%B8%8C%E8%A1%A8/">Day007 第三章哈希表</a>
</li>
<li>
<a class="" href="/notes/leetcode/day008-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/">Day008 第四章字符串</a>
</li>
<li>
<a class="" href="/notes/leetcode/day009-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/">Day009 第四章字符串</a>
</li>
<li>
<a class="" href="/notes/leetcode/day010-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">Day010 第五章栈与队列</a>
</li>
<li>
<a class="" href="/notes/leetcode/day011-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">Day011 第五章栈与队列</a>
</li>
<li>
<a class="" href="/notes/leetcode/day013-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">Day013 第五章栈与队列</a>
</li>
<li>
<a class="" href="/notes/leetcode/day014-%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">Day014 第六章二叉树</a>
</li>
<li>
<a class="" href="/notes/leetcode/day015-%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">Day015 第六章二叉树</a>
</li>
<li>
<a class="" href="/notes/leetcode/day017-%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">Day017 第六章二叉树</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-4f95435d3a74007e2c985ea455bbb6e6" type="checkbox"/>
<label class="flex justify-between" for="section-4f95435d3a74007e2c985ea455bbb6e6">
<a class="" role="button">MyBatisPlus</a>
</label>
<ul>
<li>
<a class="" href="/notes/mybatisplus/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">MP快速入门</a>
</li>
<li>
<a class="" href="/notes/mybatisplus/%E4%B8%80%E8%88%AC%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/">一般查询操作</a>
</li>
<li>
<a class="" href="/notes/mybatisplus/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/">分页查询</a>
</li>
<li>
<a class="" href="/notes/mybatisplus/%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4/">逻辑删除</a>
</li>
<li>
<a class="" href="/notes/mybatisplus/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/">条件查询</a>
</li>
<li>
<a class="" href="/notes/mybatisplus/%E5%B0%81%E8%A3%85service%E4%BD%BF%E7%94%A8/">封装service使用</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-e2ca0d138d67d9d3ae55da25ac044829" type="checkbox"/>
<label class="flex justify-between" for="section-e2ca0d138d67d9d3ae55da25ac044829">
<a class="" role="button">Redis</a>
</label>
<ul>
<li>
<a class="" href="/notes/redis/nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/">No Sql数据库简介</a>
</li>
<li>
<a class="" href="/notes/redis/redis-key/">Redis Key</a>
</li>
<li>
<a class="" href="/notes/redis/redis-string/">Redis String</a>
</li>
<li>
<a class="" href="/notes/redis/redis-list/">Redis List</a>
</li>
<li>
<a class="" href="/notes/redis/redis-set/">Redis Set</a>
</li>
<li>
<a class="" href="/notes/redis/redis-hash/">Redis Hash</a>
</li>
<li>
<a class="" href="/notes/redis/redis-zset/">Redis Zset</a>
</li>
<li>
<a class="" href="/notes/redis/redis-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/">Redis 发布与订阅</a>
</li>
<li>
<a class="" href="/notes/redis/redis-jedis/">Redis Jedis</a>
</li>
<li>
<a class="" href="/notes/redis/springboot-%E6%95%B4%E5%90%88-redis/">Spring Boot 整合 Redis</a>
</li>
<li>
<a class="" href="/notes/redis/redis-%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/">Redis 事务和锁机制</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-39abd0d44427d4a54e694a2b3f22d967" type="checkbox"/>
<label class="flex justify-between" for="section-39abd0d44427d4a54e694a2b3f22d967">
<a class="" role="button">TensorFlow</a>
</label>
<ul>
<li>
<a class="" href="/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%B8%80/">Tensor Flow 笔记（一）</a>
</li>
<li>
<a class="" href="/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%BA%8C/">Tensor Flow 笔记（二）</a>
</li>
<li>
<a class="" href="/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%B8%89/">Tensor Flow 笔记（三）</a>
</li>
<li>
<a class="" href="/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E5%9B%9B/">Tensor Flow 笔记（四）</a>
</li>
<li>
<a class="" href="/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%BA%94/">Tensor Flow 笔记（五）</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-a42f4efe12b0d964f8de7588b38cb659" type="checkbox"/>
<label class="flex justify-between" for="section-a42f4efe12b0d964f8de7588b38cb659">
<a class="" role="button">Java八股</a>
</label>
<ul>
<li>
<a class="" href="/notes/%E5%85%AB%E8%82%A1/%E5%B9%B6%E5%8F%91/">Concurrence</a>
</li>
<li>
<a class="" href="/notes/%E5%85%AB%E8%82%A1/mybatis/">MyBatis</a>
</li>
<li>
<a class="" href="/notes/%E5%85%AB%E8%82%A1/mysql/">MySQL</a>
</li>
<li>
<a class="" href="/notes/%E5%85%AB%E8%82%A1/jvm/">Jvm</a>
</li>
<li>
<a class="" href="/notes/%E5%85%AB%E8%82%A1/redis/">Redis</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-3907b2cf55ed520ad784e24525c8baa4" type="checkbox"/>
<label class="flex justify-between" for="section-3907b2cf55ed520ad784e24525c8baa4">
<a class="" role="button">Swift</a>
</label>
<ul>
<li>
<a class="" href="/notes/swift/swiftui-%E5%B8%B8%E7%94%A8%E8%A7%86%E5%9B%BE-views/">Swift Ui 常用视图 Views</a>
</li>
<li>
<a class="" href="/notes/swift/swiftui-%E4%BF%A1%E6%81%AF%E8%A7%86%E5%9B%BE-views/">Swift Ui 信息视图 Views</a>
</li>
<li>
<a class="" href="/notes/swift/swiftui-%E5%B1%82%E7%BA%A7%E8%A7%86%E5%9B%BE-views/">Swift Ui 层级视图 Views</a>
</li>
<li>
<a class="" href="/notes/swift/swiftui-%E6%8E%A7%E5%88%B6%E8%A7%86%E5%9B%BE-views/">Swift Ui 控制视图 Views</a>
</li>
</ul>
</li>
<li>
<a class="active" href="/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/c/">C</a>
</li>
</ul>
</li>
<li class="book-section-flat">
<span>--解决方案--👇</span>
<ul>
<li>
<input class="toggle" id="section-f1d4602254471b9d0da445dd468cd456" type="checkbox"/>
<label class="flex justify-between" for="section-f1d4602254471b9d0da445dd468cd456">
<a class="" role="button">环境配置</a>
</label>
<ul>
<li>
<a class="" href="/solution/environment/apple-m%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85-pyqt/">Apple M系列芯片安装 Pyqt</a>
</li>
<li>
<a class="" href="/solution/environment/docker-%E5%AE%89%E8%A3%85-redis-/">Docker 安装 Redis</a>
</li>
<li>
<a class="" href="/solution/environment/hugo-%E4%B8%BB%E9%A2%98-hugo-book-%E4%B8%AD%E8%8B%B1%E6%96%87%E6%90%9C%E7%B4%A2%E9%85%8D%E7%BD%AE/">Hugo 主题 Hugo Book 中英文搜索配置</a>
</li>
<li>
<a class="" href="/solution/environment/iterm2-oh-my-zsh-%E9%85%8D%E7%BD%AE/">I Term2 Oh My Zsh 配置</a>
</li>
<li>
<a class="" href="/solution/environment/m1-%E8%8A%AF%E7%89%87-docker-%E5%AE%89%E8%A3%85-mysql5.7-/">M1 芯片 Docker 安装 Mysql5.7</a>
</li>
<li>
<a class="" href="/solution/environment/mac-idea-%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%8D/">MAC Idea 快捷键位</a>
</li>
<li>
<a class="" href="/solution/environment/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">内网穿透</a>
</li>
<li>
<a class="" href="/solution/environment/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE/">内网穿透的自启动设置</a>
</li>
</ul>
</li>
<li>
<input class="toggle" id="section-5a76a664ba4855b79d3c1bc77e5b08b1" type="checkbox"/>
<label class="flex justify-between" for="section-5a76a664ba4855b79d3c1bc77e5b08b1">
<a class="" role="button">杂乱问题</a>
</label>
<ul>
<li>
<a class="" href="/solution/problems/brew-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Brew 一些常用命令</a>
</li>
<li>
<a class="" href="/solution/problems/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 常用命令</a>
</li>
<li>
<a class="" href="/solution/problems/git-github-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/">Git Git Hub 相关命令整理</a>
</li>
<li>
<a class="" href="/solution/problems/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%AB%E7%9B%B2/">面试题扫盲</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="book-section-flat">
<span>--其他记录--👇</span>
<ul>
<li>
<input class="toggle" id="section-9ef4d2063ddc9af7785b193647f22260" type="checkbox"/>
<label class="flex justify-between" for="section-9ef4d2063ddc9af7785b193647f22260">
<a class="" role="button">我和阿刁</a>
</label>
<ul>
<li>
<a class="" href="/daily/ad/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%88%812022%E5%B9%B4%E7%9A%84%E7%94%9F%E6%97%A5%E7%9A%84%E5%B0%8F%E8%AE%BA%E6%96%87/">关于阿刁2022年的生日的小论文</a>
</li>
<li>
<a class="" href="/daily/ad/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%88%81%E7%9A%842021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">关于阿刁的2021年度总结</a>
</li>
<li>
<a class="" href="/daily/ad/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%88%81%E7%9A%842022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">关于阿刁的2022年度总结</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class="book-page">
<header class="book-header">
<div class="flex align-center justify-between">
<label for="menu-control">
<img alt="Menu" class="book-icon" src="/svg/menu.svg"/>
</label>
<strong>C</strong>
<label for="toc-control">
<img alt="Table of Contents" class="book-icon" src="/svg/toc.svg"/>
</label>
</div>
<aside class="hidden clearfix">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#c-语言中--和--的区别">C 语言中 ## 和 # 的区别</a>
<ul>
<li><a href="#-操作符">## 操作符</a></li>
<li><a href="#-操作符-1"># 操作符</a></li>
<li><a href="#实验">实验</a></li>
</ul>
</li>
<li><a href="#关键字volatile有什么用给出应用场景">关键字volatile有什么用？给出应用场景</a>
<ul>
<li><a href="#多线程编程">多线程编程</a></li>
<li><a href="#中断处理">中断处理</a></li>
<li><a href="#硬件寄存器访问">硬件寄存器访问</a></li>
<li><a href="#全局变量在信号处理函数中的修改">全局变量在信号处理函数中的修改</a></li>
</ul>
</li>
<li><a href="#说说的static的理解">说说的static的理解？</a>
<ul>
<li><a href="#静态局部变量">静态局部变量：</a></li>
<li><a href="#静态函数">静态函数：</a></li>
<li><a href="#静态全局变量">静态全局变量：</a></li>
</ul>
</li>
<li><a href="#c语言中const关键字是干什么的有什么应用场景">C语言中const关键字是干什么的？有什么应用场景？</a>
<ul>
<li><a href="#定义常量">定义常量：</a></li>
<li><a href="#保护数据">保护数据：</a></li>
<li><a href="#限定指针">限定指针：</a></li>
<li><a href="#防止函数修改数据">防止函数修改数据：</a></li>
</ul>
</li>
<li><a href="#不借助sizeof求int占用的字节数">不借助sizeof，求int占用的字节数?</a></li>
<li><a href="#说明sizeof和strlen区别">说明sizeof和strlen区别？</a></li>
<li><a href="#实现memcpy函数">实现memcpy函数</a></li>
<li><a href="#c语言中-struct与-union的区别是什么">C语言中 struct与 union的区别是什么?</a></li>
<li><a href="#堆和栈的区别">堆和栈的区别？</a></li>
<li><a href="#什么是内存泄漏-如何避免内存泄漏">什么是内存泄漏? 如何避免内存泄漏</a></li>
<li><a href="#指针数组与数组指针的区别">指针数组与数组指针的区别？</a>
<ul>
<li><a href="#指针数组pointer-array">指针数组（Pointer Array）</a></li>
<li><a href="#数组指针array-pointer">数组指针（Array Pointer）</a></li>
</ul>
</li>
<li><a href="#函数指针和指针函数有什么区别">函数指针和指针函数有什么区别?</a></li>
<li><a href="#数组名和指针的区别">数组名和指针的区别？</a>
<ul>
<li><a href="#主要差别">主要差别</a></li>
<li><a href="#应用差别">应用差别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class="markdown"><h2 id="c-语言中--和--的区别">
  C 语言中 ## 和 # 的区别
  <a class="anchor" href="#c-%e8%af%ad%e8%a8%80%e4%b8%ad--%e5%92%8c--%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h2>
<h3 id="-操作符">
  ## 操作符
  <a class="anchor" href="#-%e6%93%8d%e4%bd%9c%e7%ac%a6">#</a>
</h3>
<p><code>##</code> 操作符（Token Pasting Operator）：在宏定义中，**<code>##</code> 可以将两个标识符（tokens）粘合在一起，形成一个新的标识符。**例如，如果有以下宏定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define CONCAT(a, b) a##b
</span></span></span></code></pre></div><p>那么，当你调用 <code>CONCAT</code> 宏并传递两个参数时，它会将这两个参数的内容合并成一个新的标识符：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">CONCAT</span>(foo, bar); <span style="color:#75715e">// 最终的标识符为 "foobar"
</span></span></span></code></pre></div><h3 id="-操作符-1">
  # 操作符
  <a class="anchor" href="#-%e6%93%8d%e4%bd%9c%e7%ac%a6-1">#</a>
</h3>
<p><code>#</code> 操作符（Stringizing Operator）：在宏定义中，<code>#</code> 可以将宏参数转化为字符串常量。例如，如果有以下宏定义：</p>
<pre tabindex="0"><code>#define STRINGIFY(x) #x
</code></pre><p>那么，当你调用 <code>STRINGIFY</code> 宏并传递一个参数时，它会将参数转换为字符串常量：</p>
<pre tabindex="0"><code>printf("%s\n", STRINGIFY(Hello)); // 输出 "Hello"
</code></pre><p><strong><code>#</code> 操作符的作用是将参数的内容用双引号包裹起来，将其转化为字符串。</strong></p>
<h3 id="实验">
  实验
  <a class="anchor" href="#%e5%ae%9e%e9%aa%8c">#</a>
</h3>
<p>实验如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GENSTR(x) #x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CONCAT(a, b) a##b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ## 实验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> foobar <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">"%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, <span style="color:#a6e22e">CONCAT</span>(foo, bar));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// # 实验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">"%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, <span style="color:#a6e22e">GENSTR</span>(String));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span>String
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><h2 id="关键字volatile有什么用给出应用场景">
  关键字volatile有什么用？给出应用场景
  <a class="anchor" href="#%e5%85%b3%e9%94%ae%e5%ad%97volatile%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8%e7%bb%99%e5%87%ba%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h2>
<p><code>volatile</code> 是一个关键字，用于告诉编译器不要对某个变量进行优化，因为该变量的值可能会在程序的控制之外被改变。主要用途包括以下几个方面的场景：</p>
<h3 id="多线程编程">
  多线程编程
  <a class="anchor" href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%bc%96%e7%a8%8b">#</a>
</h3>
<p><strong>多线程编程</strong>：在多线程编程中，多个线程可能会同时访问共享的变量。如果不使用 <code>volatile</code> 声明关键变量，编译器可能会对变量的读取和写入进行优化，导致线程之间无法正确同步。使用 <code>volatile</code> 可以确保对共享变量的访问不会被编译器优化，从而保证线程之间的正确通信。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> shared_variable;
</span></span></code></pre></div><h3 id="中断处理">
  中断处理
  <a class="anchor" href="#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86">#</a>
</h3>
<p><strong>中断处理</strong>：在嵌入式系统中，硬件中断可能会修改某些变量的值。如果这些变量没有被声明为 <code>volatile</code>，编译器可能会优化掉对它们的访问，导致中断处理程序无法正确工作。通过将相关变量声明为 <code>volatile</code>，可以确保中断处理程序正确地访问和修改这些变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> interrupt_flag;
</span></span></code></pre></div><h3 id="硬件寄存器访问">
  硬件寄存器访问
  <a class="anchor" href="#%e7%a1%ac%e4%bb%b6%e5%af%84%e5%ad%98%e5%99%a8%e8%ae%bf%e9%97%ae">#</a>
</h3>
<p><strong>硬件寄存器访问</strong>：在嵌入式系统中，通常需要与硬件寄存器进行交互，这些寄存器的值可能在任何时刻被外部硬件修改。将硬件寄存器声明为 <code>volatile</code> 可以确保每次对寄存器的读取和写入都会实际执行，而不会被编译器优化掉。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>hardware_register <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x12345678</span>;
</span></span></code></pre></div><h3 id="全局变量在信号处理函数中的修改">
  全局变量在信号处理函数中的修改
  <a class="anchor" href="#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%9c%a8%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e4%bf%ae%e6%94%b9">#</a>
</h3>
<p><strong>全局变量在信号处理函数中的修改</strong>：当全局变量在信号处理函数中被修改时，可以将这些全局变量声明为 <code>volatile</code>，以确保信号处理函数中对它们的修改不会被编译器优化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> global_variable;
</span></span></code></pre></div><p>总之，<code>volatile</code> 主要用于标识那些可能在程序控制之外被改变的变量，以防止编译器对它们的读取和写入进行优化，确保程序的正确性和可预测性。然而，应该谨慎使用 <code>volatile</code>，<strong>因为过度使用它可能会导致性能下降，并且在一些情况下，更好的方法是使用互斥锁或其他同步机制来处理多线程或中断问题。</strong></p>
<h2 id="说说的static的理解">
  说说的static的理解？
  <a class="anchor" href="#%e8%af%b4%e8%af%b4%e7%9a%84static%e7%9a%84%e7%90%86%e8%a7%a3">#</a>
</h2>
<h3 id="静态局部变量">
  静态局部变量：
  <a class="anchor" href="#%e9%9d%99%e6%80%81%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f">#</a>
</h3>
<ul>
<li>在函数内部声明的静态变量<strong>仅在函数第一次被调用时初始化</strong>，并在<strong>函数调用之间保持其值</strong>。这使得它们可以在多次函数调用之间保留状态信息。</li>
<li>静态变量的<strong>作用域限制在声明它们的函数内部</strong>，即它们是局部静态变量，其他函数无法访问它们。</li>
<li>静态变量默认<strong>初始化为零或空指针</strong>，除非显式指定了初始值。</li>
</ul>
<h3 id="静态函数">
  静态函数：
  <a class="anchor" href="#%e9%9d%99%e6%80%81%e5%87%bd%e6%95%b0">#</a>
</h3>
<ul>
<li>静态函数的<strong>作用域限制在声明它们的源文件中</strong>，其他源文件无法访问它们。这使得静态函数对于实现文件私有的辅助函数非常有用。</li>
<li>静态函数可以帮助<strong>减小程序的全局命名空间污染</strong>，因为它们的名称不会与其他源文件中的函数发生冲突。</li>
</ul>
<h3 id="静态全局变量">
  静态全局变量：
  <a class="anchor" href="#%e9%9d%99%e6%80%81%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f">#</a>
</h3>
<ul>
<li>静态全局变量具有文件作用域，只能在声明它们的源文件中访问。与普通全局变量不同，静态全局变量不会被其他源文件所看到，因此不会引起链接错误。</li>
<li><strong>静态全局变量的生存期是整个程序运行期间</strong>，但作用域仅限于声明它们的源文件。</li>
</ul>
<h2 id="c语言中const关键字是干什么的有什么应用场景">
  C语言中const关键字是干什么的？有什么应用场景？
  <a class="anchor" href="#c%e8%af%ad%e8%a8%80%e4%b8%adconst%e5%85%b3%e9%94%ae%e5%ad%97%e6%98%af%e5%b9%b2%e4%bb%80%e4%b9%88%e7%9a%84%e6%9c%89%e4%bb%80%e4%b9%88%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#</a>
</h2>
<p><code>const</code> 是C语言中的关键字，用于定义常量或限定变量的值不可更改。它在C语言中有多种应用场景，主要用途如下：</p>
<h3 id="定义常量">
  定义常量：
  <a class="anchor" href="#%e5%ae%9a%e4%b9%89%e5%b8%b8%e9%87%8f">#</a>
</h3>
<ul>
<li>最常见的用途是定义常量，以便在程序中使用具有固定值的符号标识符，从而提高代码的可读性和可维护性。</li>
<li>通过在变量声明前使用 <code>const</code> 关键字，可以创建只读变量，其值在初始化后不能被修改。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAX_VALUE <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14159265359</span>;
</span></span></code></pre></div><h3 id="保护数据">
  保护数据：
  <a class="anchor" href="#%e4%bf%9d%e6%8a%a4%e6%95%b0%e6%8d%ae">#</a>
</h3>
<ul>
<li>使用 <code>const</code> 可以将函数参数声明为只读，防止函数修改传入的数据。这可以提高代码的安全性，并减少出现错误的机会。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printData</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> data) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试修改 data 会导致编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">"%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, data);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="限定指针">
  限定指针：
  <a class="anchor" href="#%e9%99%90%e5%ae%9a%e6%8c%87%e9%92%88">#</a>
</h3>
<pre><code>还可以用于指针变量，分为两种情况：
</code></pre>
<ul>
<li><code>const int* ptr 或 int const* ptr</code>：指向常量整数的指针，不能通过指针修改所指向的整数的值。</li>
<li><code>int* const ptr</code>：常量指针，不能通过指针改变其指向的地址。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>value;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> ptr2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> number <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> ptr3 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>number;
</span></span></code></pre></div><h3 id="防止函数修改数据">
  防止函数修改数据：
  <a class="anchor" href="#%e9%98%b2%e6%ad%a2%e5%87%bd%e6%95%b0%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae">#</a>
</h3>
<ul>
<li>在函数声明和定义中使用 <code>const</code> 关键字，可以表示该函数不会修改传入的参数值。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processData</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">size_t</span> size) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不能修改 data 所指向的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">size_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// data[i] = 0; // 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">"%d "</span>, data[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总之，<code>const</code> 关键字用于创建常量、限定指针的修改权限、防止函数修改数据以及保护数据的安全性。它有助于提高代码的可维护性、可读性和安全性，并可以在编译时捕获一些潜在的错误。</p>
<h2 id="不借助sizeof求int占用的字节数">
  不借助sizeof，求int占用的字节数?
  <a class="anchor" href="#%e4%b8%8d%e5%80%9f%e5%8a%a9sizeof%e6%b1%82int%e5%8d%a0%e7%94%a8%e7%9a%84%e5%ad%97%e8%8a%82%e6%95%b0">#</a>
</h2>
<p>创建一个指向 <code>int</code> 类型的指针，然后计算指针的差值。</p>
<p>这是一个示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr2 <span style="color:#f92672">=</span> ptr1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> intSize <span style="color:#f92672">=</span> (<span style="color:#66d9ef">size_t</span>)ptr2 <span style="color:#f92672">-</span> (<span style="color:#66d9ef">size_t</span>)ptr1;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">"int 占用的字节数：%zu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, intSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="说明sizeof和strlen区别">
  说明sizeof和strlen区别？
  <a class="anchor" href="#%e8%af%b4%e6%98%8esizeof%e5%92%8cstrlen%e5%8c%ba%e5%88%ab">#</a>
</h2>
<ol>
<li><strong>功能</strong>：
<ul>
<li><code>sizeof</code> 用于获取数据类型、变量或对象在内存中占用的字节数，不受对象内容的影响，是编译时的静态计算。</li>
<li><code>strlen</code> 用于计算以null字符（’\0’）结尾的C字符串的字符数，是运行时的动态计算，需要遍历字符串内容直到遇到null字符。</li>
</ul>
</li>
<li><strong>返回值</strong>：
<ul>
<li><code>sizeof</code> 返回一个常量值，表示数据类型、变量或对象的字节数。</li>
<li><code>strlen</code> 返回一个整数值，表示字符串的实际字符数，不包括null字符。</li>
</ul>
</li>
<li><strong>用途</strong>：
<ul>
<li><code>sizeof</code> 通常用于获取数据类型、数组或对象的大小，以便在内存分配、缓冲区大小等方面进行计算。</li>
<li><code>strlen</code> 用于获取C字符串的长度，用于字符串处理、打印输出、字符串拼接等。</li>
</ul>
</li>
<li><strong>适用范围</strong>：
<ul>
<li><code>sizeof</code> 可以用于任何数据类型，包括基本数据类型、结构体、数组、指针等。</li>
<li><code>strlen</code> 只适用于以null字符结尾的C字符串，即字符数组。</li>
</ul>
</li>
<li><strong>运行时开销</strong>：
<ul>
<li><code>sizeof</code> 是在编译时计算，不会引入运行时开销，不受数据内容的影响。</li>
<li><code>strlen</code> 需要在运行时扫描字符串内容，直到遇到null字符，因此运行时开销较大，受字符串内容的影响。</li>
</ul>
</li>
</ol>
<h2 id="实现memcpy函数">
  实现memcpy函数
  <a class="anchor" href="#%e5%ae%9e%e7%8e%b0memcpy%e5%87%bd%e6%95%b0">#</a>
</h2>
<p><code>memcpy</code> 函数用于在内存中复制一块数据到另一块内存区域，包括源地址、目标地址和要复制的字节数。以下是一个简单的 <code>memcpy</code> 函数的实现示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stddef.h&gt; // 为了使用 size_t 类型</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">memcpy</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> src, <span style="color:#66d9ef">size_t</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> d <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)dest;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)src;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 逐字节复制数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">size_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        d[i] <span style="color:#f92672">=</span> s[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dest;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个实现的关键点是将源地址和目标地址都强制转换为 <code>unsigned char*</code> 类型，以确保按字节复制数据，然后使用循环逐字节复制数据，重复 <code>n</code> 次，最后返回目标地址的指针。</p>
<h2 id="c语言中-struct与-union的区别是什么">
  C语言中 struct与 union的区别是什么?
  <a class="anchor" href="#c%e8%af%ad%e8%a8%80%e4%b8%ad-struct%e4%b8%8e-union%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h2>
<p>区别主要在以下几个方面：</p>
<ol>
<li>
<p><strong>内存分配方式</strong>：</p>
<ul>
<li><strong><code>struct</code></strong>（结构体）：结构体的内存分配是按照其成员的总大小分配的，每个成员都有自己的内存空间，成员之间互不共享内存。结构体的大小等于所有成员的大小之和。</li>
<li><strong><code>union</code></strong>（联合体）：联合体的内存分配是所有成员共享同一块内存空间，占用的内存大小等于最大成员的大小。因此，不同成员不能同时存储值，修改一个成员可能会影响其他成员。</li>
</ul>
</li>
<li>
<p><strong>成员访问</strong>：</p>
<ul>
<li><strong><code>struct</code></strong>：结构体的各个成员可以同时存储不同的数据，每个成员都有自己的地址，可以通过结构体变量的成员访问运算符 <code>.</code> 来访问。</li>
<li><strong><code>union</code></strong>：联合体的各个成员共享同一块内存，只能存储其中一个成员的数据，访问时也使用 <code>.</code> 来访问。<strong>修改了联合体的一个成员，会影响其他成员，因为内存空间共用。</strong></li>
</ul>
</li>
<li>
<p><strong>用途</strong>：</p>
<ul>
<li>
<p><strong><code>struct</code></strong>：结构体通常用于表示多个相关的数据成员，每个成员都有不同的含义，它们可以一起描述一个复杂的数据结构。例如，可以用结构体表示一个点的坐标。</p>
</li>
<li>
<p><strong><code>union</code></strong>：联合体通常用于表示多个不同的数据类型中的一个，但在某一时刻只能存储其中一个。这在节省内存和处理共享内存的情况下非常有用，例如，可以用联合体表示一个变量可以是整数、浮点数或字符数组其中的一种。</p>
</li>
</ul>
</li>
<li>
<p><strong>大小</strong>：</p>
<ul>
<li>
<p><strong><code>struct</code></strong>：结构体的大小等于其所有成员的大小之和，可能会较大。</p>
</li>
<li>
<p><strong><code>union</code></strong>：联合体的大小等于其最大成员的大小，因此通常较小。</p>
</li>
</ul>
</li>
</ol>
<h2 id="堆和栈的区别">
  堆和栈的区别？
  <a class="anchor" href="#%e5%a0%86%e5%92%8c%e6%a0%88%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h2>
<p>堆和栈的区别主要有五大点，分别是：</p>
<ol>
<li>申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;</li>
<li>申请大小的不同。栈获得的空间较小，而堆获得的空间较大;</li>
<li>申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;</li>
<li>存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;</li>
<li>底层不同。栈是连续的空间，而堆是不连续的空间。</li>
</ol>
<h2 id="什么是内存泄漏-如何避免内存泄漏">
  什么是内存泄漏? 如何避免内存泄漏
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f-%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f">#</a>
</h2>
<p>内存泄漏（Memory Leak）是指程序在动态分配内存后，没有释放或释放不完全，导致程序无法再次访问或回收已分配的内存块。内存泄漏是一种常见的程序错误，可能会导致程序性能下降或最终崩溃。</p>
<p>避免内存泄漏的措施：</p>
<ol>
<li><strong>使用合适的数据结构</strong>：
<ul>
<li>使用合适的数据结构来管理内存，例如，使用数组、链表或树来组织数据，以便在不再需要时可以轻松释放内存。</li>
</ul>
</li>
<li><strong>遵循分配与释放的一一对应</strong>：
<ul>
<li>每次分配内存后，都要确保在不再需要时释放它。维护良好的分配和释放的一一对应关系是避免内存泄漏的关键。</li>
</ul>
</li>
<li><strong>注意边界条件</strong>：
<ul>
<li>确保在处理边界条件时正确分配和释放内存，例如，在循环中分配内存时要确保循环终止后释放内存。</li>
</ul>
</li>
</ol>
<h2 id="指针数组与数组指针的区别">
  指针数组与数组指针的区别？
  <a class="anchor" href="#%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84%e4%b8%8e%e6%95%b0%e7%bb%84%e6%8c%87%e9%92%88%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h2>
<h3 id="指针数组pointer-array">
  指针数组（Pointer Array）
  <a class="anchor" href="#%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84pointer-array">#</a>
</h3>
<ul>
<li>指针数组是一个数组，其中的每个元素都是一个指针。</li>
<li>每个指针可以指向不同类型的数据或相同类型的数据。</li>
<li>指针数组通常用于存储多个字符串或多个对象的地址，以便可以通过循环或索引来访问这些元素。</li>
</ul>
<h3 id="数组指针array-pointer">
  数组指针（Array Pointer）
  <a class="anchor" href="#%e6%95%b0%e7%bb%84%e6%8c%87%e9%92%88array-pointer">#</a>
</h3>
<ul>
<li>数组指针是一个指针，它指向一个数组。</li>
<li>数组指针通常用于访问整个数组，而不是单个元素。</li>
<li>数组指针的类型与其指向的数组的类型相关。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>指针数组是一个数组，其元素是指针。</li>
<li>数组指针是一个指针，它指向一个数组。</li>
<li>指针数组通常用于存储多个指向不同对象的指针。</li>
<li>数组指针通常用于访问整个数组，尤其在多维数组的情况下非常有用。</li>
</ul>
<h2 id="函数指针和指针函数有什么区别">
  函数指针和指针函数有什么区别?
  <a class="anchor" href="#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88%e5%92%8c%e6%8c%87%e9%92%88%e5%87%bd%e6%95%b0%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#</a>
</h2>
<p>函数指针（Function Pointer）和指针函数（Pointer to Function）是两个不同的概念，它们具有不同的用途和行为：</p>
<ol>
<li>
<p><strong>函数指针（Function Pointer）</strong>：</p>
<ul>
<li>函数指针是指向函数的指针变量。它存储的是函数的地址，可以用来调用相应地址上的函数。</li>
<li>函数指针的声明形式类似于函数的声明，只是将函数名替换为指针变量名，并在前面加上星号（*）表示这是一个指针。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>funcPtr)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>); <span style="color:#75715e">// 声明一个函数指针，指向一个接受两个int参数并返回int的函数
</span></span></span></code></pre></div><ul>
<li>函数指针通常用于实现函数回调、动态选择要调用的函数、实现多态等高级用途。</li>
</ul>
</li>
<li>
<p><strong>指针函数（Pointer to Function）</strong>：</p>
<ul>
<li>指针函数是一个返回指针的函数，它返回指向某种类型的指针的值。</li>
<li>指针函数的声明形式类似于函数的声明，只是返回值类型是一个指针类型。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">someFunction</span>(); <span style="color:#75715e">// 声明一个指针函数，返回一个指向int的指针
</span></span></span></code></pre></div><ul>
<li>指针函数通常用于返回动态分配的内存块的指针或特定类型的指针。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>函数指针是指向函数的指针变量，用于调用函数。</li>
<li>指针函数是一个函数，它返回一个指针。</li>
<li>这两者之间的区别在于它们的声明和用途。函数指针用于指向和调用函数，而指针函数是一个函数，它返回指针。</li>
</ul>
<h2 id="数组名和指针的区别">
  数组名和指针的区别？
  <a class="anchor" href="#%e6%95%b0%e7%bb%84%e5%90%8d%e5%92%8c%e6%8c%87%e9%92%88%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> heart[] <span style="color:#f92672">=</span> <span style="color:#e6db74">"I love Tillie!"</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> <span style="color:#e6db74">"I love Millie!"</span>;
</span></span></code></pre></div><h3 id="主要差别">
  主要差别
  <a class="anchor" href="#%e4%b8%bb%e8%a6%81%e5%b7%ae%e5%88%ab">#</a>
</h3>
<p>数组名 <code>heart</code> 是个对象，而指针 <code>*head</code> 是个变量。</p>
<h3 id="应用差别">
  应用差别
  <a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%b7%ae%e5%88%ab">#</a>
</h3>
<ol>
<li>
<p>两者都可以使用下标索引：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(heart[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(head[i]);
</span></span></code></pre></div></li>
<li>
<p>两者都可以指针加法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(<span style="color:#f92672">*</span>(heart <span style="color:#f92672">+</span> i));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(<span style="color:#f92672">*</span>(head <span style="color:#f92672">+</span> i));
</span></span></code></pre></div></li>
<li>
<p>只有指针可以使用自增加法，因为数组名是常量，所以不能使用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#f92672">*</span>(hear) <span style="color:#f92672">!=</span> <span style="color:#e6db74">"</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">"</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(<span style="color:#f92672">*</span>(head<span style="color:#f92672">++</span>));
</span></span></code></pre></div></li>
</ol>
</article>
<footer class="book-footer">
<div class="flex flex-wrap justify-between">
</div>
<script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>
</footer>
<div class="book-comments">
</div>
<label class="hidden book-menu-overlay" for="menu-control"></label>
</div>
<aside class="book-toc">
<div class="book-toc-content">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#c-语言中--和--的区别">C 语言中 ## 和 # 的区别</a>
<ul>
<li><a href="#-操作符">## 操作符</a></li>
<li><a href="#-操作符-1"># 操作符</a></li>
<li><a href="#实验">实验</a></li>
</ul>
</li>
<li><a href="#关键字volatile有什么用给出应用场景">关键字volatile有什么用？给出应用场景</a>
<ul>
<li><a href="#多线程编程">多线程编程</a></li>
<li><a href="#中断处理">中断处理</a></li>
<li><a href="#硬件寄存器访问">硬件寄存器访问</a></li>
<li><a href="#全局变量在信号处理函数中的修改">全局变量在信号处理函数中的修改</a></li>
</ul>
</li>
<li><a href="#说说的static的理解">说说的static的理解？</a>
<ul>
<li><a href="#静态局部变量">静态局部变量：</a></li>
<li><a href="#静态函数">静态函数：</a></li>
<li><a href="#静态全局变量">静态全局变量：</a></li>
</ul>
</li>
<li><a href="#c语言中const关键字是干什么的有什么应用场景">C语言中const关键字是干什么的？有什么应用场景？</a>
<ul>
<li><a href="#定义常量">定义常量：</a></li>
<li><a href="#保护数据">保护数据：</a></li>
<li><a href="#限定指针">限定指针：</a></li>
<li><a href="#防止函数修改数据">防止函数修改数据：</a></li>
</ul>
</li>
<li><a href="#不借助sizeof求int占用的字节数">不借助sizeof，求int占用的字节数?</a></li>
<li><a href="#说明sizeof和strlen区别">说明sizeof和strlen区别？</a></li>
<li><a href="#实现memcpy函数">实现memcpy函数</a></li>
<li><a href="#c语言中-struct与-union的区别是什么">C语言中 struct与 union的区别是什么?</a></li>
<li><a href="#堆和栈的区别">堆和栈的区别？</a></li>
<li><a href="#什么是内存泄漏-如何避免内存泄漏">什么是内存泄漏? 如何避免内存泄漏</a></li>
<li><a href="#指针数组与数组指针的区别">指针数组与数组指针的区别？</a>
<ul>
<li><a href="#指针数组pointer-array">指针数组（Pointer Array）</a></li>
<li><a href="#数组指针array-pointer">数组指针（Array Pointer）</a></li>
</ul>
</li>
<li><a href="#函数指针和指针函数有什么区别">函数指针和指针函数有什么区别?</a></li>
<li><a href="#数组名和指针的区别">数组名和指针的区别？</a>
<ul>
<li><a href="#主要差别">主要差别</a></li>
<li><a href="#应用差别">应用差别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>
