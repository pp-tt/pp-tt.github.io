[{"id":0,"href":"/notes/jvm/%E4%BB%80%E4%B9%88%E6%98%AF-jvm/","title":"什么是 Jvm","section":"JVM","content":" 什么是 JVM # JVM 定义 # Java Virtual Machine 是 java 程序的运行环境（java 二进制字节码的运行环境）。\nJVM 有什么好处？ # 一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态 JVM、JRE、JDK 三者之间关系？ # JRE（Java Runtime Environment）：JVM + 基础类库\nJDK（Java Developm Kit）：JVM + 基础类库 + 编译工具\nJVM 组成结构 # 补充：\nClassLoader： 加载二进制字节码到 JVM 中。 Method Area： 类均放在方法区部分。 Heap： 类创建的实例对象放在 Heap 部分，堆中的实例调用方法时用到 JVM Stacks、PC Register、Native Method Stacks。方法中的每行代码由执行引擎中的 Interpreter 逐行执行， JIT 对方法中的热点代码进行优化后执行。 GC： 对 Heap 中不再被引用的对象进行垃圾回收。 "},{"id":1,"href":"/notes/redis/nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/","title":"No Sql数据库简介","section":"Redis","content":" NoSQL数据库简介 # NoSQL概述 # NoSQL 不同于 MySql，不依赖业务逻辑方式存储，以简单的 key-value 方式存储，增加了数据库的扩展能力。\nNoSQL 适用场景 # 对高并发数据的读写 海量数据的读写 对数据的高扩展性 NoSQL不适用场景 # 需要事务支持 基于 sql 的结构化查询存储，处理复杂的关系 用不着sql的和用了sql也不行的情况就考虑用 NoSQL Memcached 与 Redis 的不同 # Memcached支持单一数据类型，而Redis支持多种数据类型 Memcached不支持持久化，但是Redis可以支持 Memcached采用多线程+锁，Redis使用的是单线程+多路IO复用 多路IO复用 # IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄； 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作； 没有文件句柄就绪就会阻塞应用程序，交出CPU。\n"},{"id":2,"href":"/notes/spring/beanfactory%E4%B8%8Eapplicationcontext/","title":"Bean Factory与 Application Context","section":"Spring","content":" BeanFactory 与 ApplicationContext # BeanFactory # 什么是 BeanFactory # BeanFactory 是 ApplicationContext 的父接口，它是 Spring 的核心容器，主要的 Spring 实现都组合了它的功能。\nBeanFactory 能做什么 # 类的方法如下图，表面上只有 getBean()，实际上控制反转、依赖注入、Bean 的生命周期等各种功能都由它的实现类来实现。\nApplicationContext # 如下图，ApplicationContext 的扩展功能主要体现在它的四个父接口上。\nMessageSource：处理国际化资源，如程序支持多种语言、翻译\nResourcePatternResolver：根据通配符去匹配资源\nfile：磁盘路径下找资源\nclasspsth：类路径下找资源\nclasspsth*：类和jar包下找资源\nApplicationEventPublisher：用来发布事件对象，通常可以作为事件解藕\nEnvironmentCapable：处理环境信息，如yaml、yml等\n总结 # BeanFactory 与 ApplicationContext 之间并不仅仅是简单的接口继承关系，ApplicationContext 组合并扩展了 BeanFactory 的功能。除此之外，通过 ApplicationEventPublisher 学到一种解藕技术。\n"},{"id":3,"href":"/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%B8%80/","title":"Tensor Flow 笔记（一）","section":"TensorFlow","content":" TensorFlow 笔记（一） # 介绍TensorFlow基本API和神经网络训练的基本流程：准备数据（数据加载，数据乱序，数据分割，数据配对），搭建神经网络，参数优化，计算LOSS，计算ACC，画出LOSS和ACC图。通过鸢尾花分类串起来以上操作。\n1.神经网络的计算过程 # 反向传播计算示例代码：\nimport tensorflow as tf w = tf.Variable(tf.constant(5, dtype=tf.float32)) # 定义可变变量 lr = 0.999 # 定义学习率 epoch = 40 # 迭代次数 for epoch in range(epoch): with tf.GradientTape() as tape: # with 结构起到grads框起了梯度的计算过程 loss = tf.square(w + 1) grads = tape.gradient(loss, w) # .gradient函数告知谁对谁求导 w.assign_sub(lr * grads) # .assign_sub 对变量做自减，即 w -= lr * grads print(f\u0026#34;After {epoch} epoch, w is {w.numpy()}, loss is {loss}\u0026#34;) 2.张量生成 # 2.1 创建一个张量 # a = tf.constant([5, 6], dtype=tf.int16) print(a) # 详细显示，值、形状、类型 print(a.shape) # 形状 print(a.dtype) # 类型 2.2 numpy 转 Tensor # tf.convert_to_tensor(数据名, dtype=数据类型) 2.3 0张量、1张量和指定值张量 # 创建全为0的张量：tf.zeros(维度) 创建全为1的张量：tf.ones(维度) 创建全为指定值的张量：tf.fill(维度， 指定值) a = tf.zeros([2, 3]) b = tf.ones(4) c = tf.fill([2, 2], 9) 2.4 其他张量 # 生成正态分布随机数： tf.random.normal(维度, mean=均值, stddev=标准差) 生成截断式正态分布随机数： tf.random.truncated_normal(维度, mean=均值, stddev=标准差) 生成均匀分布随机数 [minval, maxval] tf.random.uniform(维度, minval=0, maxval=1) 3.常用函数 # 强制tensor类型转为该数据类型： tf.cast(张量名，dtype=数据类型) 计算张量维度上的元素最小值： tf.reduce_min(张量名， axis=轴) 计算张量维度上的元素最大值： tf.reduce_max(张量名， axis=轴) 计算张量维度上的平均值： tf.reduce_mean(张量名， axis=轴) 计算张量维度上的和： tf.reduce_sum(张量名, axis=轴) 将变量标记为可训练，被标记的变量会在反向传播中记录梯度信息。神经网络中，常用该函数标记待训练参数。 tf.Variable(tf.random.normal([2, 2], mean=0, stddev=1)) 实现两个张量的对应元素相加（注：只有维度相同才可以做四则运算） tf.add(张量1， 张量2) 实现两个张量的对应元素相减 tf.subtract(张量1， 张量2) 实现两个张量的对应元素相乘 tf.multiply(张量1， 张量2) 实现两个张量的对应元素相除 tf.divide(张量1， 张量2) 计算某个张量的平方 tf.square(张量名) 计算某个张量的n次方 tf.pow(张量名， n次方数) 计算某个张量的开方 tf.sqrt(张量名) 实现两个矩阵相乘 tf.matmul(矩阵1， 矩阵2) 构建数据集（numpy 和 tensor 都可以用该语句） tf.data.Dataset.from_tensor_slices((输入特征，标签)) 求导 with tf.GradientTape() as tape: 若干计算过程 grad = tape.gradient(函数，对谁求导) 将数据转为 one-hot 形式的数据输出 tf.one_hot(待转换数据，depth=几分类) 例： import tensorflow as tf labels = tf.constant([1, 0, 2]) classes = 3 ouput = tf.one_hot(labels, depth=classes) \u0026lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy= array([[0., 1., 0.], [1., 0., 0.], [0., 0., 1.]], dtype=float32)\u0026gt; 使 n 个分类的 n 个输出符合概率分布 tf.nn.softmax() y = tf.constant([1.01, 2.01, -0.66]) y_pro = tf.nn.softmax(y) print(\u0026#34;After sotfmax, y_pro is:\u0026#34;, y_pro) 赋值操作，更新函数的值并返回，调用assign_sub前，先用tf.Variable定义变量 w 为可训练（可自更新） w.assign_sub(w 要自减的内容) 例： w = tf.Variable(4) w.assign_sub(1) print(w) 返回张量沿指定维度最大值的索引 tf.argmax(张量名，axis=轴) 4. 鸢尾花分类 # ​\t鸢尾花分类主要分为以下步骤：\n准备数据 数据集读入 数据集乱序 生成训练集和测试集（即 x_train / y_train） 配成（输入特征，标签）对，每次读入一小撮（batch） 搭建网络 定义神经网络中所有可训练参数 参数优化 嵌套循环迭代，with 结构更新参数，显示当前 loss 测试效果 计算当前参数前向传播后的准确率，显示当前 acc acc / loss 可视化 import sklearn.datasets as datasets import numpy as np import tensorflow as tf import matplotlib.pyplot as plt \u0026#34;\u0026#34;\u0026#34; 准备数据 \u0026#34;\u0026#34;\u0026#34; # 加载数据 x_data = datasets.load_iris().data y_data = datasets.load_iris().target # 数据集乱序 np.random.seed(116) # 使用相同的 seed, 使输入特征/标签一一对应 np.random.shuffle(x_data) np.random.seed(116) np.random.shuffle(y_data) # 将数据集分为训练集和测试集 x_train = x_data[:-30] y_train = y_data[:-30] x_test = x_data[-30:] y_test = y_data[-30:] # 数据类型转换，否则后面矩阵相乘时会因数据类型不一致报错 x_train = tf.cast(x_train, tf.float32) x_test = tf.cast(x_test, tf.float32) # 配成 [输入特征， 标签] 对， 每次喂入一小撮（batch） train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32) test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32) \u0026#34;\u0026#34;\u0026#34; 搭建网络 \u0026#34;\u0026#34;\u0026#34; # 生成神经网络的参数，4个输入特征，故输入层为4个输入节点，因为3分类，故输出为3个神经元 # 定义神经网络中所有可训练参数 # 使用 seed 使每次生成的随机数都相同（方便教学，使大家结果都一致，现实使用时可以不写seed） w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1)) b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1)) \u0026#34;\u0026#34;\u0026#34; 参数优化 \u0026#34;\u0026#34;\u0026#34; # 定义超参数 lr = 0.1 train_loss_results = [] # 将每轮的loss记录在此列表中，为后续画 loss 曲线提供数据 test_acc = [] # 将每轮的 acc 记录在此列表中， 为后续画 acc 曲线提供数据 epoch = 500 # 循环 500 轮 loss_all = 0 # 每轮分4个step， loss_all 记录四个 step 生成的 4 个 loss 的和 # 嵌套循环迭代，with 结构参数更新，显示当前 loss for epoch in range(epoch): # 数据集级别迭代 for step, (x_train, y_train) in enumerate(train_db): # batch 级别迭代 with tf.GradientTape() as tape: # 记录梯度信息 y = tf.matmul(x_train, w1) + b1 # 神经网络乘加运算 y = tf.nn.softmax(y) # 使输出y符合概率分布 y_ = tf.one_hot(y_train, depth=3) # 将标签值转换为独热编码 loss = tf.reduce_mean(tf.square(y_ - y)) # 采用均方误差损失函数 loss_all += loss.numpy() # 将每个 step 计算出的 loss 累加， 为后续求平均值提供数据 # 计算各个参数的梯度 grads = tape.gradient(loss, [w1, b1]) # 参数自更新 w1.assign_sub(lr * grads[0]) b1.assign_sub(lr * grads[1]) print(\u0026#34;Epoch {}, loss: {}\u0026#34;.format(epoch, loss_all/4)) train_loss_results.append(loss_all / 4) # 将 4 个 step 的 loss 求平均记录在此变量中 loss_all = 0 # loss 归零， 为计算下一个 epoch 作准备 \u0026#34;\u0026#34;\u0026#34;测试部分\u0026#34;\u0026#34;\u0026#34; # total_correct 为预测对的样本个数，total_number 为测试的总样本数 total_correct, total_number = 0, 0 for x_test, y_test in test_db: # 使用更新后的参数进行预测 y = tf.matmul(x_test, w1) + b1 y = tf.nn.softmax(y) pred = tf.argmax(y, axis=1) pred = tf.cast(pred, dtype=y_test.dtype) correct = tf.cast(tf.equal(pred, y_test), dtype=tf.float32) correct = tf.reduce_sum(correct) total_correct += int(correct) total_number += x_test.shape[0] acc = total_correct / total_number test_acc.append(acc) print(\u0026#34;Test_acc:\u0026#34;, acc) print(\u0026#34;---------------------\u0026#34;) # 绘制 loss 曲线 plt.title(\u0026#39;Loss Function Curve\u0026#39;) plt.xlabel(\u0026#39;Epoch\u0026#39;) plt.ylabel(\u0026#39;Loss\u0026#39;) plt.plot(train_loss_results, label=\u0026#39;$LOSS$\u0026#39;) plt.legend() plt.show() # 绘制 Accuracy 曲线 plt.title(\u0026#39;Acc Curve\u0026#39;) plt.xlabel(\u0026#39;Epoch\u0026#39;) plt.ylabel(\u0026#39;Acc\u0026#39;) plt.plot(test_acc, label=\u0026#34;$Accuracy$\u0026#34;) plt.legend() plt.show() "},{"id":4,"href":"/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/c/","title":"C","section":"嵌入式重点总结","content":" C 语言中 ## 和 # 的区别 # ## 操作符 # ## 操作符（Token Pasting Operator）：在宏定义中，**## 可以将两个标识符（tokens）粘合在一起，形成一个新的标识符。**例如，如果有以下宏定义：\n#define CONCAT(a, b) a##b 那么，当你调用 CONCAT 宏并传递两个参数时，它会将这两个参数的内容合并成一个新的标识符：\nCONCAT(foo, bar); // 最终的标识符为 \u0026#34;foobar\u0026#34; # 操作符 # # 操作符（Stringizing Operator）：在宏定义中，# 可以将宏参数转化为字符串常量。例如，如果有以下宏定义：\n#define STRINGIFY(x) #x 那么，当你调用 STRINGIFY 宏并传递一个参数时，它会将参数转换为字符串常量：\nprintf(\u0026#34;%s\\n\u0026#34;, STRINGIFY(Hello)); // 输出 \u0026#34;Hello\u0026#34; # 操作符的作用是将参数的内容用双引号包裹起来，将其转化为字符串。\n实验 # 实验如下：\n#include \u0026lt;stdio.h\u0026gt; #define GENSTR(x) #x #define CONCAT(a, b) a##b int main() { // ## 实验 int foobar = 5; printf(\u0026#34;%d\\n\u0026#34;, CONCAT(foo, bar)); // # 实验 printf(\u0026#34;%s\\n\u0026#34;, GENSTR(String)); return(0); } 输出结果：\nString 5 关键字volatile有什么用？给出应用场景 # volatile 是一个关键字，用于告诉编译器不要对某个变量进行优化，因为该变量的值可能会在程序的控制之外被改变。主要用途包括以下几个方面的场景：\n多线程编程 # 多线程编程：在多线程编程中，多个线程可能会同时访问共享的变量。如果不使用 volatile 声明关键变量，编译器可能会对变量的读取和写入进行优化，导致线程之间无法正确同步。使用 volatile 可以确保对共享变量的访问不会被编译器优化，从而保证线程之间的正确通信。\nvolatile int shared_variable; 中断处理 # 中断处理：在嵌入式系统中，硬件中断可能会修改某些变量的值。如果这些变量没有被声明为 volatile，编译器可能会优化掉对它们的访问，导致中断处理程序无法正确工作。通过将相关变量声明为 volatile，可以确保中断处理程序正确地访问和修改这些变量。\nvolatile int interrupt_flag; 硬件寄存器访问 # 硬件寄存器访问：在嵌入式系统中，通常需要与硬件寄存器进行交互，这些寄存器的值可能在任何时刻被外部硬件修改。将硬件寄存器声明为 volatile 可以确保每次对寄存器的读取和写入都会实际执行，而不会被编译器优化掉。\nvolatile unsigned int *hardware_register = (unsigned int *)0x12345678; 全局变量在信号处理函数中的修改 # 全局变量在信号处理函数中的修改：当全局变量在信号处理函数中被修改时，可以将这些全局变量声明为 volatile，以确保信号处理函数中对它们的修改不会被编译器优化。\nvolatile int global_variable; 总之，volatile 主要用于标识那些可能在程序控制之外被改变的变量，以防止编译器对它们的读取和写入进行优化，确保程序的正确性和可预测性。然而，应该谨慎使用 volatile，因为过度使用它可能会导致性能下降，并且在一些情况下，更好的方法是使用互斥锁或其他同步机制来处理多线程或中断问题。\n说说的static的理解？ # 静态局部变量： # 在函数内部声明的静态变量仅在函数第一次被调用时初始化，并在函数调用之间保持其值。这使得它们可以在多次函数调用之间保留状态信息。 静态变量的作用域限制在声明它们的函数内部，即它们是局部静态变量，其他函数无法访问它们。 静态变量默认初始化为零或空指针，除非显式指定了初始值。 静态函数： # 静态函数的作用域限制在声明它们的源文件中，其他源文件无法访问它们。这使得静态函数对于实现文件私有的辅助函数非常有用。 静态函数可以帮助减小程序的全局命名空间污染，因为它们的名称不会与其他源文件中的函数发生冲突。 静态全局变量： # 静态全局变量具有文件作用域，只能在声明它们的源文件中访问。与普通全局变量不同，静态全局变量不会被其他源文件所看到，因此不会引起链接错误。 静态全局变量的生存期是整个程序运行期间，但作用域仅限于声明它们的源文件。 C语言中const关键字是干什么的？有什么应用场景？ # const 是C语言中的关键字，用于定义常量或限定变量的值不可更改。它在C语言中有多种应用场景，主要用途如下：\n定义常量： # 最常见的用途是定义常量，以便在程序中使用具有固定值的符号标识符，从而提高代码的可读性和可维护性。 通过在变量声明前使用 const 关键字，可以创建只读变量，其值在初始化后不能被修改。 const int MAX_VALUE = 100; const double PI = 3.14159265359; 保护数据： # 使用 const 可以将函数参数声明为只读，防止函数修改传入的数据。这可以提高代码的安全性，并减少出现错误的机会。 void printData(const int data) { // 尝试修改 data 会导致编译错误 printf(\u0026#34;%d\\n\u0026#34;, data); } 限定指针： # 还可以用于指针变量，分为两种情况： const int* ptr 或 int const* ptr：指向常量整数的指针，不能通过指针修改所指向的整数的值。 int* const ptr：常量指针，不能通过指针改变其指向的地址。 const int value = 42; const int* ptr = \u0026amp;value; int const* ptr2 = \u0026amp;value; int number = 10; int* const ptr3 = \u0026amp;number; 防止函数修改数据： # 在函数声明和定义中使用 const 关键字，可以表示该函数不会修改传入的参数值。 void processData(const int* data, size_t size) { // 不能修改 data 所指向的值 for (size_t i = 0; i \u0026lt; size; i++) { // data[i] = 0; // 编译错误 printf(\u0026#34;%d \u0026#34;, data[i]); } } 总之，const 关键字用于创建常量、限定指针的修改权限、防止函数修改数据以及保护数据的安全性。它有助于提高代码的可维护性、可读性和安全性，并可以在编译时捕获一些潜在的错误。\n不借助sizeof，求int占用的字节数? # 创建一个指向 int 类型的指针，然后计算指针的差值。\n这是一个示例：\n#include \u0026lt;stdio.h\u0026gt; int main() { int x; int* ptr1 = \u0026amp;x; int* ptr2 = ptr1 + 1; size_t intSize = (size_t)ptr2 - (size_t)ptr1; printf(\u0026#34;int 占用的字节数：%zu\\n\u0026#34;, intSize); return 0; } 说明sizeof和strlen区别？ # 功能： sizeof 用于获取数据类型、变量或对象在内存中占用的字节数，不受对象内容的影响，是编译时的静态计算。 strlen 用于计算以null字符（\u0026rsquo;\\0\u0026rsquo;）结尾的C字符串的字符数，是运行时的动态计算，需要遍历字符串内容直到遇到null字符。 返回值： sizeof 返回一个常量值，表示数据类型、变量或对象的字节数。 strlen 返回一个整数值，表示字符串的实际字符数，不包括null字符。 用途： sizeof 通常用于获取数据类型、数组或对象的大小，以便在内存分配、缓冲区大小等方面进行计算。 strlen 用于获取C字符串的长度，用于字符串处理、打印输出、字符串拼接等。 适用范围： sizeof 可以用于任何数据类型，包括基本数据类型、结构体、数组、指针等。 strlen 只适用于以null字符结尾的C字符串，即字符数组。 运行时开销： sizeof 是在编译时计算，不会引入运行时开销，不受数据内容的影响。 strlen 需要在运行时扫描字符串内容，直到遇到null字符，因此运行时开销较大，受字符串内容的影响。 实现memcpy函数 # memcpy 函数用于在内存中复制一块数据到另一块内存区域，包括源地址、目标地址和要复制的字节数。以下是一个简单的 memcpy 函数的实现示例：\n#include \u0026lt;stddef.h\u0026gt; // 为了使用 size_t 类型 void* memcpy(void* dest, const void* src, size_t n) { unsigned char* d = (unsigned char*)dest; const unsigned char* s = (const unsigned char*)src; // 逐字节复制数据 for (size_t i = 0; i \u0026lt; n; i++) { d[i] = s[i]; } return dest; } 这个实现的关键点是将源地址和目标地址都强制转换为 unsigned char* 类型，以确保按字节复制数据，然后使用循环逐字节复制数据，重复 n 次，最后返回目标地址的指针。\nC语言中 struct与 union的区别是什么? # 区别主要在以下几个方面：\n内存分配方式：\nstruct（结构体）：结构体的内存分配是按照其成员的总大小分配的，每个成员都有自己的内存空间，成员之间互不共享内存。结构体的大小等于所有成员的大小之和。 union（联合体）：联合体的内存分配是所有成员共享同一块内存空间，占用的内存大小等于最大成员的大小。因此，不同成员不能同时存储值，修改一个成员可能会影响其他成员。 成员访问：\nstruct：结构体的各个成员可以同时存储不同的数据，每个成员都有自己的地址，可以通过结构体变量的成员访问运算符 . 来访问。 union：联合体的各个成员共享同一块内存，只能存储其中一个成员的数据，访问时也使用 . 来访问。修改了联合体的一个成员，会影响其他成员，因为内存空间共用。 用途：\nstruct：结构体通常用于表示多个相关的数据成员，每个成员都有不同的含义，它们可以一起描述一个复杂的数据结构。例如，可以用结构体表示一个点的坐标。\nunion：联合体通常用于表示多个不同的数据类型中的一个，但在某一时刻只能存储其中一个。这在节省内存和处理共享内存的情况下非常有用，例如，可以用联合体表示一个变量可以是整数、浮点数或字符数组其中的一种。\n大小：\nstruct：结构体的大小等于其所有成员的大小之和，可能会较大。\nunion：联合体的大小等于其最大成员的大小，因此通常较小。\n堆和栈的区别？ # 堆和栈的区别主要有五大点，分别是：\n申请方式的不同。栈由系统自动分配，而堆是人为申请开辟; 申请大小的不同。栈获得的空间较小，而堆获得的空间较大; 申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢; 存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排; 底层不同。栈是连续的空间，而堆是不连续的空间。 什么是内存泄漏? 如何避免内存泄漏 # 内存泄漏（Memory Leak）是指程序在动态分配内存后，没有释放或释放不完全，导致程序无法再次访问或回收已分配的内存块。内存泄漏是一种常见的程序错误，可能会导致程序性能下降或最终崩溃。\n避免内存泄漏的措施：\n使用合适的数据结构： 使用合适的数据结构来管理内存，例如，使用数组、链表或树来组织数据，以便在不再需要时可以轻松释放内存。 遵循分配与释放的一一对应： 每次分配内存后，都要确保在不再需要时释放它。维护良好的分配和释放的一一对应关系是避免内存泄漏的关键。 注意边界条件： 确保在处理边界条件时正确分配和释放内存，例如，在循环中分配内存时要确保循环终止后释放内存。 指针数组与数组指针的区别？ # 指针数组（Pointer Array） # 指针数组是一个数组，其中的每个元素都是一个指针。 每个指针可以指向不同类型的数据或相同类型的数据。 指针数组通常用于存储多个字符串或多个对象的地址，以便可以通过循环或索引来访问这些元素。 数组指针（Array Pointer） # 数组指针是一个指针，它指向一个数组。 数组指针通常用于访问整个数组，而不是单个元素。 数组指针的类型与其指向的数组的类型相关。 总结：\n指针数组是一个数组，其元素是指针。 数组指针是一个指针，它指向一个数组。 指针数组通常用于存储多个指向不同对象的指针。 数组指针通常用于访问整个数组，尤其在多维数组的情况下非常有用。 函数指针和指针函数有什么区别? # 函数指针（Function Pointer）和指针函数（Pointer to Function）是两个不同的概念，它们具有不同的用途和行为：\n函数指针（Function Pointer）：\n函数指针是指向函数的指针变量。它存储的是函数的地址，可以用来调用相应地址上的函数。 函数指针的声明形式类似于函数的声明，只是将函数名替换为指针变量名，并在前面加上星号（*）表示这是一个指针。 int (*funcPtr)(int, int); // 声明一个函数指针，指向一个接受两个int参数并返回int的函数 函数指针通常用于实现函数回调、动态选择要调用的函数、实现多态等高级用途。 指针函数（Pointer to Function）：\n指针函数是一个返回指针的函数，它返回指向某种类型的指针的值。 指针函数的声明形式类似于函数的声明，只是返回值类型是一个指针类型。 int* someFunction(); // 声明一个指针函数，返回一个指向int的指针 指针函数通常用于返回动态分配的内存块的指针或特定类型的指针。 总结：\n函数指针是指向函数的指针变量，用于调用函数。 指针函数是一个函数，它返回一个指针。 这两者之间的区别在于它们的声明和用途。函数指针用于指向和调用函数，而指针函数是一个函数，它返回指针。 数组名和指针的区别？ # char heart[] = \u0026#34;I love Tillie!\u0026#34;; char *head = \u0026#34;I love Millie!\u0026#34;; 主要差别 # 数组名 heart 是个对象，而指针 *head 是个变量。\n应用差别 # 两者都可以使用下标索引：\nfor(i = 0; i \u0026lt; 6; i++) putchar(heart[i]); for(i = 0; i \u0026lt; 6; i++) putchar(head[i]); 两者都可以指针加法\nfor(i = 0; i \u0026lt; 6; i++) putchar(*(heart + i)); for(i = 0; i \u0026lt; 6; i++) putchar(*(head + i)); 只有指针可以使用自增加法，因为数组名是常量，所以不能使用\nwhile(*(hear) != \u0026#34;\\0\u0026#34;) putchar(*(head++)); 常量指针、指针常量和指向常量的指针常量三者区别？ # 常量指针（const pointer）： 常量指针是一个指针，它指向一个常量对象。这意味着通过该指针不能修改所指向的对象的值，但可以修改该指针本身的值，使其指向其他对象。声明一个常量指针的方式是在指针变量前加上const关键字。\nint num = 10; const int *ptr = \u0026amp;num; ptr是一个常量指针，它指向一个整型常量num。通过ptr不能修改num的值，但可以修改ptr本身的值。\n指针常量（pointer to constant）： 指针常量是一个指针，它被声明为常量，即指针的值不能改变。这意味着不能通过该指针修改所指向的对象的值，但可以修改所指向对象的地址。声明一个指针常量的方式是在指针类型前加上const关键字。\nint num = 10; int *const ptr = \u0026amp;num; 在上面的示例中，ptr是一个指针常量，它指向一个整型变量num。通过ptr可以修改num的值，但不能修改ptr本身的值。\n指向常量的指针常量（constant pointer to constant）： 指向常量的指针常量既不能修改所指向的常量对象的值，也不能修改指针本身的值。声明一个指向常量的指针常量的方式是在指针类型前后都加上const关键字。\nconst int num = 10; const int *const ptr = \u0026amp;num; 在上面的示例中，ptr是一个指向整型常量num的指针常量。通过ptr既不能修改num的值，也不能修改ptr本身的值。\n总结：\n常量指针可以修改指针本身的值但不能修改所指向对象的值。 指针常量可以修改所指向对象的值但不能修改指针本身的值。 指向常量的指针常量既不能修改所指向的对象的值，也不能修改指针本身的值。 什么是野指针？如何避免野指针？ # 什么是野指针 # 野指针（Dangling Pointer）是指指向已经释放或不再有效的内存地址的指针。野指针是一个危险的编程错误，因为它可以导致未定义的行为，程序崩溃或数据损坏。\n野指针通常发生在以下情况：\n释放后未置空：当你使用 free 或 delete 释放动态分配的内存后，如果没有将指针设置为 NULL，指针仍然包含先前分配的地址。在这种情况下，指针成为野指针，因为它指向已释放的内存。\nint* ptr = (int*)malloc(sizeof(int)); free(ptr); // 释放内存 // 现在 ptr 是野指针，因为它仍然包含之前分配的地址 函数返回局部变量的指针：当一个函数返回一个指向局部变量的指针时，该指针在函数退出后会成为野指针，因为局部变量的生命周期已经结束。\nint* getLocalPointer() { int x = 10; return \u0026amp;x; // 返回局部变量的地址 } int* ptr = getLocalPointer(); // ptr 是野指针 在超出作用域的情况下使用指针：如果在变量的作用域之外使用指向该变量的指针，那么指针就成为野指针。\nint* ptr; { int x = 42; ptr = \u0026amp;x; // 在 x 的作用域之外使用 ptr } // 现在 ptr 是野指针，因为它指向已经销毁的变量 x 访问已释放的对象：如果尝试访问已经释放的对象，指针也会成为野指针。\ncCopy code int* ptr = (int*)malloc(sizeof(int)); free(ptr); // 释放内存 *ptr = 42; // 尝试访问已释放的内存，ptr 是野指针 如何避免野指针 # 避免返回指向局部变量的指针。\n在释放内存后，将指针设置为 NULL，以避免访问已释放的内存。\n对支持进行初始化NULL。\n使用malloc分配内存，并检查是否分配成功以及清空内存中的数据。\n// 使用 malloc 分配内存 int* ptr; // 声明一个指向整数的指针 ptr = (int*)malloc(sizeof(int)); // 分配一个整数大小的内存块 if (ptr == NULL) { // 检查内存是否成功分配 printf(\u0026#34;内存分配失败\\n\u0026#34;); return 1; } //s是 需要置零的空间的起始地址; n是 要置零的数据字节个数。 void bzero(void *s, int n); // 如果要清空空间的首地址为p，value为值，size为字节数。 void memset(void *start, int value, int size); 不用控制流语句，打印1～1000之间所有数值？ # #include \u0026lt;stdio.h\u0026gt; #define A(x) x;x;x;x;x;x;x;x;x; int main () { int n=1; A(A(A(printf(\u0026#34;%d\u0026#34;, n++)))); return 0; } 全局变量和局部变量区别？ # 作用域不同：全局变量作用域全局有效，局部变量作用域在当前局部有效。 生命周期不同：全局变量生命周期随主程序的开始，随其结束而结束；局部变量生命周期随局部循环体或函数的开始而开始，结束而结束。 以下代码什么意思？ # *(arr[2]+1)、*(\u0026amp;arr[2][2])、(*(arr+1))[2] *(arr[2]+1)： 这个表达式首先访问 arr 数组的第三个元素（由 [2] 指定），因为C语言中数组的索引从0开始。 arr[2] 表示第三个元素，通常是一个指向整数的指针（假设 arr 是一个二维整数数组）。 然后，我们在这个指针上执行 +1 操作，这将使指针移动到下一个整数位置。 最后，* 运算符用于间接访问这个新位置，即获取指针指向的整数的值。 *(\u0026amp;arr[2][2])： 这个表达式首先访问 arr 数组的第三行第三列元素（由 [2][2] 指定）。 arr[2][2] 表示第三行第三列的元素，通常是一个整数。 然后，\u0026amp; 运算符用于获取这个整数的地址，即指向这个整数的指针。 最后，* 运算符用于间接访问这个指针，即获取指针指向的整数的值。 (*(arr+1))[2]： 这个表达式首先执行 arr+1 运算，它将移动到数组 arr 中的第二行（假设 arr 是一个二维数组，且索引从0开始）。 然后，*(arr+1) 表示第二行的整个子数组，通常是一个指向整数的指针。 最后，[2] 运算符用于访问子数组的第三个元素（由 [2] 指定），即获取指针指向的第三个整数的值。 求解整型二进制表示中1的个数？ # #include \u0026lt;stdio.h\u0026gt; int countOnes(int num) { int count = 0; while (num != 0) { count += (num \u0026amp; 1); // 使用位运算检查最低位是否为1 num \u0026gt;\u0026gt;= 1; // 右移一位，继续检查下一位 } return count; } int main() { int number = 42; // 要计算的整数 int onesCount = countOnes(number); printf(\u0026#34;整数 %d 的二进制中包含 %d 个1。\\n\u0026#34;, number, onesCount); return 0; } 求解整型二进制表示中0的个数？ # #include \u0026lt;stdio.h\u0026gt; int countZeros(int num) { int count = 0; while (num != 0) { count += ((num \u0026amp; 1) == 0); // 使用位运算检查最低位是否为0 num \u0026gt;\u0026gt;= 1; // 右移一位，继续检查下一位 } return count; } int main() { int number = 42; // 要计算的整数 int zerosCount = countZeros(number); printf(\u0026#34;整数 %d 的二进制中包含 %d 个0。\\n\u0026#34;, number, zerosCount); return 0; } 不使用额外变量或空间交换两个变量值？ # a = a + b; b = a - b; a = a - b; a = a ^ b; b = a ^ b; a = a ^ b; "},{"id":5,"href":"/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml-%E5%9B%BE/","title":"Uml 图","section":"设计模式","content":" UML图 # 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\nUML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\n1 类图概述 # 类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n2 类图的作用 # 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 3 类的表示方式 # 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：\n+：表示public\n-：表示private\n#：表示protected\n属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]\n方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]\n注意：\n​\t1，中括号中的内容表示是可选的\n​\t2，也有将类型放在变量名前面，返回值类型放在方法名前面\n举个栗子：\n上图Demo类定义了三个方法：\nmethod()方法：修饰符为public，没有参数，没有返回值。 method1()方法：修饰符为private，没有参数，返回值类型为String。 method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。 4 类图的表示方式 # 4.1 关联关系 # 关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n关联又可以分为单向关联，双向关联，自关联。\n4.1.1 单向关联 # 在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\n4.1.2 双向关联 # 从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。\n在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\u0026lt;Product\u0026gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。\n4.1.3 自关联 # 自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。\n4.2 聚合关系 # 聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。\n聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：\n4.3 组合关系 # 组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。\n在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：\n4.4 依赖关系 # 依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：\n4.5 继承关系 # 继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：\n4.6 实现关系 # 实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。\n"},{"id":6,"href":"/notes/%E5%85%AB%E8%82%A1/%E5%B9%B6%E5%8F%91/","title":"Concurrence","section":"Java八股","content":" 基础 # 1.并行跟并发有什么区别？ # 并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。 并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。 2.说说什么是进程和线程？ # 进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。 线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。 3.说说线程有几种创建方式？ # Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。\n继承Thread类，重写run()方法，调用start()方法启动线程\npublic class ThreadTest { /** * 继承Thread类 */ public static class MyThread extends Thread { @Override public void run() { System.out.println(\u0026#34;This is child thread\u0026#34;); } } public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); } } 实现 Runnable 接口，重写run()方法\npublic class RunnableTask implements Runnable { public void run() { System.out.println(\u0026#34;Runnable!\u0026#34;); } public static void main(String[] args) { RunnableTask task = new RunnableTask(); new Thread(task).start(); } } 实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值\npublic class CallerTask implements Callable\u0026lt;String\u0026gt; { public String call() throws Exception { return \u0026#34;Hello,i am running!\u0026#34;; } public static void main(String[] args) { //创建异步任务 FutureTask\u0026lt;String\u0026gt; task=new FutureTask\u0026lt;String\u0026gt;(new CallerTask()); //启动线程 new Thread(task).start(); try { //等待执行完成，并获取返回结果 String result=task.get(); System.out.println(result); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } 4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？ # JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。\n5.线程有哪些常用的调度方法？ # 等待：wait()、join() 通知：notify()、notifyAll() 让出优先权：yield() 中断： interrupt() 、isInterrupted() 休眠：sleep(long millis) 6.线程有几种状态？ # 状态 说明 NEW 初始状态：线程被创建，但还没有调用start()方法 RUNNABLE 运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行” BLOCKED 阻塞状态：表示线程阻塞于锁 WAITING 等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断） TIME_WAITING 超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的 TERMINATED 终止状态：表示当前线程已经执行完毕 7.什么是线程上下文切换？ # 使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。\n8.守护线程了解吗？ # Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。如在JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。\n区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。\n9.线程间有哪些通信方式？ # volatile和synchronized关键字\n等待/通知机制\n管道输入/输出流\n使用Thread.join()\n使用ThreadLocal\nThreadLocal # 10.ThreadLocal是什么？ # ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。\n11.ThreadLocal怎么实现的呢？ # Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。 ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。 每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。 ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。 12.ThreadLocal 内存泄露是怎么回事？ # ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用(只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。)。弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会造成了内存泄漏问题。\n13.怎么解决内存泄漏问题呢？ # 使用完ThreadLocal后，及时调用remove()方法释放内存空间。\nThreadLocal\u0026lt;String\u0026gt; localVariable = new ThreadLocal(); try { localVariable.set(\u0026#34;鄙人三某”); …… } finally { localVariable.remove(); } 14.ThreadLocalMap的结构了解吗？ # ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：元素数组和散列方法。\n元素数组\n一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。\nprivate Entry[] table; 散列方法\n散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一\u0026amp;运算（相当于取余）。\nint i = key.threadLocalHashCode \u0026amp; (table.length - 1); 这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增0x61c88647，这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash增量为 这个数字，带来的好处就是 hash 分布非常均匀。\n15.ThreadLocalMap怎么解决Hash冲突的？ # 都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——开放定址法。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。\n16.ThreadLocalMap扩容机制了解吗？ # 在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值(len*2/3)，就开始执行rehash()逻辑：\nif (!cleanSomeSlots(i, sz) \u0026amp;\u0026amp; sz \u0026gt;= threshold) rehash(); 再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断size \u0026gt;= threshold - threshold / 4 也就是size \u0026gt;= threshold* 3/4来决定是否需要扩容。\nprivate void rehash() { //清理过期Entry expungeStaleEntries(); //扩容 if (size \u0026gt;= threshold - threshold / 4) resize(); } //清理过期Entry private void expungeStaleEntries() { Entry[] tab = table; int len = tab.length; for (int j = 0; j \u0026lt; len; j++) { Entry e = tab[j]; if (e != null \u0026amp;\u0026amp; e.get() == null) expungeStaleEntry(j); } } 接着看看具体的resize()方法，扩容后的newTab的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的newTab，遍历完成之后，oldTab中所有的entry数据都已经放入到newTab中了，然后table引用指向newTab\n// 扩容规则:双倍扩容 private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j \u0026lt; oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal\u0026lt;?\u0026gt; k = e.get(); if (k == null) { // 扩容期间发现过期元素，会跳过 e.value = null; // Help the GC } else { // 将旧数组中没有过期的元素挪到新数组里 int h = k.threadLocalHashCode \u0026amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } // 重新设置阈值 setThreshold(newLen); size = count; table = newTab; } 17.父子线程怎么共享数据？ # 在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。\npublic class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\u0026#34;不擅技术\u0026#34;); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\u0026#34;鄙人三某 ，\u0026#34; + threadLocal.get()); } }; t.start(); } } 原理很简单，在Thread类里还有另外一个变量：\nThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 在Thread.init的时候，如果父线程的inheritableThreadLocals不为空，就把它赋给当前线程（子线程）的inheritableThreadLocals 。\nif (inheritThreadLocals \u0026amp;\u0026amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); Java内存模型 # 18.说一下你对Java内存模型（JMM）的理解？ # Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。\nJMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。\n19.说说你对原子性、可见性、有序性的理解？ # 原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。\n原子性：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。 可见性：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。 有序性：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。 20.原子性、可见性、有序性都应该怎么保证呢？ # 原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用synchronized 。 可见性：Java是利用volatile关键字来保证可见性的，除此之外，final和synchronized也能保证可见性。 有序性：synchronized或者volatile都可以保证多线程之间操作的有序性。 21. 分析下面几行代码的原子性？ # int i = 2; int j = i; i++; i = i + 1; 第1句是基本类型赋值，是原子性操作。 第2句先读i的值，再赋值到j，两步操作，不能保证原子性。 第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。 22.那说说什么是指令重排？ # 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。\n编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 23.as-if-serial又是什么？单线程的程序一定是顺序的吗？ # as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。\n24.volatile实现原理了解吗？ # volatile有两个作用，保证可见性和有序性。\nvolatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。\n相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。\n锁 # 25.synchronized用过吗？怎么使用？ # synchronized经常用的，用来保证代码的原子性。synchronized主要有三种用法：\n修饰实例方法：作用于当前对象实例加锁，锁方法的调用者，谁先拿到锁谁先执行，普通方法不受限制 修饰静态方法：作用于当前类加锁，类一加载就有了，锁的是当前类，任何对象实例谁先拿到锁谁先执行 修饰代码块 ：指定加锁对象，对给定对象/类加锁。 26.synchronized的实现原理？ # synchronized修饰代码块时，JVM采用monitorenter、monitorexit两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。 synchronized修饰同步方法时，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。 27.synchronized怎么保证可见性？ # 线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。 线程加锁后，其它线程无法获取主内存中的共享变量。 线程解锁前，必须把共享变量的最新值刷新到主内存中。 28.synchronized怎么保证有序性？ # synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。\n所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。\n29.synchronized怎么实现可重入的呢？ # synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。\nsynchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。\n之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。\n30.锁升级？synchronized优化了解吗？ # Java对象头里，有一块结构，叫Mark Word标记字段，这块结构会随着锁的状态变化而变化。\n"},{"id":7,"href":"/notes/mybatisplus/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"MP快速入门","section":"MyBatisPlus","content":"共分为以下6步：\n1 创建表 # 创建数据表，用于测试使用，数据库名为 mybatis_plus，建表语句如下：\n# 创建表 CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT \u0026#39;主键ID\u0026#39;, name VARCHAR(30) NULL DEFAULT NULL COMMENT \u0026#39;姓名\u0026#39;, age INT(11) NULL DEFAULT NULL COMMENT \u0026#39;年龄\u0026#39;, email VARCHAR(50) NULL DEFAULT NULL COMMENT \u0026#39;邮箱\u0026#39;, PRIMARY KEY (id) ); # 插入数据 INSERT INTO user (id, name, age, email) VALUES (1, \u0026#39;Jone\u0026#39;, 18, \u0026#39;test1@baomidou.com\u0026#39;), (2, \u0026#39;Jack\u0026#39;, 20, \u0026#39;test2@baomidou.com\u0026#39;), (3, \u0026#39;Tom\u0026#39;, 28, \u0026#39;test3@baomidou.com\u0026#39;), (4, \u0026#39;Sandy\u0026#39;, 21, \u0026#39;test4@baomidou.com\u0026#39;), (5, \u0026#39;Billie\u0026#39;, 24, \u0026#39;test5@baomidou.com\u0026#39;); 2 导入坐标 # \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis-plus--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok用来简化实体类，注意 idea 中安装 lombok 插件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3 创建 application.yml 配置文件 # mysql5\n#mysql数据库连接 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus spring.datasource.username=root spring.datasource.password=123456 mysql8以上（spring boot 2.1）注意：driver和url的变化\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=root 注意：\n这里的 url 使用了 ?serverTimezone=GMT%2B8 后缀，因为 Spring Boot 2.1 集成了 8.0 版本的jdbc驱动，这个版本的 jdbc 驱动需要添加这个后缀，否则运行测试用例报告如下错误：java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more 这里的 driver-class-name 使用了 com.mysql.cj.jdbc.Driver ，在 jdbc8 中 建议使用这个驱动，之前的 com.mysql.jdbc.Driver 已经被废弃，否则运行测试用例的时候会有 WARN 信息 4 创建对应表的实体 # package com.atguigu.entity; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableId; import lombok.Data; @Data public class User { @TableId(type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; } @Data ：不需要写 set 和 get 方法\n@TableId(type = IdType.AUTO) ：自增\n5 创建 mapper # mapper 只需要继承 BaseMapper 即可，一般的查询语句 mp 会自动生成。\npackage com.atguigu.mapper; import com.atguigu.entity.User; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import org.springframework.stereotype.Repository; @Repository public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { } 6 创建配置类 # package com.atguigu; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ComponentScan; @SpringBootApplication @MapperScan(\u0026#34;com.atguigu.mapper\u0026#34;) public class GgktMpDemoApplication { public static void main(String[] args) { SpringApplication.run(GgktMpDemoApplication.class, args); } } "},{"id":8,"href":"/notes/jvm/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/","title":"程序计数器","section":"JVM","content":" 程序计数器（Program Counter Register） # 程序计数器用途 # 记住下一条 jvm 指令的执行地址，在物理上是通过寄存器来实现的。\n程序计数器执行流程 # 二进制字节码 ➡️ 解释器（中间解释器还需要去程序计数器取下一条指令的执行地址） ➡️ 机器码 ➡️ CPU。二进制字节码和 Java 源代码如下：\n二进制字节码 java 源代码 （每一条是jvm指令） 0: getstatic #20 // PrintStream out = System.out; 3: astore_1\t// -- 4: aload_1\t// out.println(1); 5: iconst_1\t// -- 6: invokevirtual #26\t// -- 9: aload_1\t// out.println(2); 10: iconst_2\t// -- 11: invokevirtual #26\t// --\t14: aload_1\t// out.println(3); 15: iconst_3\t// -- 16: invokevirtual #26\t// -- 19: aload_1\t// out.println(4); 20: iconst_4\t// -- 21: invokevirtual #26\t// -- 24: aload_1\t// out.println(5); 25: iconst_5\t// -- 26: invokevirtual #26\t// -- 29: return 程序计数器特点 # Java 虚拟机中唯一一个不会存在内存溢出的区 线程私有 "},{"id":9,"href":"/notes/redis/redis-key/","title":"Redis Key","section":"Redis","content":" Redis Key # keys *：查看当前库的所有 key\nexists key：判断某个 key 是否存在\ntype key：查看 key 是什么类型\ndel key：即时删除指定 key\nunlink key ：仅仅从 keyspace 元数据中删除，真正操作后续异步执行\nexpire key 10：为给定的 key 设置过期时间\nttl key：查看还有多少秒过期，-1 表示永不过期，-2表示已过期\nselect：命令切换数据库\ndbsize：查看当前数据库的 key 的数量\nflushdb：清空当前库\nflushall：通杀全部库\n"},{"id":10,"href":"/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%BA%8C/","title":"Tensor Flow 笔记（二）","section":"TensorFlow","content":" TensorFlow 笔记（二） # 介绍神经网络的优化过程，主要有：\n神经网络复杂度 指数衰减学习率 激活函数 损失函数 欠拟合与过拟合 正则化减少过拟合 优化器更新网络参数 1. 预备知识 # tf.where(条件语句，真返回A，假返回B)：条件语句，真返回A，假返回B a = tf.constant([1, 2, 3, 1, 1]) b = tf.constant([0, 1, 3, 4, 5]) c = tf.where(tf.greater(a, b), a, b) # 若a\u0026gt;b，返回 a 对应位置的元素，否则返回 b 对应位置的元素 输出：c = tf.Tensor([1 2 3 4 5], shape=(5,), dtype=int32) np.random.RandomState.rand(维度)：返回 [0, 1) 之间的随机数 rdm = np.random.RandomState(seed=1) a = rdm.rand() # 返回一个随机标量 b = rdm.rand(2, 3) # 返回维度为2行3列随机数矩阵 np.vstack(数组1， 数组2)：将两个数组按垂直方向叠加 a = np.array([1, 2, 3]) b = np.array([4, 5, 6]) c = np.vstack((a, b)) 结果： [[1 2 3] [4 5 6]] np.mgrid[]\t.ravel()\tnp.c_[] np.mgrid[起始值:结束值:步长, 起始值:结束值:步长, ...] # 几组生成的数据就几纬，列数由组参数决定 x.ravel() # 将 x 变为一维数组，\u0026#34;把 . 前的变量拉直\u0026#34; np.c_[] 使返回的间隔数值点配对 例： import numpy as np x, y = np.mgrid[1:3:1, 2:4:0.5] grid = np.c_[x.ravel(), y.ravel()] 2. 神经网络复杂度 # 空间复杂度：\n层数 = 隐藏层的层数 + 1个输出层 总参数 = 总w + 总b 时间复杂度：\n即乘加运算次数 3. 指数衰减学习率 # 可以先用较大的学习率，快速得到较优解，然后逐步减小学习率，使模型在训练后期稳定。 \\[指数衰减学习率 = 初始学习率 . 学习率衰减^{当前轮数 / 多少轮衰减一次}\\] epoch = 40 LR_BASE = 0.2 LR_DECAY = 0.99 LR_STEP = 1 for epoch in range(epoch): lr = LR_BASE * LR_DECAY ** (epoch / LR_STEP) with tf.GradientTape() as tape: loss = tf.square(w + 1) grads = tape.gradient(loss, w) w.assign_sub(lr * grads) 4.激活函数 # 4.1 Sigmoid 函数 # tf.nn.sigmoid(x) \\[f(x) = \\frac{1}{1\u0026#43;{e^{-x}}}\\] 特点：\n容易造成梯度消失(因为梯度小) 输出非0均值，收敛慢 幂运算复杂，训练时间长 4.2 Relu函数 # tf.nn.relu(x) \\[f(x) = max(x, 0) = \\begin{cases}0, \u0026amp; x\u0026lt;0 \\\\ 1, \u0026amp; x \\ge0\\end{cases}\\] 优点：\n解决了梯度消失问题 只需要判断输入是否大于0，计算速度快 收敛速度远快于sigmoid和tanh 缺点：\n输出非 0 均值，收敛慢 某些神经元可能永远未被激活，导致相应的参数永远不能被更新 4.2 总结 # 首选 relu 激活函数\n学习率设置较小值\n输入特征标准化，即让输入特征满足以 0 为均值，1 为标准差的正态分布\n初始参数中心化，即让随机生成的参数满足以0为均值， \\(\\sqrt\\frac{2}{当前输入特征个数}\\) 为标准差的正态分布。\n5.损失函数 # 损失函数：预测值（y）与已知答案（y_）的差距\n损失函数的优化目标：使 loss 最小，主要有以下损失函数\nmse (Mean Squared Error) 自定义 ce(Cross Entropy) 5.1 均方误差损失函数 # loss_mse = tf.reduce_mean(tf.square(y_-y)) \\[MSE(y\\_, y) = \\frac{\\Sigma^n_{i=1}(y-y\\_)^2}{n}\\] 例：\n预测酸奶日销量 y， \\(x_1\\) 和 \\(x_2\\) 是影响日常销量的因素。\n建模前，应预先采集的数据有：每日 \\(x_1\\) , \\(x_2\\) 和日销量 \\(y\\_\\) （即已知答案：最佳情况：产量=销量），拟造数据集 \\(X\\) , \\(Y\\_\\) : \\(y\\_=x_1 \u0026#43; x_2\\) 噪声： \\(-0.05~\u0026#43;0.05\\) 拟合可以预测销量的函数。\nimport tensorflow as tf import numpy as np SEED = 23455 rdm = np.random.RandomState(SEED) x = rdm.rand(32, 2) y_ = [[x1 + x2 + (rdm.rand() / 10.0 - 0.05)] for (x1, x2) in x] x = tf.cast(x, dtype=tf.float32) w1 = tf.Variable(tf.random.normal([2, 1], stddev=1, seed=1)) epoch = 15000 lr = 0.002 for epoch in range(epoch): with tf.GradientTape() as tape: y = tf.matmul(x, w1) loss_mse = tf.reduce_mean(tf.square(y_ - y)) grads = tape.gradient(loss_mse, w1) w1.assign_sub(lr * grads) if epoch % 500 == 0: print(\u0026#34;After %d training steps, w1 is \u0026#34; % (epoch)) print(w1.numpy(), \u0026#34;\\n\u0026#34;) print(\u0026#34;Final w1 is: \u0026#34;, w1.numpy()) Output: ... Final w1 is: [[1.0009792] [0.9977485]] 5.2 自定义损失函数 # 如 5.1 预测商品销量，预测多了，损失成本；预测少了，损失利润。若 \\(利润\\neq成本\\) 则 mse 产生的 loss 无法实现利益最大化。 \\[自定义损失函数：loss(y\\_,y)=\\Sigma{f({y\\_}, y)}\\] 优化 5.1 损失函数\nloss_zdy = tf.reduce_sum(tf.where(tf.greater(y, y_), COST(y-y_), PROFIT(y_-y))) \\[f(y\\_,y)=\\begin{cases}PROFIT*(y\\_-y), \u0026amp; y\u0026lt;y\\_ \u0026amp; 预测的y少了，损失利润\\\\ COST*(y-y\\_), \u0026amp; y \\ge y\\_ \u0026amp; 预测的y多了，损失成本 \\end{cases}\\] 例：\n预测酸奶销量，酸奶成本（COST）1元，酸奶利润（PROFIT）99元。预测少了损失利润99元，预测多了损失成本1元。预测少了损失大，希望生成的预测函数往多了预测。\nimport tensorflow as tf import numpy as np SEED = 23455 COST = 1 PROFIT = 99 rdm = np.random.RandomState(SEED) x = rdm.rand(32, 2) y_ = [[x1 + x2 + (rdm.rand() / 10.0 - 0.05)] for (x1, x2) in x] x = tf.cast(x, dtype=tf.float32) w1 = tf.Variable(tf.random.normal([2, 1], stddev=1, seed=1)) epoch = 15000 lr = 0.002 for epoch in range(epoch): with tf.GradientTape() as tape: y = tf.matmul(x, w1) # loss_mse = tf.reduce_mean(tf.square(y_ - y)) loss = tf.reduce_sum(tf.where(tf.greater(y, y_), (y-y_) * COST, (y_-y) * PROFIT)) grads = tape.gradient(loss, w1) w1.assign_sub(lr * grads) if epoch % 500 == 0: print(\u0026#34;After %d training steps, w1 is \u0026#34; % (epoch)) print(w1.numpy(), \u0026#34;\\n\u0026#34;) print(\u0026#34;Final w1 is: \u0026#34;, w1.numpy()) Output: Final w1 is: [[1.1420637] [1.101678 ]] 5.3 交叉熵损失函数（Cross Entropy） # 交叉熵损失函数：表征两个概率分布之间的距离\ntf.losses.categorical_crossentropy(y_, y) \\[H(y\\_,y)=-\\Sigma y\\_*\\ln y\\] softmax 与交叉熵结合：输出先过 softmax 函数，再计算 y 与 y_ 的交叉熵损失函数。\ntf.nn.softmax_cross_entropy_with_logits(y_, y) y_ = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 0,], [0, 1, 0]]) y = np.array([[12, 3, 2], [3, 10, 1], [1, 2, 5], [4, 6.5, 1.2], [3, 6, 1]]) y_pro = tf.nn.softmax(y) loss_ce1 = tf.losses.categorical_crossentropy(y_, y_pro) loss_ce2 = tf.nn.softmax_cross_entropy_with_logits(y_, y) tf.nn.softmax_cross_entropy_with_logits(y_, y) 函数内部就有 softmax算法，不用再 softmax 了 6. 欠拟合与过拟合 # 6.1 解决方案 # 欠拟合解决方法：\n增加输入特征项 增加网络参数 减少正则化参数 过拟合解决方法：\n数据清洗 增大训练集 采用正则化 增大正则化参数 6.2 正则化缓解过拟合 # 正则化在损失函数中引入模型复杂度指标，利用给 W 加权值，弱化了训练数据的噪声（一般不正则化b） \\[loss = loss(y, y\\_) \u0026#43; REGULARIZER * loss(w)\\] L1 正则化： \\[loss_{L1}(w) = \\Sigma{|w_i|}\\] L2 正则化： \\[loss_{L2}(w)=\\Sigma{|w_{i}^2|}\\] 正则化的选择：\nL1 正则化大概率会使很多参数变为 0，因此该方法可通过稀疏参数，即减少参数的数量，降低复杂度。 L2 正则化会使参数很接近 0 但不为 0，因为该方法可通过减少参数值的大小降低复杂度。 7. 优化器 # 7.1 更新参数四步骤 # 计算 \\(t\\) 时刻损失函数关于当前参数的梯度 \\(g_t=\\nabla{loss}=\\frac{\\partial loss}{\\partial (w_t)} \\) 计算 \\(t\\) 时刻一阶动量 \\(m_t\\) 和二阶动量 \\(V_t\\) 计算 \\(t\\) 时刻下降梯度： \\(\\eta{_t}=lr. \\frac{m_t}{\\sqrt{V_t}}\\) 计算 t+1 时刻参数： \\(w_{t\u0026#43;1}=w_t - \\eta{_t} = w_t - lr. \\frac{m_t}{\\sqrt V_t}\\) 其中：\n一阶动量：与梯度相关的函数 二阶动量：与梯度平方相关的函数 7.2 SGD（无momentum），常用的梯度下降法 # \\[m_t = g_t \\hspace{3cm} V_t = 1\\] \\[\\eta_t = lr. \\frac {m_t}{\\sqrt V_t} = lr.g_t\\] \\[w_{t\u0026#43;1} = w_t - \\eta_t = w_t-lr. \\frac {m_t}{\\sqrt{V_t}}=w_t-lr.g_t\\] \\[w_{t\u0026#43;1}=w_t-lr.\\frac{\\partial loss}{\\partial (w_t)}\\] 7.3 SGDM（含momentum的SGD），在 SGD 基础上增加了一阶动量 # \\[m_t = \\beta.m_{t-1} \u0026#43; (1-\\beta).g_t \\hspace{3cm} V_t = 1\\] \\[\\eta_t=lr.\\frac{m_t}{\\sqrt{V_t}}=lr.m_t=lr.(\\beta.m_{t-1} \u0026#43; (1-\\beta).g_t)\\] \\[w_{t\u0026#43;1} = w_t - \\eta_t=w_t-lr.(\\beta.m_{t-1} \u0026#43; (1-\\beta).g_t)\\] 7.4 Adagrad, 在 SGD 基础上增加二阶动量 # \\[m_t = g_t \\hspace{3cm} V_t = \\Sigma^t_\\tau g^2_\\tau\\] \\[\\eta_t = lr.\\frac{m_t}{\\sqrt V_t} = lr.\\frac{g_t}{\\sqrt{\\Sigma^t_\\tau g^2_\\tau}}\\] \\[w_{t\u0026#43;1} = w_t - \\eta_t=w_t-lr.\\frac{g_t}{\\Sigma^t_\\tau g^2_\\tau}\\] 7.5 RMSProp，SGD基础上增加二阶动量 # \\[m_t = g_t \\hspace{3cm} V_t = \\beta.V_{t-1} \u0026#43; (1-\\beta).g_t^2\\] \\[\\eta_t = lr.\\frac{m_t}{\\sqrt V_t} = lr.\\frac{g_t}{\\sqrt{\\beta.V_{t-1} \u0026#43; (1-\\beta).g_t^2}}\\] \\[w_{t\u0026#43;1} = w_t - \\eta_t=w_t-lr.\\frac{g_t}{\\sqrt{\\beta.V_{t-1} \u0026#43; (1-\\beta).g_t^2}}\\] 7.6 Adam，同时结合 SGDM 的一阶动量和 RMSProp 二阶动量 # \\[m_t = \\beta.m_{t-1} \u0026#43; (1-\\beta).g_t \\hspace{1cm} 修正一阶动量的偏差：\\widehat{m_t}=\\frac{m_t}{1-\\beta_1^t}\\] \\[V_t = \\beta.V_{t-1} \u0026#43; (1-\\beta).g_t^2 \\hspace{1cm} 修正一阶动量的偏差：\\widehat{V_t}=\\frac{V_t}{1-\\beta_2^t}\\] \\[\\eta_t = lr.\\frac{\\widehat{m_t}}{\\sqrt{\\widehat{V_t}}}=lr.\\frac{\\frac{m_t}{1-\\beta_1^t}}{\\frac{V_t}{1-\\beta_2^t}}\\] \\[w_{t\u0026#43;1} = w_t - \\eta_t = w_t - lr.\\frac{\\frac{m_t}{1-\\beta_1^t}}{\\frac{V_t}{1-\\beta_2^t}}\\] "},{"id":11,"href":"/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","title":"设计原则","section":"设计模式","content":" 设计原则 # 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。\n1 开闭原则 # 对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\n想要达到这样的效果，我们需要使用接口和抽象类。\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。\n【例】搜狗输入法 的皮肤设计。\n分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\n2 里氏代换原则 # 里氏代换原则是面向对象设计的基本原则之一。\n里氏代换原则：**任何基类可以出现的地方，子类一定可以出现。**通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\n下面看一个里氏替换原则中经典的一个例子\n【例】正方形不是长方形。\n在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。\n代码如下：\n长方形类（Rectangle）：\npublic class Rectangle { private double length; private double width; public double getLength() { return length; } public void setLength(double length) { this.length = length; } public double getWidth() { return width; } public void setWidth(double width) { this.width = width; } } 正方形（Square）：\n由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。\npublic class Square extends Rectangle { public void setWidth(double width) { super.setLength(width); super.setWidth(width); } public void setLength(double length) { super.setLength(length); super.setWidth(length); } } 类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。\npublic class RectangleDemo { public static void resize(Rectangle rectangle) { while (rectangle.getWidth() \u0026lt;= rectangle.getLength()) { rectangle.setWidth(rectangle.getWidth() + 1); } } //打印长方形的长和宽 public static void printLengthAndWidth(Rectangle rectangle) { System.out.println(rectangle.getLength()); System.out.println(rectangle.getWidth()); } public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setLength(20); rectangle.setWidth(10); resize(rectangle); printLengthAndWidth(rectangle); System.out.println(\u0026#34;============\u0026#34;); Rectangle rectangle1 = new Square(); rectangle1.setLength(10); resize(rectangle1); printLengthAndWidth(rectangle1); } } 我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。 我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。\n如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口\n3 依赖倒转原则 # **高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。**简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n下面看一个例子来理解依赖倒转原则\n【例】组装电脑\n现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\n类图如下：\n代码如下：\n希捷硬盘类（XiJieHardDisk）:\npublic class XiJieHardDisk implements HardDisk { public void save(String data) { System.out.println(\u0026#34;使用希捷硬盘存储数据\u0026#34; + data); } public String get() { System.out.println(\u0026#34;使用希捷希捷硬盘取数据\u0026#34;); return \u0026#34;数据\u0026#34;; } } Intel处理器（IntelCpu）：\npublic class IntelCpu implements Cpu { public void run() { System.out.println(\u0026#34;使用Intel处理器\u0026#34;); } } 金士顿内存条（KingstonMemory）：\npublic class KingstonMemory implements Memory { public void save() { System.out.println(\u0026#34;使用金士顿作为内存条\u0026#34;); } } 电脑（Computer）：\npublic class Computer { private XiJieHardDisk hardDisk; private IntelCpu cpu; private KingstonMemory memory; public IntelCpu getCpu() { return cpu; } public void setCpu(IntelCpu cpu) { this.cpu = cpu; } public KingstonMemory getMemory() { return memory; } public void setMemory(KingstonMemory memory) { this.memory = memory; } public XiJieHardDisk getHardDisk() { return hardDisk; } public void setHardDisk(XiJieHardDisk hardDisk) { this.hardDisk = hardDisk; } public void run() { System.out.println(\u0026#34;计算机工作\u0026#34;); cpu.run(); memory.save(); String data = hardDisk.get(); System.out.println(\u0026#34;从硬盘中获取的数据为：\u0026#34; + data); } } 测试类（TestComputer）：\n测试类用来组装电脑。\npublic class TestComputer { public static void main(String[] args) { Computer computer = new Computer(); computer.setHardDisk(new XiJieHardDisk()); computer.setCpu(new IntelCpu()); computer.setMemory(new KingstonMemory()); computer.run(); } } 上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。\n根据依赖倒转原则进行改进：\n代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。\n类图如下：\n电脑（Computer）：\npublic class Computer { private HardDisk hardDisk; private Cpu cpu; private Memory memory; public HardDisk getHardDisk() { return hardDisk; } public void setHardDisk(HardDisk hardDisk) { this.hardDisk = hardDisk; } public Cpu getCpu() { return cpu; } public void setCpu(Cpu cpu) { this.cpu = cpu; } public Memory getMemory() { return memory; } public void setMemory(Memory memory) { this.memory = memory; } public void run() { System.out.println(\u0026#34;计算机工作\u0026#34;); } } 面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。\n4 接口隔离原则 # 客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。\n下面看一个例子来理解接口隔离原则\n【例】安全门案例\n我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：\n上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：\n代码如下：\nAntiTheft（接口）：\npublic interface AntiTheft { void antiTheft(); } Fireproof（接口）：\npublic interface Fireproof { void fireproof(); } Waterproof（接口）：\npublic interface Waterproof { void waterproof(); } HeiMaSafetyDoor（类）：\npublic class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof { public void antiTheft() { System.out.println(\u0026#34;防盗\u0026#34;); } public void fireproof() { System.out.println(\u0026#34;防火\u0026#34;); } public void waterproof() { System.out.println(\u0026#34;防水\u0026#34;); } } ItcastSafetyDoor（类）：\npublic class ItcastSafetyDoor implements AntiTheft,Fireproof { public void antiTheft() { System.out.println(\u0026#34;防盗\u0026#34;); } public void fireproof() { System.out.println(\u0026#34;防火\u0026#34;); } } 5 迪米特法则 # 迪米特法则又叫最少知识原则。\n只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。\n其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n下面看一个例子来理解迪米特法则\n【例】明星与经纪人的关系实例\n明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。\n类图如下：\n代码如下：\n明星类（Star）\npublic class Star { private String name; public Star(String name) { this.name=name; } public String getName() { return name; } } 粉丝类（Fans）\npublic class Fans { private String name; public Fans(String name) { this.name=name; } public String getName() { return name; } } 媒体公司类（Company）\npublic class Company { private String name; public Company(String name) { this.name=name; } public String getName() { return name; } } 经纪人类（Agent）\npublic class Agent { private Star star; private Fans fans; private Company company; public void setStar(Star star) { this.star = star; } public void setFans(Fans fans) { this.fans = fans; } public void setCompany(Company company) { this.company = company; } public void meeting() { System.out.println(fans.getName() + \u0026#34;与明星\u0026#34; + star.getName() + \u0026#34;见面了。\u0026#34;); } public void business() { System.out.println(company.getName() + \u0026#34;与明星\u0026#34; + star.getName() + \u0026#34;洽淡业务。\u0026#34;); } } 6 合成复用原则 # 合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n通常类的复用分为继承复用和合成复用两种。\n继承复用虽然有简单和易实现的优点，但它也存在以下缺点：\n继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：\n它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 对象间的耦合度低。可以在类的成员位置声明抽象。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 下面看一个例子来理解合成复用原则\n【例】汽车分类管理程序\n汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：\n从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\n"},{"id":12,"href":"/notes/%E5%85%AB%E8%82%A1/mybatis/","title":"MyBatis","section":"Java八股","content":" 1. 说说什么是MyBatis? # Mybatis 是一个半 自动ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。 MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 2.为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？ # Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。 而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。 3.Hibernate 和 MyBatis 有什么区别？ # 相同点\n都是对jdbc的封装，都是应用于持久层的框架。 不同点\n1）映射关系\nMyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单 Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂 2）SQL优化和移植性\nHibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。 3）MyBatis和Hibernate的适用场景不同\nHibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统 MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站 3. MyBatis使用过程？生命周期？ # MyBatis基本使用的过程大概可以分为这么几步：\n1）创建SqlSessionFactory\n可以从配置或者直接编码来创建SqlSessionFactory\nString resource = \u0026#34;org/mybatis/example/mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 2）通过SqlSessionFactory创建SqlSession\nSqlSession（会话）可以理解为程序和数据库之间的桥梁\nSqlSession session = sqlSessionFactory.openSession(); 3）通过sqlsession执行数据库操作\n可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：\nBlog blog = (Blog)session.selectOne(\u0026#34;org.mybatis.example.BlogMapper.selectBlog\u0026#34;, 101); 更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：\nBlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); 4）调用session.commit()提交事务\n如果是更新、删除语句，我们还需要提交一下事务。\n5）调用session.close()关闭会话\n最后一定要记得关闭会话。\n4.MyBatis生命周期？ # SqlSessionFactoryBuilder：一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。\nSqlSessionFactory：SqlSessionFactory 是用来创建SqlSession的，相当于一个数据库连接池，每次创建SqlSessionFactory都会使用数据库资源，多次创建和销毁是对资源的浪费。所以SqlSessionFactory是应用级的生命周期，而且应该是单例的。\nSqlSession：SqlSession相当于JDBC中的Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的生命周期是一次请求或一个方法。\nMapper：映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。\n5. 在mapper中如何传递多个参数？ # 顺序传参法\npublic User selectUser(String name, int deptId); \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultMap=\u0026#34;UserResultMap\u0026#34;\u0026gt; select * from user where user_name = #{0} and dept_id = #{1} \u0026lt;/select\u0026gt; \\#{}里面的数字代表传入参数的顺序。 这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。 @Param注解传参法\npublic User selectUser(@Param(\u0026#34;userName\u0026#34;) String name, int @Param(\u0026#34;deptId\u0026#34;) deptId); \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultMap=\u0026#34;UserResultMap\u0026#34;\u0026gt; select * from user where user_name = #{userName} and dept_id = #{deptId} \u0026lt;/select\u0026gt; \\#{}里面的名称对应的是注解@Param括号里面修饰的名称。 这种方法在参数不多的情况还是比较直观的（推荐使用）。 Map传参法\npublic User selectUser(Map\u0026lt;String, Object\u0026gt; params); \u0026lt;select id=\u0026#34;selectUser\u0026#34; parameterType=\u0026#34;java.util.Map\u0026#34; resultMap=\u0026#34;UserResultMap\u0026#34;\u0026gt; select * from user where user_name = #{userName} and dept_id = #{deptId} \u0026lt;/select\u0026gt; \\#{}里面的名称对应的是Map里面的key名称。 这种方法适合传递多个参数，且参数易变能灵活传递的情况。 Java Bean传参法\npublic User selectUser(User user); \u0026lt;select id=\u0026#34;selectUser\u0026#34; parameterType=\u0026#34;com.jourwon.pojo.User\u0026#34; resultMap=\u0026#34;UserResultMap\u0026#34;\u0026gt; select * from user where user_name = #{userName} and dept_id = #{deptId} \u0026lt;/select\u0026gt; \\#{}里面的名称对应的是User类里面的成员属性。 这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。 6. 实体类属性名和表中字段名不一样 ，怎么办? # 第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。\n\u0026lt;select id=\u0026#34;getOrder\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.jourwon.pojo.Order\u0026#34;\u0026gt; select order_id id, order_no orderno ,order_price price form orders where order_id=#{id}; \u0026lt;/select\u0026gt; 第2种： 通过resultMap 中的来映射字段名和实体类属性名的一一对应的关系。\n\u0026lt;select id=\u0026#34;getOrder\u0026#34; parameterType=\u0026#34;int\u0026#34; resultMap=\u0026#34;orderResultMap\u0026#34;\u0026gt; select * from orders where order_id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultMap type=\u0026#34;com.jourwon.pojo.Order\u0026#34; id=\u0026#34;orderResultMap\u0026#34;\u0026gt; \u0026lt;!–用id属性来映射主键字段–\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;order_id\u0026#34;\u0026gt; \u0026lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–\u0026gt; \u0026lt;result property =\u0026#34;orderno\u0026#34; column =\u0026#34;order_no\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;price\u0026#34; column=\u0026#34;order_price\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; 7.Mybatis是否可以映射Enum枚举类？ # Mybatis当然可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。 TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。 8.#{}和${}的区别? # #{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。 Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。 #{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入 #{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外 9.模糊查询like语句该怎么写? # 1 ’%${question}%’ 可能引起SQL注入，不推荐 2 \u0026quot;%\u0026quot;#{question}\u0026quot;%\u0026quot; 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ \u0026lsquo;，所以这里 % 需要使用双引号\u0026quot; \u0026ldquo;，不能使用单引号 ’ \u0026lsquo;，不然会查不到任何结果。 3 CONCAT('%',#{question},'%') 使用CONCAT()函数，（推荐✨） 4 使用bind标签（不推荐） 10.Mybatis能执行一对一、一对多的关联查询吗？ # 当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。\n一对一: 比如订单和支付是一对一的关系，这种关联的实现：\n// 实体类: public class Order { private Integer orderId; private String orderDesc; /** * 支付对象 */ private Pay pay; //…… } \u0026lt;!-- # 结果映射 --\u0026gt; \u0026lt;!-- 订单resultMap --\u0026gt; \u0026lt;resultMap id=\u0026#34;peopleResultMap\u0026#34; type=\u0026#34;cn.fighter3.entity.Order\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;orderId\u0026#34; column=\u0026#34;order_id\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;orderDesc\u0026#34; column=\u0026#34;order_desc\u0026#34;/\u0026gt; \u0026lt;!--一对一结果映射--\u0026gt; \u0026lt;association property=\u0026#34;pay\u0026#34; javaType=\u0026#34;cn.fighter3.entity.Pay\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;payId\u0026#34; property=\u0026#34;pay_id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;account\u0026#34; property=\u0026#34;account\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- # 关联查询 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;getTeacherMap\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; select * from order o left join pay p on o.order_id=p.order_id where o.order_id=#{orderId} \u0026lt;/select\u0026gt; 一对多\u0026lt;collection\u0026gt;：比如商品分类和商品，是一对多的关系。\n// 实体类 public class Category { private int categoryId; private String categoryName; /** * 商品列表 **/ List\u0026lt;Product\u0026gt; products; //…… } \u0026lt;!-- # 结果映射 --\u0026gt; \u0026lt;resultMap type=\u0026#34;Category\u0026#34; id=\u0026#34;categoryBean\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;categoryId\u0026#34; property=\u0026#34;category_id\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;categoryName\u0026#34; property=\u0026#34;category_name\u0026#34; /\u0026gt; \u0026lt;!-- 一对多的关系 --\u0026gt; \u0026lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --\u0026gt; \u0026lt;collection property=\u0026#34;products\u0026#34; ofType=\u0026#34;Product\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;product_id\u0026#34; property=\u0026#34;productId\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;productName\u0026#34; property=\u0026#34;productName\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;price\u0026#34; property=\u0026#34;price\u0026#34; /\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 关联查询分类和产品表 --\u0026gt; \u0026lt;select id=\u0026#34;listCategory\u0026#34; resultMap=\u0026#34;categoryBean\u0026#34;\u0026gt; select c.*, p.* from category_ c left join product_ p on c.id = p.cid \u0026lt;/select\u0026gt; 11. 如何获取生成的主键? # 新增标签中添加：keyProperty=\u0026rdquo; ID \u0026quot; 即可\n\u0026lt;insert id=\u0026#34;insert\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;userId\u0026#34; \u0026gt; insert into user( user_name, user_password, create_time) values(#{userName}, #{userPassword} , #{createTime, jdbcType= TIMESTAMP}) \u0026lt;/insert\u0026gt; 这时候就可以完成回填主键\nmapper.insert(user); user.getId; 12. MyBatis支持动态SQL吗？ # MyBatis中有一些支持动态SQL的标签，它们的原理是从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL的功能。\nif：根据条件来组成where子句\n\u0026lt;select id=\u0026#34;findActiveBlogWithTitleLike\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; AND title like #{title} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; choose (when, otherwise)：这个和Java 中的 switch 语句有点像\n\u0026lt;select id=\u0026#34;findActiveBlogLike\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; AND title like #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null and author.name != null\u0026#34;\u0026gt; AND author_name like #{author.name} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; AND featured = 1 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/select\u0026gt; 可以用在所有的查询条件都是动态的情况\n\u0026lt;select id=\u0026#34;findActiveBlogLike\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; SELECT * FROM BLOG \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;state != null\u0026#34;\u0026gt; state = #{state} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; AND title like #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null and author.name != null\u0026#34;\u0026gt; AND author_name like #{author.name} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 可以用在动态更新的时候\n\u0026lt;update id=\u0026#34;updateAuthorIfNecessary\u0026#34;\u0026gt; update Author \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username=#{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null\u0026#34;\u0026gt;password=#{password},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null\u0026#34;\u0026gt;email=#{email},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;bio != null\u0026#34;\u0026gt;bio=#{bio}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; foreach：看到名字就知道了，这个是用来循环的，可以对集合进行遍历\n\u0026lt;select id=\u0026#34;selectPostIn\u0026#34; resultType=\u0026#34;domain.blog.Post\u0026#34;\u0026gt; SELECT * FROM POST P \u0026lt;where\u0026gt; \u0026lt;foreach item=\u0026#34;item\u0026#34; index=\u0026#34;index\u0026#34; collection=\u0026#34;list\u0026#34; open=\u0026#34;ID in (\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34; nullable=\u0026#34;true\u0026#34;\u0026gt; #{item} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 13. 为什么Mapper接口不需要实现类？ # 动态代理。\n"},{"id":13,"href":"/notes/mybatisplus/%E4%B8%80%E8%88%AC%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","title":"一般查询操作","section":"MyBatisPlus","content":"按照增、删、改、查的顺序，分别如下：\n1 新增记录 # @Test void addTest() { User user = new User(); user.setName(\u0026#34;测试2\u0026#34;); user.setAge(20); user.setEmail(\u0026#34;xzb996@gmail.com\u0026#34;); userMapper.insert(user); testSelectList(); } 2 删除指定 id # // 根据 ID 删除单个 @Test void testDelByID() { userMapper.deleteById(1614632871479058433L); testSelectList(); } 3 批量删除指定 id # // 根据 ID 批量删除 @Test void testDelBatchByID() { userMapper.deleteBatchIds(Arrays.asList(1614631462599655425L, 1614627651596423170L)); testSelectList(); } 4 根据 id 修改记录 # @Test void testUpdateByID() { User user = userMapper.selectById(1L); user.setName(\u0026#34;科比\u0026#34;); userMapper.updateById(user); testSelectList(); } 5 查询全部 # @Autowired UserMapper userMapper; // 查询全部 @Test void testSelectList() { List\u0026lt;User\u0026gt; userList = userMapper.selectList(null); for (User user : userList) { System.out.println(user); } } "},{"id":14,"href":"/notes/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/","title":"虚拟机栈","section":"JVM","content":" 虚拟机栈 # 什么是虚拟机栈 # 即线程运行时需要的内存空间，多个线程多个虚拟机栈。每个虚拟机栈由栈帧组成，一个栈帧对应一次方法的调用，所以每个方法运行时需要的内存空间可以称之为栈帧。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。\n问题辨析 # 垃圾回收是否涉及到栈内存？\n栈内存是一次次的方法调用所产生的栈帧内存，每次方法调用完毕，栈帧就会弹出 ，不需要垃圾回收来管理。\n栈内存分配越大越好吗？\n栈内存划分越大，会支持越多次数的方法递归调用，但是线程数量会越少， 因为物理内存是固定的。\n**栈内存在idea中设置方法：**Edit Configurations\u0026hellip; \u0026gt; Modify options \u0026gt; Add VM options\n然后设置参数如下：\n方法内的局部变量是否是线程安全的？\n判断一个变量是否安全，不仅要看是否为方法内的局部变量，还要判断其是否离开了方法的作用范围，如：行参、返回值等都能够引起线程不安全。基本类型是安全的，但是引用类型要考虑下述问题：\n如果方法内局部变量没有逃离方法的作用访问，它是线程安全的 如果是局部变量引用了对象（基本类型安全），并逃离方法的作用方法，需要考虑线程安全 栈内存溢出的原因？ # 过多的栈帧入栈，但是没有出栈就很容易导致栈内存溢出，一般递归调用没有一个正确的递归条件的话，就很容易导致栈内存溢出 栈帧过大 栈内存溢出问题案例分析： # Emp 和Dept 类之间存在相互引用，这时转 json 的话会出现无限递归的报错导致栈溢出，这时候只需要在被依赖的变量上添加注解@JsonIgnore打断循环依赖即可。\n/** * json 数据转换 */ public class Demo1_19 { public static void main(String[] args) throws JsonProcessingException { Dept d = new Dept(); d.setName(\u0026#34;Market\u0026#34;); Emp e1 = new Emp(); e1.setName(\u0026#34;zhang\u0026#34;); e1.setDept(d); Emp e2 = new Emp(); e2.setName(\u0026#34;li\u0026#34;); e2.setDept(d); d.setEmps(Arrays.asList(e1, e2)); // { name: \u0026#39;Market\u0026#39;, emps: [{ name:\u0026#39;zhang\u0026#39;, dept:{ name:\u0026#39;\u0026#39;, emps: [ {}]} },] } ObjectMapper mapper = new ObjectMapper(); System.out.println(mapper.writeValueAsString(d)); } } class Emp { private String name; @JsonIgnore private Dept dept; public String getName() { return name; } public void setName(String name) { this.name = name; } public Dept getDept() { return dept; } public void setDept(Dept dept) { this.dept = dept; } } class Dept { private String name; private List\u0026lt;Emp\u0026gt; emps; public String getName() { return name; } public void setName(String name) { this.name = name; } public List\u0026lt;Emp\u0026gt; getEmps() { return emps; } public void setEmps(List\u0026lt;Emp\u0026gt; emps) { this.emps = emps; } } 线程运行占用CPU过多案例诊断 # 定位方法：\n用 top 定位哪个进程对 cpu 的占用过高 ps H -eo pid,tid,%cpu | grep 进程id 来进一步查看是哪个线程引起的cpu占用过高 jstack 进程id 可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号 top 指令，发现进程 32655 cpu 占用过高\nps H -eo pid,tid,%cpu | grep 32655 命令查看进程中出问题的线程，发现为线程 32665 出现问题\njstack 32655 查看 java 中与该进程相关的线程的具体信息\n将 10 进制线程编号换算成 16 进制，即 32665 -\u0026gt; 7f99，可以定位到是 Demo1_16 这个类的第八行附近代码出问题了\n"},{"id":15,"href":"/notes/redis/redis-string/","title":"Redis String","section":"Redis","content":" String # 二进制安全，可以包含任何数据，如图片、序列化对象等。\n常用命令 # set \u0026lt;key\u0026gt;\u0026lt;value\u0026gt;：添加键值对\nget \u0026lt;key\u0026gt;：查询对应键值\nappend \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;：将给定的 追加到原值的末尾\nstrlen \u0026lt;len\u0026gt;：获得值的长度\nsentnx \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;：只有key不存在时，设置 key 值\nincr \u0026lt;key\u0026gt;：将 key 中储存的数字增1（原子操作）\ndecr \u0026lt;key\u0026gt;：将 key 中储存的数字减1\nincrby / decrby \u0026lt;key\u0026gt; \u0026lt;步长\u0026gt;：将key中数字按照自定义步长增减\n原子操作：不会被线程调度机制打乱的操作，这种线程一旦开始，就会一直运行到结束，中间不会跳到其他线程。\nmset \u0026lt;key1\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt; \u0026lt;value2\u0026gt;：设置多个键值\nmget \u0026lt;key1\u0026gt; \u0026lt;key2\u0026gt; \u0026lt;key3\u0026gt;：同时获取多个 value\nmsetnx \u0026lt;key1\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt; \u0026lt;value2\u0026gt;：同时设置多个键值，前提 key 不存在\ngetrange \u0026lt;key\u0026gt; \u0026lt;起始位置\u0026gt; \u0026lt;结束位置(包括)\u0026gt;：获得值的范围，类似 java 中的 substring\nsetrange \u0026lt;key\u0026gt; \u0026lt;起始位置\u0026gt; \u0026lt;value\u0026gt;：用 value 覆盖从起始位置开始的字符串\nsetex \u0026lt;key\u0026gt; \u0026lt;过期时间\u0026gt; \u0026lt;value\u0026gt;：设置键值的同时，设置过期时间，单位秒\ngetset \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;：以旧换新，设置新值的同时获得旧值\nString 数据结构 # String 的数据结构为简单动态字符串（Simple Dynamic String，缩写 SDS）。是可以修改的字符串，类似于 Java 中的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。\n当前字符串实际分配的空间 capacity 一般高于实际字符串长度 len。当前字符串长度小于 1M 时，扩容是加倍现有的空间，若超过 1M，扩容时只会多扩容 1M 的空间。另外，字符串最大长度为 512M。\n"},{"id":16,"href":"/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%B8%89/","title":"Tensor Flow 笔记（三）","section":"TensorFlow","content":" TensorFlow 笔记（三） # 利用 TensorFlow API 搭建神经网络，利用六步法，采用 20 行左右代码重写 iris 分类。\n1. 六步法 # import train，test model = tf.keras.models.Sequential model.compile model.fit model.summary 2. 相关 API 解析 # 2.1 model # # 描述各层网络 model = tf.keras.models.Sequential([ 网络结构 ]) 网络结构举例：\n拉直层： tf.keras.layers.Flatten() 全连接层 tf.keras.layers.Dense(神经元个数, activation=\u0026#39;激活函数\u0026#39;, kernel_regularizer=哪种正则化) activation (字符串给出) 可选：relu, softmax, sigmoid, tanh kernel_regularizer 可选：tf.keras.regularizers.l1(), tf.keras.regularizers.l2() 卷积层 tf.keras.layers.Conv2D(filters = 卷积个数, kernel_size = 卷积, strides = 卷积步长, padding = \u0026#34;vaild\u0026#34; or \u0026#34;same\u0026#34;) LSTM层 tf.keras.layers.LSTM() 2.2 model.compile # model.compile(optimizer=优化器, loss=损失函数, metrics=[\u0026#34;准确率\u0026#34;]) Optimizer 可选： \u0026#39;sgd\u0026#39; or tf.keras.optimizers.SGD(lr=学习率, momentum=动量参数) \u0026#39;adagrad\u0026#39; or tf.keras.optimizers.Adagrad(lr=学习率) \u0026#39;adadelta\u0026#39; or tf.keras.optimizers.Adadelta(lr=学习率) \u0026#39;adam\u0026#39; or tf.keras.optimizers.Adam(lr=学习率, beta_1=0.9, beta_2=0.999) loss 可选: \u0026#39;mse\u0026#39; or tf.keras.losses.MeanSquareError() \u0026#39;sparse_categorical_crosstropy\u0026#39; or tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False) Metrics 可选： \u0026#39;accuracy\u0026#39;: y_ 和y 都是数值， 如 y_=[1] y=[1] \u0026#39;categorical_accuracy\u0026#39;: y_ 和 y 都是独热码(概率分布), 如 y_=[0, 1, 0] y=[0.256, 0.695, 0.048] \u0026#39;sparse_categorical_accuracy\u0026#39;: y_ 是数值， y 是独热码（概率分布），如 y_=[1] y=[0.256, 0.695, 0.048] 2.3 model.fit # model.fit(训练集的输入特征, 训练集标签, batch_size= , epochs= , vaildation_data=(测试集的输入特征, 测试集的标签), validation_split=从训练集划分多少比例给测试集, validation_freq=多少epoch测试一次) 2.5 model.summary # 打印网络及参数信息。\n3. 重写鸢尾花程序 # \u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; import sklearn.datasets as datasets import tensorflow as tf import numpy as np \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; x_train = datasets.load_iris().data y_train = datasets.load_iris().target np.random.seed(116) np.random.shuffle(x_train) np.random.seed(116) np.random.shuffle(y_train) \u0026#34;\u0026#34;\u0026#34; model = tf.keras.models.Sequential \u0026#34;\u0026#34;\u0026#34; model = tf.keras.models.Sequential([ tf.keras.layers.Dense(3, activation=\u0026#39;softmax\u0026#39;, kernel_regularizer=tf.keras.regularizers.l2()) ]) \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=tf.keras.optimizers.SGD(lr=0.1), loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; model.fit( x_train, y_train, batch_size=32, epochs=500, validation_split=0.2, validation_freq=20 ) \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() 4. 用类 class 搭建神经网络 # import train, test class MyModel(Model) model=MyModel model.compile model.fit model.summary 模型结构:\nclass MyModel(Model): def __init__(self): super(MyModel, self).__init__() # 定义网络结构 def call(self, x): # 调用网络结构块，实现前向传播 model = MyModel() 改写 Iris 程序代码:\n\u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; import sklearn.datasets as datasets import tensorflow as tf import numpy as np from tensorflow.keras.layers import Dense from tensorflow.keras import Model \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; x_train = datasets.load_iris().data y_train = datasets.load_iris().target np.random.seed(116) np.random.shuffle(x_train) np.random.seed(116) np.random.shuffle(y_train) \u0026#34;\u0026#34;\u0026#34; model = tf.keras.models.Sequential \u0026#34;\u0026#34;\u0026#34; # model = tf.keras.models.Sequential([ # tf.keras.layers.Dense(3, activation=\u0026#39;softmax\u0026#39;, kernel_regularizer=tf.keras.regularizers.l2()) # ]) class IrisModel(Model): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.d1 = Dense(3, activation=\u0026#39;softmax\u0026#39;, kernel_regularizer=tf.keras.regularizers.l2()) def call(self, x): y = self.d1(x) return y model = IrisModel() \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=tf.keras.optimizers.SGD(lr=0.1), loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; model.fit( x_train, y_train, batch_size=32, epochs=500, validation_split=0.2, validation_freq=20 ) \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() 5. Mnist 程序 # \u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; from matplotlib.pyplot import cla from sklearn import metrics from tensorflow.keras.layers import Dense, Flatten import tensorflow as tf from tensorflow.keras import Model \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data() \u0026#34;\u0026#34;\u0026#34; model \u0026#34;\u0026#34;\u0026#34; class MnistModel(Model): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.f1 = Flatten() self.d1 = Dense(128, activation=\u0026#39;relu\u0026#39;) self.d2 = Dense(10, activation=\u0026#39;softmax\u0026#39;) def call(self, x): x = self.f1(x) x = self.d1(x) x = self.d2(x) return x model = MnistModel() \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;sparse_categorical_accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; model.fit(x_train, y_train, batch_size=32, epochs=50, validation_data=(x_test, y_test), validation_freq=1) \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() "},{"id":17,"href":"/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"创建型模式","section":"设计模式","content":" 创建型模式 # 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。\n这样可以降低系统的耦合度，并且使用者不需要关注对象的创建细节。\n1 单例设计模式 # 1.1 概述 # 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n1.2 结构 # 单例模式的主要有以下角色：\n单例类。只能创建一个实例的类 访问类。使用单例类 1.3 案例实现 # 单例设计模式分类两种：\n​\t饿汉式：类加载就会导致该单实例对象被创建\n​\t懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\n1.2.1 饿汉式 # 方式1（静态变量方式）\n点击展开 ... /** * 饿汉式 * 静态变量创建类的对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 说明：\n​\t该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。\n方式2（静态代码块方式）\n点击展开 ... /** * 恶汉式 * 在静态代码块中创建该类对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; static { instance = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 说明：\n​\t该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。\n1.2.2 懒汉式 # 方式1（线程不安全）\n点击展开 ... /** * 懒汉式 * 线程不安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 说明：\n​\t从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。\n懒汉式-方式2（线程安全）\n点击展开 ... /** * 懒汉式 * 线程安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 说明：\n​\t该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。\n懒汉式-方式3（双重检查锁）\n再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式\n点击展开 ... /** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为null if(instance == null) { instance = new Singleton(); } } } return instance; } } 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。\n要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。\n点击展开 ... /** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为空 if(instance == null) { instance = new Singleton(); } } } return instance; } } 小结：\n添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\n懒汉式-方式4（静态内部类方式）\n静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。\n点击展开 ... /** * 静态内部类方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } 说明：\n​\t第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder\n并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。\n小结：\n​\t静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。\n1.2.3 枚举方式 # 枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\n点击展开 ... /** * 枚举方式 */ public enum Singleton { INSTANCE; } 说明：\n​\t枚举方式属于恶汉式方式。\n1.4 JDK源码解析-Runtime类 # Runtime类就是使用的单例设计模式。\n通过源代码查看使用的是哪儿种单例模式\n点击展开 ... public class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don\u0026#39;t let anyone else instantiate this class */ private Runtime() {} ... } 从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。\n使用Runtime类中的方法\n点击展开 ... public class RuntimeDemo { public static void main(String[] args) throws IOException { //获取Runtime类对象 Runtime runtime = Runtime.getRuntime(); //返回 Java 虚拟机中的内存总量。 System.out.println(runtime.totalMemory()); //返回 Java 虚拟机试图使用的最大内存量。 System.out.println(runtime.maxMemory()); //创建一个新的进程执行指定的字符串命令，返回进程对象 Process process = runtime.exec(\u0026#34;ipconfig\u0026#34;); //获取命令执行后的结果，通过输入流获取 InputStream inputStream = process.getInputStream(); byte[] arr = new byte[1024 * 1024* 100]; int b = inputStream.read(arr); System.out.println(new String(arr,0,b,\u0026#34;gbk\u0026#34;)); } } 1.5 存在的问题 # 1.5.1 问题演示 # 破坏单例模式：\n使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。\n序列化反序列化\nSingleton类：\n点击展开 ... public class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } Test类：\n点击展开 ... public class Test { public static void main(String[] args) throws Exception { //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile(); //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); } private static Singleton readObjectFromFile() throws Exception { //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\u0026#34;)); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject(); return instance; } public static void writeObject2File() throws Exception { //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\u0026#34;)); //将instance对象写出到文件中 oos.writeObject(instance); } } 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。\n反射\nSingleton类：\n点击展开 ... public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } Test类：\n点击展开 ... public class Test { public static void main(String[] args) throws Exception { //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true); //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance(); //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); } } 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式\n注意：枚举方式不会出现这两个问题。\n1.5.2 问题的解决 # 序列化、反序列方式破坏单例模式的解决方法\n在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。\nSingleton类：\n点击展开 ... public class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() { return SingletonHolder.INSTANCE; } } 源码解析：\nObjectInputStream类\n点击展开 ... public final Object readObject() throws IOException, ClassNotFoundException{ ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false);//重点查看readObject0方法 ..... } private Object readObject0(boolean unshared) throws IOException { ... try { switch (tc) { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... } } finally { depth--; bin.setBlockDataMode(oldMode); } } private Object readOrdinaryObject(boolean unshared) throws IOException { ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null \u0026amp;\u0026amp; handles.lookupException(passHandle) == null \u0026amp;\u0026amp; desc.hasReadResolveMethod()) { // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... } return obj; } 反射方式破解单例的解决方法\n点击展开 ... public class Singleton { //私有构造方法 private Singleton() { /* 反射破解单例模式需要添加的代码 */ if(instance != null) { throw new RuntimeException(); } } private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } 说明:\n​\t这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。\n2 工厂模式 # 2.1 概述 # 需求：设计一个咖啡店点餐系统。\n设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。\n具体类的设计如下：\n在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。\n2.2 简单工厂模式 # 2.2.1 概念 # 简单工厂不是一种设计模式，反而比较像是一种编程习惯。\n2.2.2 结构 # 简单工厂包含如下角色：\n抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 2.2.3 实现 # 现在使用简单工厂对上面案例进行改进，类图如下：\n工厂类代码如下：\n点击展开 ... public class SimpleCoffeeFactory { public Coffee createCoffee(String type) { Coffee coffee = null; if(\u0026#34;americano\u0026#34;.equals(type)) { coffee = new AmericanoCoffee(); } else if(\u0026#34;latte\u0026#34;.equals(type)) { coffee = new LatteCoffee(); } return coffee; } } 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。\n后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。\n优点：\n封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\n缺点：\n增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\n2.2.4 扩展 # 静态工厂\n在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\n点击展开 ... public class SimpleCoffeeFactory { public static Coffee createCoffee(String type) { Coffee coffee = null; if(\u0026#34;americano\u0026#34;.equals(type)) { coffee = new AmericanoCoffee(); } else if(\u0026#34;latte\u0026#34;.equals(type)) { coffee = new LatteCoffee(); } return coffe; } } 2.3 工厂方法模式 # 针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。\n2.3.1 概念 # 定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\n2.3.2 结构 # 工厂方法模式的主要角色：\n抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 2.3.3 实现 # 使用工厂方法模式对上例进行改进，类图如下：\n代码如下：\n抽象工厂：\n点击展开 ... public interface CoffeeFactory { Coffee createCoffee(); } 具体工厂：\n点击展开 ... public class LatteCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new LatteCoffee(); } } public class AmericanCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new AmericanCoffee(); } } 咖啡店类：\n点击展开 ... public class CoffeeStore { private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) { this.factory = factory; } public Coffee orderCoffee(String type) { Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; } } 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n优点：\n用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点：\n每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 2.4 抽象工厂模式 # 前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\n这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\n本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\n2.4.1 概念 # 是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\n2.4.2 结构 # 抽象工厂模式的主要角色如下：\n抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 2.4.3 实现 # 现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\n代码如下：\n抽象工厂：\n点击展开 ... public interface DessertFactory { Coffee createCoffee(); Dessert createDessert(); } 具体工厂：\n点击展开 ... //美式甜点工厂 public class AmericanDessertFactory implements DessertFactory { public Coffee createCoffee() { return new AmericanCoffee(); } public Dessert createDessert() { return new MatchaMousse(); } } //意大利风味甜点工厂 public class ItalyDessertFactory implements DessertFactory { public Coffee createCoffee() { return new LatteCoffee(); } public Dessert createDessert() { return new Tiramisu(); } } 如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。\n优点：\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n缺点：\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\n2.4.4 使用场景 # 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\n系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\n系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\n如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。\n2.5 模式扩展 # 简单工厂+配置文件解除耦合\n可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\n第一步：定义配置文件\n为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\namerican=com.itheima.pattern.factory.config_factory.AmericanCoffee latte=com.itheima.pattern.factory.config_factory.LatteCoffee 第二步：改进工厂类\n点击展开 ... public class CoffeeFactory { private static Map\u0026lt;String,Coffee\u0026gt; map = new HashMap(); static { Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\u0026#34;bean.properties\u0026#34;); try { p.load(is); //遍历Properties集合对象 Set\u0026lt;Object\u0026gt; keys = p.keySet(); for (Object key : keys) { //根据键获取值（全类名） String className = p.getProperty((String) key); //获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); } } catch (Exception e) { e.printStackTrace(); } } public static Coffee createCoffee(String name) { return map.get(name); } } 静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\n2.6 JDK源码解析-Collection.iterator方法 # 点击展开 ... public class Demo { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;令狐冲\u0026#34;); list.add(\u0026#34;风清扬\u0026#34;); list.add(\u0026#34;任我行\u0026#34;); //获取迭代器对象 Iterator\u0026lt;String\u0026gt; it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) { String ele = it.next(); System.out.println(ele); } } } 对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：\nCollection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。\n另：\n​\t1 DateForamt类中的getInstance()方法使用的是工厂模式；\n​\t2 Calendar类中的getInstance()方法使用的是工厂模式；\n3 原型模式 # 3.1 概述 # 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\n3.2 结构 # 原型模式包含如下角色：\n抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 接口类图如下：\n实现方式：\n原型模式的克隆分为浅克隆和深克隆。\n浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\n深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\nJava中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：\nRealizetype（具体的原型类）：\n点击展开 ... public class Realizetype implements Cloneable { public Realizetype() { System.out.println(\u0026#34;具体的原型对象创建完成！\u0026#34;); } @Override protected Realizetype clone() throws CloneNotSupportedException { System.out.println(\u0026#34;具体原型复制成功！\u0026#34;); return (Realizetype) super.clone(); } } PrototypeTest（测试访问类）：\n点击展开 ... public class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { Realizetype r1 = new Realizetype(); Realizetype r2 = r1.clone(); System.out.println(\u0026#34;对象r1和r2是同一个对象？\u0026#34; + (r1 == r2)); } } 3.3 案例 # 用原型模式生成“三好学生”奖状 ：同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。\n类图如下：\n代码如下：\n点击展开 ... //奖状类 public class Citation implements Cloneable { private String name; public void setName(String name) { this.name = name; } public String getName() { return (this.name); } public void show() { System.out.println(name + \u0026#34;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\u0026#34;); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //测试访问类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); c1.setName(\u0026#34;张三\u0026#34;); //复制奖状 Citation c2 = c1.clone(); //将奖状的名字修改李四 c2.setName(\u0026#34;李四\u0026#34;); c1.show(); c2.show(); } } 3.4 使用场景 # 对象的创建非常复杂，可以使用原型模式快捷的创建对象。 性能和安全要求比较高。 3.5 扩展（深克隆） # 将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：\n点击展开 ... //奖状类 public class Citation implements Cloneable { private Student stu; public Student getStu() { return stu; } public void setStu(Student stu) { this.stu = stu; } void show() { System.out.println(stu.getName() + \u0026#34;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\u0026#34;); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //学生类 public class Student { private String name; private String address; public Student(String name, String address) { this.name = name; this.address = address; } public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } //测试类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); Student stu = new Student(\u0026#34;张三\u0026#34;, \u0026#34;西安\u0026#34;); c1.setStu(stu); //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\u0026#34;李四\u0026#34;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\u0026#34;stu和stu1是同一个对象？\u0026#34; + (stu == stu1)); c1.show(); c2.show(); } } 运行结果为：\n说明：\n​\tstu 对象和 stu1 对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：\n点击展开 ... public class CitationTest1 { public static void main(String[] args) throws Exception { Citation c1 = new Citation(); Student stu = new Student(\u0026#34;张三\u0026#34;, \u0026#34;西安\u0026#34;); c1.setStu(stu); //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\u0026#34;)); //将c1对象写出到文件中 oos.writeObject(c1); oos.close(); //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\u0026#34;)); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\u0026#34;李四\u0026#34;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\u0026#34;stu和stu1是同一个对象？\u0026#34; + (stu == stu1)); c1.show(); c2.show(); } } 运行结果为：\n注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。\n4 建造者模式 # 4.1 概述 # 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\n分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 4.2 结构 # 建造者（Builder）模式包含如下角色：\n抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。\n具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。\n产品类（Product）：要创建的复杂对象。\n指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。\n类图如下：\n4.3 实例 # 创建共享单车\n生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。\n这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：\n具体的代码如下：\n点击展开 ... //自行车类 public class Bike { private String frame; private String seat; public String getFrame() { return frame; } public void setFrame(String frame) { this.frame = frame; } public String getSeat() { return seat; } public void setSeat(String seat) { this.seat = seat; } } // 抽象 builder 类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); } //摩拜单车Builder类 public class MobikeBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\u0026#34;铝合金车架\u0026#34;); } @Override public void buildSeat() { mBike.setSeat(\u0026#34;真皮车座\u0026#34;); } @Override public Bike createBike() { return mBike; } } //ofo单车Builder类 public class OfoBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\u0026#34;碳纤维车架\u0026#34;); } @Override public void buildSeat() { mBike.setSeat(\u0026#34;橡胶车座\u0026#34;); } @Override public Bike createBike() { return mBike; } } //指挥者类 public class Director { private Builder mBuilder; public Director(Builder builder) { mBuilder = builder; } public Bike construct() { mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); } } //测试类 public class Client { public static void main(String[] args) { showBike(new OfoBuilder()); showBike(new MobikeBuilder()); } private static void showBike(Builder builder) { Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); } } 注意：\n上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合\n点击展开 ... // 抽象 builder 类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() { this.buildFrame(); this.BuildSeat(); return this.createBike(); } } 说明：\n这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。\n优点：\n建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。 缺点：\n造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n4.4 使用场景 # 建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。\n创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 4.5 模式扩展 # 建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。\n重构前代码如下：\n点击展开 ... public class Phone { private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) { this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; } public String getCpu() { return cpu; } public void setCpu(String cpu) { this.cpu = cpu; } public String getScreen() { return screen; } public void setScreen(String screen) { this.screen = screen; } public String getMemory() { return memory; } public void setMemory(String memory) { this.memory = memory; } public String getMainboard() { return mainboard; } public void setMainboard(String mainboard) { this.mainboard = mainboard; } @Override public String toString() { return \u0026#34;Phone{\u0026#34; + \u0026#34;cpu=\u0026#39;\u0026#34; + cpu + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, screen=\u0026#39;\u0026#34; + screen + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, memory=\u0026#39;\u0026#34; + memory + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, mainboard=\u0026#39;\u0026#34; + mainboard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } public class Client { public static void main(String[] args) { //构建Phone对象 Phone phone = new Phone(\u0026#34;intel\u0026#34;,\u0026#34;三星屏幕\u0026#34;,\u0026#34;金士顿\u0026#34;,\u0026#34;华硕\u0026#34;); System.out.println(phone); } } 上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。\n重构后代码：\n点击展开 ... public class Phone { private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) { cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; } public static final class Builder { private String cpu; private String screen; private String memory; private String mainboard; public Builder() {} public Builder cpu(String val) { cpu = val; return this; } public Builder screen(String val) { screen = val; return this; } public Builder memory(String val) { memory = val; return this; } public Builder mainboard(String val) { mainboard = val; return this; } public Phone build() { return new Phone(this);} } @Override public String toString() { return \u0026#34;Phone{\u0026#34; + \u0026#34;cpu=\u0026#39;\u0026#34; + cpu + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, screen=\u0026#39;\u0026#34; + screen + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, memory=\u0026#39;\u0026#34; + memory + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, mainboard=\u0026#39;\u0026#34; + mainboard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } public class Client { public static void main(String[] args) { Phone phone = new Phone.Builder() .cpu(\u0026#34;intel\u0026#34;) .mainboard(\u0026#34;华硕\u0026#34;) .memory(\u0026#34;金士顿\u0026#34;) .screen(\u0026#34;三星\u0026#34;) .build(); System.out.println(phone); } } 重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。\n4.6 创建者模式对比 # 4.6.1 工厂方法模式VS建造者模式 # 工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。\n我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。\n4.6.2 抽象工厂模式VS建造者模式 # 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。\n建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\n如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\n"},{"id":18,"href":"/notes/%E5%85%AB%E8%82%A1/mysql/","title":"MySQL","section":"Java八股","content":" 1. 什么是内连接、外连接、交叉连接、笛卡尔积呢？ # 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。\n-- 标准语法（显式内连接） SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件; -- 查询用户信息和对应的订单信息 SELECT * FROM USER INNER JOIN orderlist ON user.id=orderlist.uid; -- 标准语法(隐式内连接) SELECT 列名 FROM 表名1,表名2 WHERE 条件; 外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。\n交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有 n 行，那么 A 和 B 交叉连接的结果就有 m*n 行。\n笛卡尔积：是数学中的一个概念，例如集合 A={a,b}，集合 B={1,2,3}，那么 A✖️B={\u0026lt;a,o\u0026gt;,\u0026lt;a,1\u0026gt;,\u0026lt;a,2\u0026gt;,\u0026lt;b,0\u0026gt;,\u0026lt;b,1\u0026gt;,\u0026lt;b,2\u0026gt;,}。\n2.说一下数据库的三大范式？ # 第一范式：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和订单 ID 作为联合主键，才满足第二范式。 第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。 三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。\n3.varchar 与 char 的区别？ # char：\nchar 表示定长字符串，长度是固定的； 如果插入数据的长度小于 char 的固定长度时，则用空格填充； 因为长度固定，所以存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法； 对于 char 来说，最多能存放的字符个数为 255，和编码无关 varchar：\nvarchar 表示可变长字符串，长度是可变的； 插入的数据是多长，就按照多长来存储； varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法； 对于 varchar 来说，最多能存放的字符个数为 65532 日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。\n4.blob 和 text 有什么区别？ # blob 用于存储二进制数据，而 text 用于存储大字符串。 blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较 5.DATETIME 和 TIMESTAMP 的异同？ # 相同点:\n两个数据类型存储时间的表现格式一致。均为 YYYY-MM-DD HH:MM:SS 两个数据类型都包含「日期」和「时间」部分。 两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒） 区别:\n日期范围：DATETIME 的日期范围是 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999；TIMESTAMP 的时间范围是1970-01-01 00:00:01.000000 UTC 到 ``2038-01-09 03:14:07.999999 UTC 存储空间：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节 时区相关：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区 默认值：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP) 6.MySQL 中 in 和 exists 的区别？ # MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景：\n如果查询的两个表大小相当，那么用 in 和 exists 差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。 not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。 7.MySQL 里记录货币用什么字段类型比较好？ # 货币在数据库中 MySQL 常用 Decimal 和 Numric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。\n例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。\nDECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。\n之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。\n8.MySQL 怎么存储 emoji😊? # MySQL 可以直接使用字符串存储 emoji。\n但是需要注意的，utf8 编码是不行的，MySQL 中的 utf8 是阉割版的 utf8，它最多只用 3 个字节存储字符，所以存储不了表情。那该怎么办？\n需要使用 utf8mb4 编码。\nalter table blogs modify content text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci not null; 9.drop、delete 与 truncate 的区别？ # 三者都表示删除，但是三者有一些差别：\ndelete truncate drop 类型 属于 DML 属于 DDL 回滚 可回滚 不可回滚 删除内容 表结构还在，删除表的全部或者一部分数据行 表结构还在，删除表中的所有数据 删除速度 删除速度慢，需要逐行删除 删除速度快 因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。\n10.UNION 与 UNION ALL 的区别？ # 如果使用 UNION，会在表链接后筛选掉重复的记录行 如果使用 UNION ALL，不会合并重复的记录行 从效率上说，UNION ALL 要比 UNION 快很多，如果合并没有刻意要删除重复行，那么就使用 UNION All 11.count(1)、count(*) 与 count(列名) 的区别？ # count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。 执行速度：\n列名为主键，count(列名)会比 count(1)快 列名不为主键，count(1)会比 count(列名)快 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） 如果有主键，则 select count（主键）的执行效率是最优的 如果表只有一个字段，则 select count（*）最优。 12.说说 MySQL 的基础架构? # 从上图可以看出， MySQL 主要由下面几部分构成：\n连接器： 身份认证和权限相关(登录 MySQL 的时候)。 查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。 分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。 优化器： 按照 MySQL 认为最优的方案去执行。 执行器： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。 插件式存储引擎 ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。 13.什么是关系型数据库？ # 顾名思义，关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型的基础上的数据库。\n14.什么是 SQL？ # SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。\n15.MySQL 有哪些常见存储引擎？ # 主要存储引擎以及功能如下：\n功能 MylSAM MEMORY InnoDB 存储限制 256TB RAM 64TB 支持事务 No No Yes 支持全文索引 Yes No Yes 支持树索引 Yes Yes Yes 支持哈希索引 No Yes Yes 支持数据缓存 No N/A Yes 支持外键 No No Yes MySQL5.5 之前，默认存储引擎是 MylSAM，5.5 之后变成了 InnoDB。\n16.那存储引擎应该怎么选择？ # 大致上可以这么选择：\n大多数情况下，使用默认的 InnoDB 就够了。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。 使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。\n17.InnoDB 和 MylSAM 主要有什么区别？ # 1.是否支持行级锁:MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。\n2.是否支持事务:MyISAM 不提供事务支持。\n3.是否支持外键:MyISAM 不支持，而 InnoDB 支持。\n4.是否支持数据库异常崩溃后的安全恢复:MyISAM 不支持，而 InnoDB 支持。\n5.是否支持 MVCC:MyISAM 不支持，而 InnoDB 支持。\n6.索引实现不一样。:虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。\n18.MySQL 存储引擎架构了解吗？ # MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。\n# "},{"id":19,"href":"/notes/mybatisplus/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/","title":"分页查询","section":"MyBatisPlus","content":"分页查询主要分为两个步骤，其一为添加分页插件，其二为配置分页参数。具体如下：\n1 添加分页插件 # 在 config 包中添加配置类， 这里命名为 MpConfig。其中代码如下：\npackage com.atguigu.config; import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MpConfig { @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 2 配置分页参数 # Page\u0026lt;User\u0026gt; page = new Page\u0026lt;\u0026gt;(1, 2); // 意思为从第一条记录开始，每页显示两条记录 userMapper.selectPage(page, null);\t// 将 page 配置绑定到 userMapper 3 相关查询 API # page.getRecords().forEach(System.out::println); // 当前页所有记录 System.out.println(page.getPages()); // 总共页数 System.out.println(page.getCurrent()); // 获取当前页数 System.out.println(page.getSize()); // 每页记录数 System.out.println(page.getTotal()); // 总记录数 System.out.println(page.hasNext()); // 是否有下一页 System.out.println(page.hasPrevious()); // 是否有上一页 "},{"id":20,"href":"/notes/jvm/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-/","title":"本地方法栈","section":"JVM","content":" 本地方法栈 # Java 语言不能直接和系统底层硬件打交道，这时候需要用到 C/C++编写的方法来与操作系统更底层的 API 通信，Java 代码可以通过本地方法（一般 native 修饰）来调用底层功能，这些本地方法运行的时候，所使用的内存就是本地方法栈。\n"},{"id":21,"href":"/notes/redis/redis-list/","title":"Redis List","section":"Redis","content":" Redis List # 是简单的字符串列表，按照插入顺序排序，底层是双向链表，对两端操作性能高，索引下标操作中间性能会比较差。\n常用命令 # lpush/rpush \u0026lt;key\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;value2\u0026gt; \u0026lt;value3\u0026gt;：从左边或值右边插入值\nlpop/rpop \u0026lt;key\u0026gt;：吐值\nrpoplpush \u0026lt;key1\u0026gt; \u0026lt;key2\u0026gt;：从列表右边吐出一个值，插到 列表左边\nlrange \u0026lt;key\u0026gt; \u0026lt;start\u0026gt; \u0026lt;stop\u0026gt;：按照索引下标获得元素（从左到右），0~-1取所有值\nlindex \u0026lt;key\u0026gt; \u0026lt;index\u0026gt;：按照索引下标获得元素（从左到右）\nllen \u0026lt;key\u0026gt;：获得列表长度\nlinsert \u0026lt;key\u0026gt; after/before \u0026lt;value\u0026gt; \u0026lt;newvalue\u0026gt; 在 的前/后面插入 lrem \u0026lt;key\u0026gt; \u0026lt;n\u0026gt; \u0026lt;value\u0026gt;：从左边删除 n 个 value（从左到右）\nlset \u0026lt;key\u0026gt; \u0026lt;index\u0026gt; \u0026lt;value\u0026gt;：将列表 key 下标为 index 的值替换成 value\nList 数据结构 # List的数据结构是 quickList，但不安全是，当数据元素比较少的时候，元素都是在连续内存空间存储，这时候的结构是 zipList，即压缩列表。当元素比较多的时候，会产生多个 zipList，然后将多个 zipList 以链表的形式存储。如下图：\n"},{"id":22,"href":"/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E5%9B%9B/","title":"Tensor Flow 笔记（四）","section":"TensorFlow","content":" TensorFlow 笔记（四） # 对六步法进行扩展，扩展内容如下：\n自制数据集，解决本领域应用 数据增强，扩充数据集 断点续训，存取模型 参数提取，把参数存入文本 acc / loss 可视化，查看训练效果 应用程序，给图识物 1. 自制数据集 # \u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; from matplotlib.pyplot import cla from sklearn import metrics from tensorflow.keras.layers import Dense, Flatten import tensorflow as tf from tensorflow.keras import Model from PIL import Image import numpy as np \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; train_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000\u0026#39; test_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000\u0026#39; train_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000.txt\u0026#39; test_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000.txt\u0026#39; def generateds(path, txt): f = open(txt) contents = f.readlines() f.close() imgs = [] labels = [] for content in contents: # print(content) value = content.split(\u0026#39; \u0026#39;) img = Image.open(path+\u0026#39;/\u0026#39;+value[0]) # 获取图片值 img = np.array(img.convert(\u0026#39;L\u0026#39;)) # 图像转为灰度 img = img / 255 label = value[1] # 获取标签值 imgs.append(img) labels.append(label) # 将数据转为 numpy 格式 imgs = np.array(imgs) labels = np.array(labels) labels = labels.astype(np.int64) return imgs, labels (x_train, y_train) = generateds(train_img_path, train_label) (x_test, y_test) = generateds(test_img_path, test_label) \u0026#34;\u0026#34;\u0026#34; model \u0026#34;\u0026#34;\u0026#34; class MnistModel(Model): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.f1 = Flatten() self.d1 = Dense(128, activation=\u0026#39;relu\u0026#39;) self.d2 = Dense(10, activation=\u0026#39;softmax\u0026#39;) def call(self, x): x = self.f1(x) x = self.d1(x) x = self.d2(x) return x model = MnistModel() \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;sparse_categorical_accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; model.fit(x_train, y_train, batch_size=32, epochs=50, validation_data=(x_test, y_test), validation_freq=1) \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() 2.数据增强 # 对图像的简单形变，用来应对因拍照角度不同引起的图片变形。\nimage_gen_train = tf.keras.preprocessing.image.ImageDataGenerator( rescale = # 所有数据将乘以该数值 rotation_range = # 随机旋转度数范围 width_shift_range = # 随机宽度偏移 height_shift_range = # 随机高度偏移 horizontal_flip = # 是否随机水平翻转 zoom_range = # 将图像随机缩放 ) image_gen_train.fit(x_train) # x_train.shape 为 （数目, 长，宽， 通道） model.fit(image_gen_train.flow(x_train, y_train, batch_size=32), epochs=, validation_data=(x_test, y_test), validation_freq=) \u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; from tensorflow.keras.layers import Dense, Flatten import tensorflow as tf from tensorflow.keras import Model from PIL import Image import numpy as np \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; def generateds(path, txt): f = open(txt) contents = f.readlines() f.close() imgs = [] labels = [] for content in contents: # print(content) value = content.split(\u0026#39; \u0026#39;) img = Image.open(path+\u0026#39;/\u0026#39;+value[0]) # 获取图片值 img = np.array(img.convert(\u0026#39;L\u0026#39;)) # 图像转为灰度 img = img / 255 label = value[1] # 获取标签值 imgs.append(img) labels.append(label) # 将数据转为 numpy 格式 imgs = np.array(imgs) labels = np.array(labels) labels = labels.astype(np.int64) return imgs, labels train_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000\u0026#39; test_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000\u0026#39; train_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000.txt\u0026#39; test_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000.txt\u0026#39; (x_train, y_train) = generateds(train_img_path, train_label) (x_test, y_test) = generateds(test_img_path, test_label) x_train = x_train.reshape(x_train.shape[0], 28, 28, 1) image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator( rescale = 1. / 1, # 将所有数值乘以该数值 rotation_range = 45, # 随机旋转度数范围 width_shift_range = .15, # 宽度偏移 height_shift_range = .15, # 高度偏移 horizontal_flip = False, # 水平翻转 zoom_range = 0.5 # 将图像随机缩放阈值为 50% ) image_gen_train.fit(x_train) \u0026#34;\u0026#34;\u0026#34; model \u0026#34;\u0026#34;\u0026#34; class MnistModel(Model): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.f1 = Flatten() self.d1 = Dense(128, activation=\u0026#39;relu\u0026#39;) self.d2 = Dense(10, activation=\u0026#39;softmax\u0026#39;) def call(self, x): x = self.f1(x) x = self.d1(x) x = self.d2(x) return x model = MnistModel() \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;sparse_categorical_accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; model.fit(image_gen_train.flow(x_train, y_train, batch_size=32), epochs=5, validation_data=(x_test, y_test), validation_freq=1) \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() 3. 断点续训 # 保存模型load_weights(路径文件名) checkpoint_save_path = \u0026#34;./checkpoint/mnist.ckpt\u0026#34; if os.path.exists(checkpoint_save_path + \u0026#39;.index\u0026#39;) # 保存模型会自动生成索引文件 print(\u0026#39;---------------------------- load the model ----------------------------\u0026#39;) model.load_weights(checkpoint_save_path) 保存模型 tf.keras.callbacks.ModelCheckpoint( filepath= ,\t# 路径文件名 save_weights_only=True/False,\t# 是否只保留模型参数 save_best_only=True/False\t# 是否只保留最优结果 ) model.fit(callbacks=[cp_callback]) \u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; from tensorflow.keras.layers import Dense, Flatten import tensorflow as tf from tensorflow.keras import Model from PIL import Image import numpy as np import os \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; def generateds(path, txt): f = open(txt) contents = f.readlines() f.close() imgs = [] labels = [] for content in contents: # print(content) value = content.split(\u0026#39; \u0026#39;) img = Image.open(path+\u0026#39;/\u0026#39;+value[0]) # 获取图片值 img = np.array(img.convert(\u0026#39;L\u0026#39;)) # 图像转为灰度 img = img / 255 label = value[1] # 获取标签值 imgs.append(img) labels.append(label) # 将数据转为 numpy 格式 imgs = np.array(imgs) labels = np.array(labels) labels = labels.astype(np.int64) return imgs, labels train_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000\u0026#39; test_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000\u0026#39; train_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000.txt\u0026#39; test_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000.txt\u0026#39; (x_train, y_train) = generateds(train_img_path, train_label) (x_test, y_test) = generateds(test_img_path, test_label) x_train = x_train.reshape(x_train.shape[0], 28, 28, 1) image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator( rescale = 1. / 1, # 将所有数值乘以该数值 rotation_range = 45, # 随机旋转度数范围 width_shift_range = .15, # 宽度偏移 height_shift_range = .15, # 高度偏移 horizontal_flip = False, # 水平翻转 zoom_range = 0.5 # 将图像随机缩放阈值为 50% ) image_gen_train.fit(x_train) \u0026#34;\u0026#34;\u0026#34; model \u0026#34;\u0026#34;\u0026#34; class MnistModel(Model): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.f1 = Flatten() self.d1 = Dense(2000, activation=\u0026#39;relu\u0026#39;) self.d2 = Dense(10, activation=\u0026#39;softmax\u0026#39;) def call(self, x): x = self.f1(x) x = self.d1(x) x = self.d2(x) return x model = MnistModel() \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;sparse_categorical_accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; checkpoint_save_path = \u0026#39;./checkpoint/mnist.ckpt\u0026#39; if os.path.exists(checkpoint_save_path + \u0026#39;.index\u0026#39;): print(\u0026#34;--------------------- load the model ---------------------\u0026#34;) model.load_weights(checkpoint_save_path) cp_callback = tf.keras.callbacks.ModelCheckpoint( filepath=checkpoint_save_path, save_weights_only=True, save_best_only=True ) model.fit(image_gen_train.flow(x_train, y_train, batch_size=32), epochs=5, validation_data=(x_test, y_test), validation_freq=1, callbacks=[cp_callback]) \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() 4. acc 曲线与 loss 曲线可视化 # \u0026#34;\u0026#34;\u0026#34; history = model.fit(训练集数据，训练集标签，batch_size=, epochs=, validation_split=用作测试数据的比例, validation_data=测试集, validation_freq=测试频率) history: # 训练集 loss: loss # 测试集 loss: val_loss # 训练集准确率: sparse_categorical_accuracy # 测试集准确率: val_categorical_accuracy \u0026#34;\u0026#34;\u0026#34; acc = history.history[\u0026#39;sparse_categorical_accuracy\u0026#39;] val_acc = history.history[\u0026#39;val_categorical_accuracy\u0026#39;] loss = history.history[\u0026#39;loss\u0026#39;] val_loss = history.history[\u0026#39;val_loss\u0026#39;] \u0026#34;\u0026#34;\u0026#34; import \u0026#34;\u0026#34;\u0026#34; from tensorflow.keras.layers import Dense, Flatten import tensorflow as tf from tensorflow.keras import Model import matplotlib.pyplot as plt from PIL import Image import numpy as np import os \u0026#34;\u0026#34;\u0026#34; train, test \u0026#34;\u0026#34;\u0026#34; def generateds(path, txt): f = open(txt) contents = f.readlines() f.close() imgs = [] labels = [] for content in contents: # print(content) value = content.split(\u0026#39; \u0026#39;) img = Image.open(path+\u0026#39;/\u0026#39;+value[0]) # 获取图片值 img = np.array(img.convert(\u0026#39;L\u0026#39;)) # 图像转为灰度 img = img / 255 label = value[1] # 获取标签值 imgs.append(img) labels.append(label) # 将数据转为 numpy 格式 imgs = np.array(imgs) labels = np.array(labels) labels = labels.astype(np.int64) return imgs, labels train_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000\u0026#39; test_img_path = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000\u0026#39; train_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_train_jpg_60000.txt\u0026#39; test_label = \u0026#39;TensorFlow 笔记/mnist_image_label/mnist_test_jpg_10000.txt\u0026#39; (x_train, y_train) = generateds(train_img_path, train_label) (x_test, y_test) = generateds(test_img_path, test_label) x_train = x_train.reshape(x_train.shape[0], 28, 28, 1) image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator( rescale = 1. / 1, # 将所有数值乘以该数值 rotation_range = 45, # 随机旋转度数范围 width_shift_range = .15, # 宽度偏移 height_shift_range = .15, # 高度偏移 horizontal_flip = False, # 水平翻转 zoom_range = 0.5 # 将图像随机缩放阈值为 50% ) image_gen_train.fit(x_train) \u0026#34;\u0026#34;\u0026#34; model \u0026#34;\u0026#34;\u0026#34; class MnistModel(Model): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.f1 = Flatten() self.d1 = Dense(120, activation=\u0026#39;relu\u0026#39;) self.d2 = Dense(10, activation=\u0026#39;softmax\u0026#39;) def call(self, x): x = self.f1(x) x = self.d1(x) x = self.d2(x) return x model = MnistModel() \u0026#34;\u0026#34;\u0026#34; model.compile \u0026#34;\u0026#34;\u0026#34; model.compile( optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[\u0026#39;sparse_categorical_accuracy\u0026#39;] ) \u0026#34;\u0026#34;\u0026#34; model.fit \u0026#34;\u0026#34;\u0026#34; checkpoint_save_path = \u0026#39;./checkpoint/mnist.ckpt\u0026#39; if os.path.exists(checkpoint_save_path + \u0026#39;.index\u0026#39;): print(\u0026#34;--------------------- load the model ---------------------\u0026#34;) model.load_weights(checkpoint_save_path) cp_callback = tf.keras.callbacks.ModelCheckpoint( filepath=checkpoint_save_path, save_weights_only=True, save_best_only=True ) history = model.fit(image_gen_train.flow(x_train, y_train, batch_size=64), epochs=5, validation_data=(x_test, y_test), validation_freq=1, callbacks=[cp_callback]) # 刻画 loss 和 acc 曲线 loss = history.history[\u0026#39;loss\u0026#39;] val_loss = history.history[\u0026#39;val_loss\u0026#39;] acc = history.history[\u0026#39;sparse_categorical_accuracy\u0026#39;] # 训练集准确率 val_acc = history.history[\u0026#39;val_sparse_categorical_accuracy\u0026#39;] # 测试集准确率 plt.subplot(1, 2, 1) plt.plot(acc, label=\u0026#39;Training Accuracy\u0026#39;) plt.plot(val_acc, label=\u0026#39;Validation Accuracy\u0026#39;) plt.title(\u0026#34;Training and Validation Accuracy\u0026#34;) plt.legend() plt.subplot(1, 2, 2) plt.plot(loss, label=\u0026#39;Training Loss\u0026#39;) plt.plot(val_loss, label=\u0026#39;Validation Loss\u0026#39;) plt.title(\u0026#34;Training and Validation Loss\u0026#34;) plt.legend() plt.show() \u0026#34;\u0026#34;\u0026#34; model.summary \u0026#34;\u0026#34;\u0026#34; model.summary() 5. 给图识物，进行预测 # 复现模型 model = tf.keras.models.Squential([ tf.keras.layers.Flatten(), tf.keras.layers.Dense(128, activation=\u0026#39;relu\u0026#39;), tf.keras.layers.Dense(10, activation=\u0026#39;softmax\u0026#39;) ]) 加载参数 model.load_weights(model_save_path) 预测结果 resutl = model.predict(x_predict) 预测代码：\nfrom PIL import Image from tensorflow.keras.layers import Dense, Flatten import tensorflow as tf from tensorflow.keras import Model import numpy as np model_save_path = \u0026#39;./checkpoint/mnist.ckpt\u0026#39; # model = tf.keras.models.Sequential([ # tf.keras.layers.Flatten(), # tf.keras.layers.Dense(128, activation=\u0026#39;relu\u0026#39;), # tf.keras.layers.Dense(10, activation=\u0026#39;softmax\u0026#39;) # ]) class MnistModel(Model): # 之前使用 class 搭建网络，则这里也必须使用 class 搭建网络，否则会报错 def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.f1 = Flatten() self.d1 = Dense(120, activation=\u0026#39;relu\u0026#39;) self.d2 = Dense(10, activation=\u0026#39;softmax\u0026#39;) def call(self, x): x = self.f1(x) x = self.d1(x) x = self.d2(x) return x model = MnistModel() model.load_weights(model_save_path) preNum = int(input(\u0026#34;input the number of test pictures:\u0026#34;)) for i in range(preNum): image_path = input(\u0026#39;the path of test picture:\u0026#39;) img = Image.open(image_path) img = img.resize((28, 28), Image.BILINEAR) img_arr = np.array(img.convert(\u0026#39;L\u0026#39;)) img_arr = 255 - img_arr # for i in range(28): # for j in range(28): # if img_arr[i][j] \u0026lt; 200: # img_arr[i][j] = 255 # else: # img_arr[i][j] = 0 img_arr = img_arr / 255 # 归一化 x_predict= img_arr[tf.newaxis, ...] result = model.predict(x_predict) pred = tf.argmax(result, axis=1) # 注意 axis print(pred) "},{"id":23,"href":"/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"结构型模式","section":"设计模式","content":" 结构型模式 # 1 代理模式 # 1.1 概述 # 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\nJava中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\n1.2 结构 # 代理（Proxy）模式分为三种角色：\n抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 1.3 案例实现 # 火车站卖票：如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\n1.3.1 静态代理 # 点击展开 ... //卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\u0026#34;火车站卖票\u0026#34;); } } //代售点 public class ProxyPoint implements SellTickets { private TrainStation station = new TrainStation(); public void sell() { System.out.println(\u0026#34;代理点收取一些服务费用\u0026#34;); station.sell(); } } //测试类 public class Client { public static void main(String[] args) { ProxyPoint pp = new ProxyPoint(); pp.sell(); } } 从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\n1.3.2 JDK 动态代理 # 接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。\n点击展开 ... //卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\u0026#34;火车站卖票\u0026#34;); } } //代理工厂，用来创建代理对象 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { //使用Proxy获取代理对象 /* newProxyInstance()方法参数说明： ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 Class\u0026lt;?\u0026gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { /* InvocationHandler中invoke方法参数说明： proxy ： 代理对象 method ： 对应于在代理对象上调用的接口方法的 Method 实例 args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;代理点收取一些服务费用(JDK动态代理方式)\u0026#34;); //执行真实对象 Object result = method.invoke(station, args); return result; } }); return sellTickets; } } //测试类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } 使用了动态代理，我们思考下面问题：\nProxyFactory是代理类吗？\nProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：\n点击展开 ... package com.sun.proxy; import com.itheima.proxy.dynamic.jdk.SellTickets; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements SellTickets { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { try { m1 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;equals\u0026#34;, Class.forName(\u0026#34;java.lang.Object\u0026#34;)); m2 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;toString\u0026#34;, new Class[0]); m3 = Class.forName(\u0026#34;com.itheima.proxy.dynamic.jdk.SellTickets\u0026#34;).getMethod(\u0026#34;sell\u0026#34;, new Class[0]); m0 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;hashCode\u0026#34;, new Class[0]); return; } catch (NoSuchMethodException noSuchMethodException) { throw new NoSuchMethodError(noSuchMethodException.getMessage()); } catch (ClassNotFoundException classNotFoundException) { throw new NoClassDefFoundError(classNotFoundException.getMessage()); } } public final boolean equals(Object object) { try { return (Boolean)this.h.invoke(this, m1, new Object[]{object}); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final String toString() { try { return (String)this.h.invoke(this, m2, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final int hashCode() { try { return (Integer)this.h.invoke(this, m0, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final void sell() { try { this.h.invoke(this, m3, null); return; } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } } 从上面的类中，我们可以看到以下几个信息：\n代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。 代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。 动态代理的执行流程是什么样？下面是摘取的重点代码： 点击展开 ... //程序运行过程中动态生成的代理类 public final class $Proxy0 extends Proxy implements SellTickets { private static Method m3; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { m3 = Class.forName(\u0026#34;com.itheima.proxy.dynamic.jdk.SellTickets\u0026#34;).getMethod(\u0026#34;sell\u0026#34;, new Class[0]); } public final void sell() { this.h.invoke(this, m3, null); } } //Java提供的动态代理相关类 public class Proxy implements java.io.Serializable { protected InvocationHandler h; protected Proxy(InvocationHandler h) { this.h = h; } } //代理工厂类 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;代理点收取一些服务费用(JDK动态代理方式)\u0026#34;); Object result = method.invoke(station, args); return result; } }); return sellTickets; } } //测试访问类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } 执行流程如下：\n1. 在测试类中通过代理对象调用sell()方法 2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法 3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法 4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法 1.3.3 CGLIB动态代理 # 同样是上面的案例，我们再次使用CGLIB代理实现。\n如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\nCGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\nCGLIB是第三方提供的包，所以需要引入jar包的坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 点击展开 ... //火车站 public class TrainStation { public void sell() { System.out.println(\u0026#34;火车站卖票\u0026#34;); } } //代理工厂 public class ProxyFactory implements MethodInterceptor { private TrainStation target = new TrainStation(); public TrainStation getProxyObject() { //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; } /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;代理点收取一些服务费用(CGLIB动态代理方式)\u0026#34;); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; } } //测试类 public class Client { public static void main(String[] args) { //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); } } 1.4 应用场景 # 远程（Remote）代理\n本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。\n防火墙（Firewall）代理\n当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。\n保护（Protect or Access）代理\n控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。\n1.5 优缺点 # 优点：\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点：\n增加了系统的复杂度； 1.6 三种代理的对比 # jdk代理和CGLIB代理\n使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\n在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\n动态代理和静态代理\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\n如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\n2 适配器模式 # 2.1 概述 # 如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\n将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n2.2 结构 # 适配器模式（Adapter）包含以下主要角色：\n目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 2.3 案例实现 # 读卡器：现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。\n2.3.1 类适配器模式 # 实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。\n点击展开 ... //SD卡的接口 public interface SDCard { //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg); } //SD卡实现类 public class SDCardImpl implements SDCard { public String readSD() { String msg = \u0026#34;sd card read a msg :hello word SD\u0026#34;; return msg; } public void writeSD(String msg) { System.out.println(\u0026#34;sd card write msg : \u0026#34; + msg); } } //电脑类 public class Computer { public String readSD(SDCard sdCard) { if(sdCard == null) { throw new NullPointerException(\u0026#34;sd card null\u0026#34;); } return sdCard.readSD(); } } //TF卡接口 public interface TFCard { //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg); } //TF卡实现类 public class TFCardImpl implements TFCard { public String readTF() { String msg =\u0026#34;tf card read msg : hello word tf card\u0026#34;; return msg; } public void writeTF(String msg) { System.out.println(\u0026#34;tf card write a msg : \u0026#34; + msg); } } //定义适配器类（SD兼容TF） public class SDAdapterTF extends TFCardImpl implements SDCard { public String readSD() { System.out.println(\u0026#34;adapter read tf card \u0026#34;); return readTF(); } public void writeSD(String msg) { System.out.println(\u0026#34;adapter write tf card\u0026#34;); writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\u0026#34;------------\u0026#34;); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); } } 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。\n2.3.2 对象适配器模式 # 实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。\n点击展开 ... 类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。\n//创建适配器对象（SD兼容TF） public class SDAdapterTF implements SDCard { private TFCard tfCard; public SDAdapterTF(TFCard tfCard) { this.tfCard = tfCard; } public String readSD() { System.out.println(\u0026#34;adapter read tf card \u0026#34;); return tfCard.readTF(); } public void writeSD(String msg) { System.out.println(\u0026#34;adapter write tf card\u0026#34;); tfCard.writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\u0026#34;------------\u0026#34;); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); } } 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。\n2.4 应用场景 # 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 2.5 JDK源码解析 # Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。\nInputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：\npublic int read() throws IOException { return sd.read(); } public int read(char cbuf[], int offset, int length) throws IOException { return sd.read(cbuf, offset, length); } 如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：\n从上图可以看出：\nInputStreamReader是对同样实现了Reader的StreamDecoder的封装。 StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。 结论：\n从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。\n3 装饰者模式 # 3.1 概述 # 我们先来看一个快餐店的例子。\n快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。\n使用继承的方式存在的问题：\n扩展性不好\n如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。\n产生过多的子类\n装饰着模式指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。\n3.2 结构 # 装饰（Decorator）模式中的角色：\n抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 3.3 案例 # 我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。\n点击展开 ... //快餐接口 public abstract class FastFood { private float price; private String desc; public FastFood() { } public FastFood(float price, String desc) { this.price = price; this.desc = desc; } public void setPrice(float price) { this.price = price; } public float getPrice() { return price; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public abstract float cost(); //获取价格 } //炒饭 public class FriedRice extends FastFood { public FriedRice() { super(10, \u0026#34;炒饭\u0026#34;); } public float cost() { return getPrice(); } } //炒面 public class FriedNoodles extends FastFood { public FriedNoodles() { super(12, \u0026#34;炒面\u0026#34;); } public float cost() { return getPrice(); } } //配料类 public abstract class Garnish extends FastFood { private FastFood fastFood; public FastFood getFastFood() { return fastFood; } public void setFastFood(FastFood fastFood) { this.fastFood = fastFood; } public Garnish(FastFood fastFood, float price, String desc) { super(price,desc); this.fastFood = fastFood; } } //鸡蛋配料 public class Egg extends Garnish { public Egg(FastFood fastFood) { super(fastFood,1,\u0026#34;鸡蛋\u0026#34;); } public float cost() { return getPrice() + getFastFood().getPrice(); } @Override public String getDesc() { return super.getDesc() + getFastFood().getDesc(); } } //培根配料 public class Bacon extends Garnish { public Bacon(FastFood fastFood) { super(fastFood,2,\u0026#34;培根\u0026#34;); } @Override public float cost() { return getPrice() + getFastFood().getPrice(); } @Override public String getDesc() { return super.getDesc() + getFastFood().getDesc(); } } //测试类 public class Client { public static void main(String[] args) { //点一份炒饭 FastFood food = new FriedRice(); //花费的价格 System.out.println(food.getDesc() + \u0026#34; \u0026#34; + food.cost() + \u0026#34;元\u0026#34;); System.out.println(\u0026#34;========\u0026#34;); //点一份加鸡蛋的炒饭 FastFood food1 = new FriedRice(); food1 = new Egg(food1); //花费的价格 System.out.println(food1.getDesc() + \u0026#34; \u0026#34; + food1.cost() + \u0026#34;元\u0026#34;); System.out.println(\u0026#34;========\u0026#34;); //点一份加培根的炒面 FastFood food2 = new FriedNoodles(); food2 = new Bacon(food2); //花费的价格 System.out.println(food2.getDesc() + \u0026#34; \u0026#34; + food2.cost() + \u0026#34;元\u0026#34;); } } 好处：\n饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。\n装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n3.4 应用场景 # 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。\n不能采用继承的情况主要有两类：\n第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长； 第二类是因为类定义不能继承（如final类） 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n当对象的功能要求可以动态地添加，也可以再动态地撤销时。\n3.5 JDK源码解析 # IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。\n我们以 BufferedWriter 举例来说明，先看看如何使用 BufferedWriter\n点击展开 ... public class Demo { public static void main(String[] args) throws Exception{ //创建BufferedWriter对象 //创建FileWriter对象 FileWriter fw = new FileWriter(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\u0026#34;); BufferedWriter bw = new BufferedWriter(fw); //写数据 bw.write(\u0026#34;hello Buffered\u0026#34;); bw.close(); } } 使用起来感觉确实像是装饰者模式，接下来看它们的结构：\n小结：\n​\tBufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。\n3.6 代理和装饰者的区别 # 静态代理和装饰者模式的区别：\n相同点： 都要实现与目标类相同的业务接口 在两个类中都要声明目标对象 都可以在不修改目标类的前提下增强目标方法 不同点： 目的不同 装饰者是为了增强目标对象 静态代理是为了保护和隐藏目标对象 获取目标对象构建的地方不同 装饰者是由外界传递进来，可以通过构造方法传递 静态代理是在代理类内部创建，以此来隐藏目标对象 4 桥接模式 # 4.1 概述 # 现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：\n我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。\n试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。\n将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n4.2 结构 # 桥接（Bridge）模式包含以下主要角色：\n抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 4.3 案例 # 视频播放器：需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。\n类图如下：\n点击展开 ... //视频文件 public interface VideoFile { void decode(String fileName); } //avi文件 public class AVIFile implements VideoFile { public void decode(String fileName) { System.out.println(\u0026#34;avi视频文件：\u0026#34;+ fileName); } } //rmvb文件 public class REVBBFile implements VideoFile { public void decode(String fileName) { System.out.println(\u0026#34;rmvb文件：\u0026#34; + fileName); } } //操作系统版本 public abstract class OperatingSystemVersion { protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) { this.videoFile = videoFile; } public abstract void play(String fileName); } //Windows版本 public class Windows extends OperatingSystem { public Windows(VideoFile videoFile) { super(videoFile); } public void play(String fileName) { videoFile.decode(fileName); } } //mac版本 public class Mac extends OperatingSystemVersion { public Mac(VideoFile videoFile) { super(videoFile); } public void play(String fileName) { videoFile.decode(fileName); } } //测试类 public class Client { public static void main(String[] args) { OperatingSystem os = new Windows(new AVIFile()); os.play(\u0026#34;战狼3\u0026#34;); } } 好处：\n桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。\n如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。\n实现细节对客户透明\n4.4 使用场景 # 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 5 外观模式 # 5.1 概述 # 有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。\n外观模式又名 门面模式 ，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\n外观（Facade）模式是“迪米特法则”的典型应用。\n5.2 结构 # 外观（Facade）模式包含以下主要角色：\n外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 5.3 案例 # 智能家电控制：小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：\n点击展开 ... //灯类 public class Light { public void on() { System.out.println(\u0026#34;打开了灯....\u0026#34;); } public void off() { System.out.println(\u0026#34;关闭了灯....\u0026#34;); } } //电视类 public class TV { public void on() { System.out.println(\u0026#34;打开了电视....\u0026#34;); } public void off() { System.out.println(\u0026#34;关闭了电视....\u0026#34;); } } //控制类 public class AirCondition { public void on() { System.out.println(\u0026#34;打开了空调....\u0026#34;); } public void off() { System.out.println(\u0026#34;关闭了空调....\u0026#34;); } } //智能音箱 public class SmartAppliancesFacade { private Light light; private TV tv; private AirCondition airCondition; public SmartAppliancesFacade() { light = new Light(); tv = new TV(); airCondition = new AirCondition(); } public void say(String message) { if(message.contains(\u0026#34;打开\u0026#34;)) { on(); } else if(message.contains(\u0026#34;关闭\u0026#34;)) { off(); } else { System.out.println(\u0026#34;我还听不懂你说的！！！\u0026#34;); } } //起床后一键开电器 private void on() { System.out.println(\u0026#34;起床了\u0026#34;); light.on(); tv.on(); airCondition.on(); } //睡觉一键关电器 private void off() { System.out.println(\u0026#34;睡觉了\u0026#34;); light.off(); tv.off(); airCondition.off(); } } //测试类 public class Client { public static void main(String[] args) { //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(\u0026#34;打开家电\u0026#34;); facade.say(\u0026#34;关闭家电\u0026#34;); } } 好处：\n降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 缺点：\n不符合开闭原则，修改很麻烦 5.4 使用场景 # 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 5.5 源码解析 # 使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。\nRequestFacade 类就使用了外观模式。先看结构图：\n为什么在此处使用外观模式呢？\n定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request 的实现。然后，将 RequestFacade上转为 ServletRequest 传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。\n6 组合模式 # 6.1 概述 # ​\t对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。\n组合模式又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n6.2 结构 # 组合模式主要包含三种角色：\n抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 6.3 案例实现 # 软件菜单：如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。\n要实现该案例，我们先画出类图：\n不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。\n点击展开 ... //菜单组件 不管是菜单还是菜单项，都应该继承该类 public abstract class MenuComponent { protected String name; protected int level; //添加菜单 public void add(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } //移除菜单 public void remove(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } //获取指定的子菜单 public MenuComponent getChild(int i){ throw new UnsupportedOperationException(); } //获取菜单名称 public String getName(){ return name; } public void print(){ throw new UnsupportedOperationException(); } } 这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。\n点击展开 ... public class Menu extends MenuComponent { private List\u0026lt;MenuComponent\u0026gt; menuComponentList; public Menu(String name,int level){ this.level = level; this.name = name; menuComponentList = new ArrayList\u0026lt;MenuComponent\u0026gt;(); } @Override public void add(MenuComponent menuComponent) { menuComponentList.add(menuComponent); } @Override public void remove(MenuComponent menuComponent) { menuComponentList.remove(menuComponent); } @Override public MenuComponent getChild(int i) { return menuComponentList.get(i); } @Override public void print() { for (int i = 1; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(name); for (MenuComponent menuComponent : menuComponentList) { menuComponent.print(); } } } Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。\n点击展开 ... public class MenuItem extends MenuComponent { public MenuItem(String name,int level) { this.name = name; this.level = level; } @Override public void print() { for (int i = 1; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(name); } } 好处：\n组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 6.4 使用场景 # 组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。\n6.5 组合模式的分类 # 在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。\n透明组合模式\n透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。\n透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）\n安全组合模式\n在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。\n7 享元模式 # 7.1 概述 # 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。\n7.2 结构 # 享元（Flyweight ）模式中存在以下两种状态：\n内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色：\n抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 7.3 案例实现 # 俄罗斯方块：下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。\n先来看类图：\n俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。\n点击展开 ... public abstract class AbstractBox { public abstract String getShape(); public void display(String color) { System.out.println(\u0026#34;方块形状：\u0026#34; + this.getShape() + \u0026#34; 颜色：\u0026#34; + color); } } 接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。\n点击展开 ... public class IBox extends AbstractBox { @Override public String getShape() { return \u0026#34;I\u0026#34;; } } public class LBox extends AbstractBox { @Override public String getShape() { return \u0026#34;L\u0026#34;; } } public class OBox extends AbstractBox { @Override public String getShape() { return \u0026#34;O\u0026#34;; } } 提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。\n点击展开 ... public class BoxFactory { private static HashMap\u0026lt;String, AbstractBox\u0026gt; map; private BoxFactory() { map = new HashMap\u0026lt;String, AbstractBox\u0026gt;(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(\u0026#34;I\u0026#34;, iBox); map.put(\u0026#34;L\u0026#34;, lBox); map.put(\u0026#34;O\u0026#34;, oBox); } public static final BoxFactory getInstance() { return SingletonHolder.INSTANCE; } private static class SingletonHolder { private static final BoxFactory INSTANCE = new BoxFactory(); } public AbstractBox getBox(String key) { return map.get(key); } } 优点\n极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能 享元模式中的外部状态相对独立，且不影响内部状态 缺点：\n为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂。\n7.4 使用场景 # 一个系统有大量相同或者相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。 7.5 JDK源码解析 # Integer类使用了享元模式。我们先看下面的例子：\n点击展开 ... public class Demo { public static void main(String[] args) { Integer i1 = 127; Integer i2 = 127; System.out.println(\u0026#34;i1和i2对象是否是同一个对象？\u0026#34; + (i1 == i2)); Integer i3 = 128; Integer i4 = 128; System.out.println(\u0026#34;i3和i4对象是否是同一个对象？\u0026#34; + (i3 == i4)); } } 运行上面代码，结果如下：\n为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：\n点击展开 ... public class Demo { public static void main(String[] args) { Integer i1 = Integer.valueOf((int)127); Integer i2 Integer.valueOf((int)127); System.out.println((String)new StringBuilder().append((String)\u0026#34;i1\\u548ci2\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f\u0026#34;).append((boolean)(i1 == i2)).toString()); Integer i3 = Integer.valueOf((int)128); Integer i4 = Integer.valueOf((int)128); System.out.println((String)new StringBuilder().append((String)\u0026#34;i3\\u548ci4\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f\u0026#34;).append((boolean)(i3 == i4)).toString()); } } 上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 valueOf() ，所以只需要看该方法即可\n点击展开 ... public final class Integer extends Number implements Comparable\u0026lt;Integer\u0026gt; { public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k \u0026lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } } 可以看到 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象。\n"},{"id":24,"href":"/notes/mybatisplus/%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4/","title":"逻辑删除","section":"MyBatisPlus","content":"逻辑删除主要步骤如下：\n新增 deleted 字段\n实体类中添加对应字段并注释，如下\n@TableLogic private Integer deleted; 配置文件默认如下，也可以自定义，主要用于指定删除或未删除的默认值\nmybatis-plus: global-config: db-config: logic-delete-value: 1 logic-not-delete-value: 0 "},{"id":25,"href":"/notes/jvm/%E5%A0%86/","title":"堆","section":"JVM","content":" 堆（Heap） # 通过 new 关键字创建的对象都会使用堆。\n堆的特点 # 线程共享，堆中的对象都需要考虑线程安全问题。 有垃圾回收机制 堆内存溢出代码 # public class Demo1_5 { public static void main(String[] args) { int i = 0; try { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String a = \u0026#34;hello\u0026#34;; while (true) { list.add(a); a = a + a; i++; } } catch (Throwable e) { e.printStackTrace(); System.out.println(i); } } } 报错代码 ... java.lang.OutOfMemoryError: Java heap space at java.base/java.util.Arrays.copyOf(Arrays.java:3512) at java.base/java.util.Arrays.copyOf(Arrays.java:3481) at java.base/java.util.ArrayList.grow(ArrayList.java:237) at java.base/java.util.ArrayList.grow(ArrayList.java:244) at java.base/java.util.ArrayList.add(ArrayList.java:454) at java.base/java.util.ArrayList.add(ArrayList.java:467) at Demo1_5.main(Demo1_5.java:11) 532254060 堆内存大小设置 # 如下：-Xmx1024m\n⚠️注意：内存非常大的时候可能暂时不太会暴露内存溢出的问题。\njconsole 工具使用 # 运行以下代码，使用 jconsole 工具观察其内存占用情况：\npublic class Demo1_4 { public static void main(String[] args) throws InterruptedException { System.out.println(\u0026#34;1...\u0026#34;); Thread.sleep(30000); byte[] array = new byte[1024 * 1024 * 10]; System.out.println(\u0026#34;2...\u0026#34;); Thread.sleep(30000); array = null; System.gc(); System.out.println(\u0026#34;3...\u0026#34;); Thread.sleep(1000000L); } } jconsole 查看分析如下：\n案例：垃圾回收后，内存占用依然很高 # 使用 jvisualvm 工具 查看 堆 dump 查看快照 查看占用资源最多的程序 "},{"id":26,"href":"/notes/redis/redis-set/","title":"Redis Set","section":"Redis","content":" Redis Set # 常用命令 # sadd \u0026lt;key\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;value2\u0026gt;：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略\nsmembers \u0026lt;key\u0026gt;：取出集合的所有值\nsismember \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;：判断 key 中是否有 value，有1无0\nscard \u0026lt;key\u0026gt;：返回该集合中元素的个数\nsrem \u0026lt;key\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;value2\u0026gt; \u0026lt;value3\u0026gt;：删除集合中的指定元素\nspop \u0026lt;key\u0026gt;：随机从集合中吐出一个值\nsrandmember \u0026lt;key\u0026gt; \u0026lt;n\u0026gt;：随机从集合中取出 n 个值，不会从集合中删除\nsmove \u0026lt;source\u0026gt; \u0026lt;destination\u0026gt; \u0026lt;value\u0026gt;：集合中的某个值移动到另一个集合\nsinter \u0026lt;key1\u0026gt; \u0026lt;key2\u0026gt;：返回两个集合的交集元素\nsunion \u0026lt;key1\u0026gt; \u0026lt;key2\u0026gt;：返回两个集合的并集元素\nsdiff \u0026lt;key1\u0026gt; \u0026lt;key2\u0026gt;：返回两个集合的差集元素\n数据结构 # Set 数据结构是 dict 字典，字典是用哈希表实现的。\nJava 中 HashSet 的内部实现使用的是 HashMap，但是所有的 value 都指向同一个对象。Redis 的 set 结构同样如此，内部也是用 hash 结构，所有的 value 都指向同一个内部值。\n"},{"id":27,"href":"/notes/tensorflow/tensorflow-%E7%AC%94%E8%AE%B0%E4%BA%94/","title":"Tensor Flow 笔记（五）","section":"TensorFlow","content":" TensorFlow 笔记（五） # 介绍卷积神经网络的一些概念，并利用卷积神经网络对 Cifar10 数据集进行分类。\n1.全连接NN # 每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测的结果。\n实际应用时会先对原始图像进行特征提取，再把提取到的特征送给全连接网络。\n2.卷积 # 卷积计算是一种有效的提取图像特征的方法。\n一般会用一个正方形的卷积核，按指定步长，在输入特征图上滑动，遍历输入特征图中的每个像素点。每一个步长，卷积核会与输入特征图出现重合区域，重合区域对应元素相乘，求和再加上偏执项得到输出特征的一个像素点。\n输入特征图的深度（channel数）决定了当前层卷积核的深度；当前层卷积核的个数，决定了当前层输出特征图的深度。\ntf.keras.layers.Conv2D( filters = ,\t# 卷积核个数 kernel_size = ,\t# 卷积核尺寸 # stride = ,\t# 滑动步长 padding = ,\t# \u0026#34;same\u0026#34; or \u0026#34;valid\u0026#34; activation = ,\t# \u0026#34;relu\u0026#34;，\u0026#34;sofmax\u0026#34;，\u0026#34;tanh\u0026#34;，\u0026#34;sigmoid\u0026#34; # input_shape = ,\t# (高，宽，通道数) ) 3. 感受野 # 卷积神经网络各输出特征图中的每个像素点在原始输入图片上映射区域的大小。 \\[padding=\\begin{cases}SAME（全零填充）, \u0026amp; \\frac {入长}{步长}（向上取整） \\\\ VALID（不全零填充）, \u0026amp; \\frac {入长-核长\u0026#43;1}{步长}（向上取整） \\end{cases}\\] 4. 批标准化（Batch Normalization，BN） # 标准化：使数据符合均值为 0，1 位标准差的分布\n批标准化：对一小批数据（batch），做标准化处理\nBN层位置：BN 层位于卷积层之后，激活层之前。\ntf.keras.layers.BatchNormalization() # 可以直接放 5. 池化（Pooling） # 池化用于减少特征数据量。\n最大池化可提取图片纹理，均值池化可保留背景特征。\ntf.keras.layers.MaxPool2D( pool_size=,\t# 池化核尺寸，正方形写核长整数或（核高h, 核宽w） strides=,\t# 池化步长，步长整数，或（纵向步长h，横向步长w），默认为 pool_size padding=,\t# \u0026#39;valid\u0026#39; or \u0026#39;same\u0026#39; 使用全零填充是\u0026#39;same\u0026#39;,不使用时\u0026#39;valid\u0026#39;（默认） ) tf.keras.layers.AveragePooling2D( pool_size=,\t# 池化核尺寸，正方形写核长整数或（核高h, 核宽w） strides=,\t# 池化步长，步长整数，或（纵向步长h，横向步长w），默认为 pool_size padding=,\t# \u0026#39;valid\u0026#39; or \u0026#39;same\u0026#39; 使用全零填充是\u0026#39;same\u0026#39;,不使用时\u0026#39;valid\u0026#39;（默认） ) 6. 舍弃 (Dropout) # 在神经网络训练时，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。\ntf.keras.layers.Dropout(舍弃比例) 7.卷积神经网络 # 借助卷积核提取特征后，送入全连接网络。\n卷积神经网络的主要模块：\n卷积 批标准化 激活 池化 全连接 卷积是什么: 卷积就是特征提取器，就是 CBAPD。\nmodel = tf.keras.models.Sequential([ Conv2D(filters=6, kernel_size=(5,5), padding=\u0026#39;same\u0026#39;),\t# 卷积层 C BatchNormalization(),\t# BN层\tB Activation(\u0026#39;relu\u0026#39;),\t# 激活层\tA MaxPool2D(pool_size=(2,2), strides=2, padding=\u0026#39;same\u0026#39;),\t# 池化层\tP Dropout(0.2),\t# dropout层 D ]) "},{"id":28,"href":"/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"行为型模式","section":"设计模式","content":" 行为型模式 # 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\n1 模板方法模式 # 1.1 概述 # 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\n例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\n定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n1.2 结构 # 模板方法（Template Method）模式包含以下主要角色：\n抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\n模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\n基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\n抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\n具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\n一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\n具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\n1.3 案例实现 # 炒菜：炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：\n点击展开 ... public abstract class AbstractClass { public final void cookProcess() { //第一步：倒油 this.pourOil(); //第二步：热油 this.heatOil(); //第三步：倒蔬菜 this.pourVegetable(); //第四步：倒调味料 this.pourSauce(); //第五步：翻炒 this.fry(); } public void pourOil() { System.out.println(\u0026#34;倒油\u0026#34;); } //第二步：热油是一样的，所以直接实现 public void heatOil() { System.out.println(\u0026#34;热油\u0026#34;); } //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心） public abstract void pourVegetable(); //第四步：倒调味料是不一样 public abstract void pourSauce(); //第五步：翻炒是一样的，所以直接实现 public void fry(){ System.out.println(\u0026#34;炒啊炒啊炒到熟啊\u0026#34;); } } public class ConcreteClass_BaoCai extends AbstractClass { @Override public void pourVegetable() { System.out.println(\u0026#34;下锅的蔬菜是包菜\u0026#34;); } @Override public void pourSauce() { System.out.println(\u0026#34;下锅的酱料是辣椒\u0026#34;); } } public class ConcreteClass_CaiXin extends AbstractClass { @Override public void pourVegetable() { System.out.println(\u0026#34;下锅的蔬菜是菜心\u0026#34;); } @Override public void pourSauce() { System.out.println(\u0026#34;下锅的酱料是蒜蓉\u0026#34;); } } public class Client { public static void main(String[] args) { //炒手撕包菜 ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai(); baoCai.cookProcess(); //炒蒜蓉菜心 ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin(); caiXin.cookProcess(); } } 注意：为防止恶意操作，一般模板方法都加上 final 关键词。\n优点：\n提高代码复用性\n将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\n实现了反向控制\n通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\n缺点：\n对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 1.4 适用场景 # 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 1.5 JDK源码解析 # 点击展开 ... InputStream类就使用了模板方法模式。在InputStream类中定义了多个 read() 方法，如下：\npublic abstract class InputStream implements Closeable { //抽象方法，要求子类必须重写 public abstract int read() throws IOException; public int read(byte b[]) throws IOException { return read(b, 0, b.length); } public int read(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off \u0026lt; 0 || len \u0026lt; 0 || len \u0026gt; b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据 if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i \u0026lt; len ; i++) { c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; } } 从上面代码可以看到，无参的 read() 方法是抽象方法，要求子类必须实现。而 read(byte b[]) 方法调用了 read(byte b[], int off, int len) 方法，所以在此处重点看的方法是带三个参数的方法。\n在该方法中第18行、27行，可以看到调用了无参的抽象的 read() 方法。\n总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\n2.2 策略模式 # 2.1 概述 # 先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。\n作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。\n策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\n2.2 结构 # 策略模式的主要角色如下：\n抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。 2.3 案例实现 # 促销活动：一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：\n代码如下：\n定义百货公司所有促销活动的共同接口\n点击展开 ... public interface Strategy { void show(); } 定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动\n点击展开 ... //为春节准备的促销活动A public class StrategyA implements Strategy { public void show() { System.out.println(\u0026#34;买一送一\u0026#34;); } } //为中秋准备的促销活动B public class StrategyB implements Strategy { public void show() { System.out.println(\u0026#34;满200元减50元\u0026#34;); } } //为圣诞准备的促销活动C public class StrategyC implements Strategy { public void show() { System.out.println(\u0026#34;满1000元加一元换购任意200元以下商品\u0026#34;); } } 定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员\n点击展开 ... public class SalesMan { //持有抽象策略角色的引用 private Strategy strategy; public SalesMan(Strategy strategy) { this.strategy = strategy; } //向客户展示促销活动 public void salesManShow(){ strategy.show(); } } 优点：\n策略类之间可以自由切换\n由于策略类都实现同一个接口，所以使它们之间可以自由切换。\n易于扩展\n增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“\n避免使用多重条件选择语句（if else），充分体现面向对象设计思想。\n缺点：\n客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 2.4 使用场景 # 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 2.5 JDK源码解析 # Comparator 中的策略模式。在Arrays类中有一个 sort() 方法，如下：\n点击展开 ... public class Arrays{ public static \u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c) { if (c == null) { sort(a); } else { if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); } } } Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。\n点击展开 ... public class demo { public static void main(String[] args) { Integer[] data = {12, 2, 3, 2, 4, 5, 1}; // 实现降序排序 Arrays.sort(data, new Comparator\u0026lt;Integer\u0026gt;() { public int compare(Integer o1, Integer o2) { return o2 - o1; } }); System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1] } } 这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 compare() 方法吗？让我们继续查看TimSort类的 sort() 方法，代码如下：\n点击展开 ... class TimSort\u0026lt;T\u0026gt; { static \u0026lt;T\u0026gt; void sort(T[] a, int lo, int hi, Comparator\u0026lt;? super T\u0026gt; c, T[] work, int workBase, int workLen) { assert c != null \u0026amp;\u0026amp; a != null \u0026amp;\u0026amp; lo \u0026gt;= 0 \u0026amp;\u0026amp; lo \u0026lt;= hi \u0026amp;\u0026amp; hi \u0026lt;= a.length; int nRemaining = hi - lo; if (nRemaining \u0026lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \u0026#34;mini-TimSort\u0026#34; with no merges if (nRemaining \u0026lt; MIN_MERGE) { int initRunLen = countRunAndMakeAscending(a, lo, hi, c); binarySort(a, lo, hi, lo + initRunLen, c); return; } ... } private static \u0026lt;T\u0026gt; int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator\u0026lt;? super T\u0026gt; c) { assert lo \u0026lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (c.compare(a[runHi++], a[lo]) \u0026lt; 0) { // Descending while (runHi \u0026lt; hi \u0026amp;\u0026amp; c.compare(a[runHi], a[runHi - 1]) \u0026lt; 0) runHi++; reverseRange(a, lo, runHi); } else { // Ascending while (runHi \u0026lt; hi \u0026amp;\u0026amp; c.compare(a[runHi], a[runHi - 1]) \u0026gt;= 0) runHi++; } return runHi - lo; } } 上面的代码中最终会跑到 countRunAndMakeAscending() 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。\n3 命令模式 # 3.1 概述 # 日常生活中，我们出去吃饭都会遇到下面的场景。\n将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。\n3.2 结构 # 命令模式包含以下主要角色：\n抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 3.3 案例实现 # 将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。\n服务员： 就是调用者角色，由她来发起命令。\n资深大厨： 就是接收者角色，真正命令执行的对象。\n订单： 命令中包含订单。\n类图如下：\n点击展开 ... public interface Command { void execute();//只需要定义一个统一的执行方法 } public class OrderCommand implements Command { //持有接受者对象 private SeniorChef receiver; private Order order; public OrderCommand(SeniorChef receiver, Order order){ this.receiver = receiver; this.order = order; } public void execute() { System.out.println(order.getDiningTable() + \u0026#34;桌的订单：\u0026#34;); Set\u0026lt;String\u0026gt; keys = order.getFoodDic().keySet(); for (String key : keys) { receiver.makeFood(order.getFoodDic().get(key),key); } try { Thread.sleep(100);//停顿一下 模拟做饭的过程 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(order.getDiningTable() + \u0026#34;桌的饭弄好了\u0026#34;); } } public class Order { // 餐桌号码 private int diningTable; // 用来存储餐名并记录份数 private Map\u0026lt;String, Integer\u0026gt; foodDic = new HashMap\u0026lt;String, Integer\u0026gt;(); public int getDiningTable() { return diningTable; } public void setDiningTable(int diningTable) { this.diningTable = diningTable; } public Map\u0026lt;String, Integer\u0026gt; getFoodDic() { return foodDic; } public void setFoodDic(String name, int num) { foodDic.put(name,num); } } // 资深大厨类 是命令的Receiver public class SeniorChef { public void makeFood(int num,String foodName) { System.out.println(num + \u0026#34;份\u0026#34; + foodName); } } public class Waitor { private ArrayList\u0026lt;Command\u0026gt; commands;//可以持有很多的命令对象 public Waitor() { commands = new ArrayList(); } public void setCommand(Command cmd){ commands.add(cmd); } // 发出命令 喊 订单来了，厨师开始执行 public void orderUp() { System.out.println(\u0026#34;美女服务员：叮咚，大厨，新订单来了.......\u0026#34;); for (int i = 0; i \u0026lt; commands.size(); i++) { Command cmd = commands.get(i); if (cmd != null) { cmd.execute(); } } } } public class Client { public static void main(String[] args) { //创建2个order Order order1 = new Order(); order1.setDiningTable(1); order1.getFoodDic().put(\u0026#34;西红柿鸡蛋面\u0026#34;,1); order1.getFoodDic().put(\u0026#34;小杯可乐\u0026#34;,2); Order order2 = new Order(); order2.setDiningTable(3); order2.getFoodDic().put(\u0026#34;尖椒肉丝盖饭\u0026#34;,1); order2.getFoodDic().put(\u0026#34;小杯雪碧\u0026#34;,1); //创建接收者 SeniorChef receiver=new SeniorChef(); //将订单和接收者封装成命令对象 OrderCommand cmd1 = new OrderCommand(receiver, order1); OrderCommand cmd2 = new OrderCommand(receiver, order2); //创建调用者 waitor Waitor invoker = new Waitor(); invoker.setCommand(cmd1); invoker.setCommand(cmd2); //将订单带到柜台 并向厨师喊 订单来了 invoker.orderUp(); } } 优点：\n降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 缺点：\n使用命令模式可能会导致某些系统有过多的具体命令类。 系统结构更加复杂。 3.4 使用场景 # 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队和执行请求。 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 3.5 JDK源码解析 # Runable 是一个典型命令模式，Runnable 担当命令的角色，Thread充当的是调用者，start` 方法就是其执行方法。\n点击展开 ... //命令接口(抽象命令角色) public interface Runnable { public abstract void run(); } //调用者 public class Thread implements Runnable { private Runnable target; public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } private native void start0(); } 会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。\n点击展开 ... /** * jdk Runnable 命令模式 *\tTurnOffThread ： 属于具体 */ public class TurnOffThread implements Runnable{ private Receiver receiver; public TurnOffThread(Receiver receiver) { this.receiver = receiver; } public void run() { receiver.turnOFF(); } } /** * 测试类 */ public class Demo { public static void main(String[] args) { Receiver receiver = new Receiver(); TurnOffThread turnOffThread = new TurnOffThread(receiver); Thread thread = new Thread(turnOffThread); thread.start(); } } 4 责任链模式 # 4.1 概述 # 在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。\n责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\n4.2 结构 # 职责链模式主要包含以下角色:\n抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 4.3 案例实现 # 现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。\n类图如下：\n点击展开 ... //请假条 public class LeaveRequest { private String name;//姓名 private int num;//请假天数 private String content;//请假内容 public LeaveRequest(String name, int num, String content) { this.name = name; this.num = num; this.content = content; } public String getName() { return name; } public int getNum() { return num; } public String getContent() { return content; } } //处理者抽象类 public abstract class Handler { protected final static int NUM_ONE = 1; protected final static int NUM_THREE = 3; protected final static int NUM_SEVEN = 7; //该领导处理的请假天数区间 private int numStart; private int numEnd; //领导上面还有领导 private Handler nextHandler; //设置请假天数范围 上不封顶 public Handler(int numStart) { this.numStart = numStart; } //设置请假天数范围 public Handler(int numStart, int numEnd) { this.numStart = numStart; this.numEnd = numEnd; } //设置上级领导 public void setNextHandler(Handler nextHandler){ this.nextHandler = nextHandler; } //提交请假条 public final void submit(LeaveRequest leave){ if(0 == this.numStart){ return; } //如果请假天数达到该领导者的处理要求 if(leave.getNum() \u0026gt;= this.numStart){ this.handleLeave(leave); //如果还有上级 并且请假天数超过了当前领导的处理范围 if(null != this.nextHandler \u0026amp;\u0026amp; leave.getNum() \u0026gt; numEnd){ this.nextHandler.submit(leave);//继续提交 } else { System.out.println(\u0026#34;流程结束\u0026#34;); } } } //各级领导处理请假条方法 protected abstract void handleLeave(LeaveRequest leave); } //小组长 public class GroupLeader extends Handler { public GroupLeader() { //小组长处理1-3天的请假 super(Handler.NUM_ONE, Handler.NUM_THREE); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + \u0026#34;请假\u0026#34; + leave.getNum() + \u0026#34;天,\u0026#34; + leave.getContent() + \u0026#34;。\u0026#34;); System.out.println(\u0026#34;小组长审批：同意。\u0026#34;); } } //部门经理 public class Manager extends Handler { public Manager() { //部门经理处理3-7天的请假 super(Handler.NUM_THREE, Handler.NUM_SEVEN); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + \u0026#34;请假\u0026#34; + leave.getNum() + \u0026#34;天,\u0026#34; + leave.getContent() + \u0026#34;。\u0026#34;); System.out.println(\u0026#34;部门经理审批：同意。\u0026#34;); } } //总经理 public class GeneralManager extends Handler { public GeneralManager() { //部门经理处理7天以上的请假 super(Handler.NUM_SEVEN); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + \u0026#34;请假\u0026#34; + leave.getNum() + \u0026#34;天,\u0026#34; + leave.getContent() + \u0026#34;。\u0026#34;); System.out.println(\u0026#34;总经理审批：同意。\u0026#34;); } } //测试类 public class Client { public static void main(String[] args) { //请假条来一张 LeaveRequest leave = new LeaveRequest(\u0026#34;小花\u0026#34;,5,\u0026#34;身体不适\u0026#34;); //各位领导 GroupLeader groupLeader = new GroupLeader(); Manager manager = new Manager(); GeneralManager generalManager = new GeneralManager(); groupLeader.setNextHandler(manager);//小组长的领导是部门经理 manager.setNextHandler(generalManager);//部门经理的领导是总经理 //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。 //提交申请 groupLeader.submit(leave); } } 优点：\n降低了对象之间的耦合度\n该模式降低了请求发送者和接收者的耦合度。\n增强了系统的可扩展性\n可以根据需要增加新的请求处理类，满足开闭原则。\n增强了给对象指派职责的灵活性\n当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。\n责任链简化了对象之间的连接\n一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。\n责任分担\n每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。\n缺点：\n不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 4.4 源码解析 # 在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:\n模拟web请求Request以及web响应Response\n点击展开 ... ```java public interface Request{ } public interface Response{ } ``` 模拟web过滤器Filter\n点击展开 ... public interface Filter { public void doFilter(Request req,Response res,FilterChain c); } 模拟实现具体过滤器\n点击展开 ... public class FirstFilter implements Filter { @Override public void doFilter(Request request, Response response, FilterChain chain) { System.out.println(\u0026#34;过滤器1 前置处理\u0026#34;); // 先执行所有request再倒序执行所有response chain.doFilter(request, response); System.out.println(\u0026#34;过滤器1 后置处理\u0026#34;); } } public class SecondFilter implements Filter { @Override public void doFilter(Request request, Response response, FilterChain chain) { System.out.println(\u0026#34;过滤器2 前置处理\u0026#34;); // 先执行所有request再倒序执行所有response chain.doFilter(request, response); System.out.println(\u0026#34;过滤器2 后置处理\u0026#34;); } } 模拟实现过滤器链FilterChain\n点击展开 ... public class FilterChain { private List\u0026lt;Filter\u0026gt; filters = new ArrayList\u0026lt;Filter\u0026gt;(); private int index = 0; // 链式调用 public FilterChain addFilter(Filter filter) { this.filters.add(filter); return this; } public void doFilter(Request request, Response response) { if (index == filters.size()) { return; } Filter filter = filters.get(index); index++; filter.doFilter(request, response, this); } } 测试类\n点击展开 ... public class Client { public static void main(String[] args) { Request req = null; Response res = null ; FilterChain filterChain = new FilterChain(); filterChain.addFilter(new FirstFilter()).addFilter(new SecondFilter()); filterChain.doFilter(req,res); } } 5 状态模式 # 5.1 概述 # 假如通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。\n点击展开 ... public interface ILift { //电梯的4个状态 //开门状态 public final static int OPENING_STATE = 1; //关门状态 public final static int CLOSING_STATE = 2; //运行状态 public final static int RUNNING_STATE = 3; //停止状态 public final static int STOPPING_STATE = 4; //设置电梯的状态 public void setState(int state); //电梯的动作 public void open(); public void close(); public void run(); public void stop(); } public class Lift implements ILift { private int state; @Override public void setState(int state) { this.state = state; } //执行关门动作 @Override public void close() { switch (this.state) { case OPENING_STATE: System.out.println(\u0026#34;电梯关门了。。。\u0026#34;);//只有开门状态可以关闭电梯门，可以对应电梯状态表来看 this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了 break; case CLOSING_STATE: //do nothing //已经是关门状态，不能关门 break; case RUNNING_STATE: //do nothing //运行时电梯门是关着的，不能关门 break; case STOPPING_STATE: //do nothing //停止时电梯也是关着的，不能关门 break; } } //执行开门动作 @Override public void open() { switch (this.state) { case OPENING_STATE://门已经开了，不能再开门了 //do nothing break; case CLOSING_STATE://关门状态，门打开: System.out.println(\u0026#34;电梯门打开了。。。\u0026#34;); this.setState(OPENING_STATE); break; case RUNNING_STATE: //do nothing 运行时电梯不能开门 break; case STOPPING_STATE: System.out.println(\u0026#34;电梯门开了。。。\u0026#34;);//电梯停了，可以开门了 this.setState(OPENING_STATE); break; } } //执行运行动作 @Override public void run() { switch (this.state) { case OPENING_STATE://电梯不能开着门就走 //do nothing break; case CLOSING_STATE://门关了，可以运行了 System.out.println(\u0026#34;电梯开始运行了。。。\u0026#34;); this.setState(RUNNING_STATE);//现在是运行状态 break; case RUNNING_STATE: //do nothing 已经是运行状态了 break; case STOPPING_STATE: System.out.println(\u0026#34;电梯开始运行了。。。\u0026#34;); this.setState(RUNNING_STATE); break; } } //执行停止动作 @Override public void stop() { switch (this.state) { case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下) //do nothing break; case CLOSING_STATE://关门时才可以停止 System.out.println(\u0026#34;电梯停止了。。。\u0026#34;); this.setState(STOPPING_STATE); break; case RUNNING_STATE://运行时当然可以停止了 System.out.println(\u0026#34;电梯停止了。。。\u0026#34;); this.setState(STOPPING_STATE); break; case STOPPING_STATE: //do nothing break; } } } public class Client { public static void main(String[] args) { Lift lift = new Lift(); lift.setState(ILift.STOPPING_STATE);//电梯是停止的 lift.open();//开门 lift.close();//关门 lift.run();//运行 lift.stop();//停止 } } 问题分析：\n使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。 扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。\n5.2 结构 # 状态模式包含以下主要角色。\n环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。 5.3 案例实现 # 对上述电梯的案例使用状态模式进行改进。类图如下：\n点击展开 ... //抽象状态类 public abstract class LiftState { //定义一个环境角色，也就是封装状态的变化引起的功能变化 protected Context context; public void setContext(Context context) { this.context = context; } //电梯开门动作 public abstract void open(); //电梯关门动作 public abstract void close(); //电梯运行动作 public abstract void run(); //电梯停止动作 public abstract void stop(); } //开启状态 public class OpenningState extends LiftState { //开启当然可以关闭了，我就想测试一下电梯门开关功能 @Override public void open() { System.out.println(\u0026#34;电梯门开启...\u0026#34;); } @Override public void close() { //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().close(); } //电梯门不能开着就跑，这里什么也不做 @Override public void run() { //do nothing } //开门状态已经是停止的了 @Override public void stop() { //do nothing } } //运行状态 public class RunningState extends LiftState { //运行的时候开电梯门？你疯了！电梯不会给你开的 @Override public void open() { //do nothing } //电梯门关闭？这是肯定了 @Override public void close() {//虽然可以关门，但这个动作不归我执行 //do nothing } //这是在运行状态下要实现的方法 @Override public void run() { System.out.println(\u0026#34;电梯正在运行...\u0026#34;); } //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了 @Override public void stop() { super.context.setLiftState(Context.stoppingState); super.context.stop(); } } //停止状态 public class StoppingState extends LiftState { //停止状态，开门，那是要的！ @Override public void open() { //状态修改 super.context.setLiftState(Context.openningState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().open(); } @Override public void close() {//虽然可以关门，但这个动作不归我执行 //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().close(); } //停止状态再跑起来，正常的很 @Override public void run() { //状态修改 super.context.setLiftState(Context.runningState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().run(); } //停止状态是怎么发生的呢？当然是停止方法执行了 @Override public void stop() { System.out.println(\u0026#34;电梯停止了...\u0026#34;); } } //关闭状态 public class ClosingState extends LiftState { @Override //电梯门关闭，这是关闭状态要实现的动作 public void close() { System.out.println(\u0026#34;电梯门关闭...\u0026#34;); } //电梯门关了再打开，逗你玩呢，那这个允许呀 @Override public void open() { super.context.setLiftState(Context.openningState); super.context.open(); } //电梯门关了就跑，这是再正常不过了 @Override public void run() { super.context.setLiftState(Context.runningState); super.context.run(); } //电梯门关着，我就不按楼层 @Override public void stop() { super.context.setLiftState(Context.stoppingState); super.context.stop(); } } //环境角色 public class Context { //定义出所有的电梯状态 public final static OpenningState openningState = new OpenningState();//开门状态，这时候电梯只能关闭 public final static ClosingState closeingState = new ClosingState();//关闭状态，这时候电梯可以运行、停止和开门 public final static RunningState runningState = new RunningState();//运行状态，这时候电梯只能停止 public final static StoppingState stoppingState = new StoppingState();//停止状态，这时候电梯可以开门、运行 //定义一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() { return this.liftState; } public void setLiftState(LiftState liftState) { //当前环境改变 this.liftState = liftState; //把当前的环境通知到各个实现类中 this.liftState.setContext(this); } public void open() { this.liftState.open(); } public void close() { this.liftState.close(); } public void run() { this.liftState.run(); } public void stop() { this.liftState.stop(); } } //测试类 public class Client { public static void main(String[] args) { Context context = new Context(); context.setLiftState(new ClosingState()); context.open(); context.close(); context.run(); context.stop(); } } 优点：\n将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 缺点：\n状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对\u0026quot;开闭原则\u0026quot;的支持并不太好。 5.4 使用场景 # 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。 6 观察者模式 # 6.1 概述 # 又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。\n6.2 结构 # 在观察者模式中有如下角色：\nSubject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 6.3 案例实现 # 在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。\n类图如下：\n代码如下：\n定义抽象观察者类，里面定义一个更新的方法\n点击展开 ... public interface Observer { void update(String message); } 定义具体观察者类，微信用户是观察者，里面实现了更新的方法\n点击展开 ... public class WeixinUser implements Observer { // 微信用户名 private String name; public WeixinUser(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + \u0026#34;-\u0026#34; + message); } } 定义抽象主题类，提供了attach、detach、notify三个方法\n点击展开 ... public interface Subject { //增加订阅者 public void attach(Observer observer); //删除订阅者 public void detach(Observer observer); //通知订阅者更新消息 public void notify(String message); } 微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法\n点击展开 ... public class SubscriptionSubject implements Subject { //储存订阅公众号的微信用户 private List\u0026lt;Observer\u0026gt; weixinUserlist = new ArrayList\u0026lt;Observer\u0026gt;(); @Override public void attach(Observer observer) { weixinUserlist.add(observer); } @Override public void detach(Observer observer) { weixinUserlist.remove(observer); } @Override public void notify(String message) { for (Observer observer : weixinUserlist) { observer.update(message); } } } 客户端程序\n点击展开 ... public class Client { public static void main(String[] args) { SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject(); //创建微信用户 WeixinUser user1=new WeixinUser(\u0026#34;孙悟空\u0026#34;); WeixinUser user2=new WeixinUser(\u0026#34;猪悟能\u0026#34;); WeixinUser user3=new WeixinUser(\u0026#34;沙悟净\u0026#34;); //订阅公众号 mSubscriptionSubject.attach(user1); mSubscriptionSubject.attach(user2); mSubscriptionSubject.attach(user3); //公众号更新发出消息给订阅的微信用户 mSubscriptionSubject.notify(\u0026#34;传智黑马的专栏更新了\u0026#34;); } } 优点：\n降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】 缺点：\n如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃 6.4 使用场景 # 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。 6.5 JDK中提供的实现 # 在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。\nObservable类\nObservable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。\nvoid addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。\nvoid notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。\nvoid setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。\nObserver 接口\nObserver 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。\n【例】警察抓小偷\n警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：\n小偷是一个被观察者，所以需要继承Observable类\n点击展开 ... public class Thief extends Observable { private String name; public Thief(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void steal() { System.out.println(\u0026#34;小偷：我偷东西了，有没有人来抓我！！！\u0026#34;); super.setChanged(); //changed = true super.notifyObservers(); } } 警察是一个观察者，所以需要让其实现Observer接口\n点击展开 ... public class Policemen implements Observer { private String name; public Policemen(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return name; } @Override public void update(Observable o, Object arg) { System.out.println(\u0026#34;警察：\u0026#34; + ((Thief) o).getName() + \u0026#34;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！\u0026#34;); } } 客户端代码\n点击展开 ... public class Client { public static void main(String[] args) { //创建小偷对象 Thief t = new Thief(\u0026#34;隔壁老王\u0026#34;); //创建警察对象 Policemen p = new Policemen(\u0026#34;小李\u0026#34;); //让警察盯着小偷 t.addObserver(p); //小偷偷东西 t.steal(); } } 7 中介者模式 # 7.1 概述 # 又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。\n一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。\n如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。\n7.2 结构 # 中介者模式包含以下主要角色：\n抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。\n具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。\n抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。\n具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。\n7.3 案例实现 # 租房：现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。\n类图如下：\n点击展开 ... 代码如下：\n//抽象中介者 public abstract class Mediator { //申明一个联络方法 public abstract void constact(String message,Person person); } //抽象同事类 public abstract class Person { protected String name; protected Mediator mediator; public Person(String name,Mediator mediator){ this.name = name; this.mediator = mediator; } } //具体同事类 房屋拥有者 public class HouseOwner extends Person { public HouseOwner(String name, Mediator mediator) { super(name, mediator); } //与中介者联系 public void constact(String message){ mediator.constact(message, this); } //获取信息 public void getMessage(String message){ System.out.println(\u0026#34;房主\u0026#34; + name +\u0026#34;获取到的信息：\u0026#34; + message); } } //具体同事类 承租人 public class Tenant extends Person { public Tenant(String name, Mediator mediator) { super(name, mediator); } //与中介者联系 public void constact(String message){ mediator.constact(message, this); } //获取信息 public void getMessage(String message){ System.out.println(\u0026#34;租房者\u0026#34; + name +\u0026#34;获取到的信息：\u0026#34; + message); } } //中介机构 public class MediatorStructure extends Mediator { //首先中介结构必须知道所有房主和租房者的信息 private HouseOwner houseOwner; private Tenant tenant; public HouseOwner getHouseOwner() { return houseOwner; } public void setHouseOwner(HouseOwner houseOwner) { this.houseOwner = houseOwner; } public Tenant getTenant() { return tenant; } public void setTenant(Tenant tenant) { this.tenant = tenant; } public void constact(String message, Person person) { if (person == houseOwner) { //如果是房主，则租房者获得信息 tenant.getMessage(message); } else { //反正则是房主获得信息 houseOwner.getMessage(message); } } } //测试类 public class Client { public static void main(String[] args) { //一个房主、一个租房者、一个中介机构 MediatorStructure mediator = new MediatorStructure(); //房主和租房者只需要知道中介机构即可 HouseOwner houseOwner = new HouseOwner(\u0026#34;张三\u0026#34;, mediator); Tenant tenant = new Tenant(\u0026#34;李四\u0026#34;, mediator); //中介结构要知道房主和租房者 mediator.setHouseOwner(houseOwner); mediator.setTenant(tenant); tenant.constact(\u0026#34;需要租三室的房子\u0026#34;); houseOwner.constact(\u0026#34;我这有三室的房子，你需要租吗？\u0026#34;); } } 优点：\n松散耦合\n中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。\n集中控制交互\n多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。\n一对多关联转变为一对一的关联\n没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。\n缺点：\n当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。\n7.5 使用场景 # 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。 8 迭代器模式 # 8.1 概述 # 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n8.2 结构 # 迭代器模式主要包含以下角色：\n抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。\n具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。\n抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。\n具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。\n8.3 案例实现 # 定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：\n代码如下：\n定义迭代器接口，声明hasNext、next方法\n点击展开 ... public interface StudentIterator { boolean hasNext(); Student next(); } 定义具体的迭代器类，重写所有的抽象方法\n点击展开 ... public class StudentIteratorImpl implements StudentIterator { private List\u0026lt;Student\u0026gt; list; private int position = 0; public StudentIteratorImpl(List\u0026lt;Student\u0026gt; list) { this.list = list; } @Override public boolean hasNext() { return position \u0026lt; list.size(); } @Override public Student next() { Student currentStudent = list.get(position); position ++; return currentStudent; } } 定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法\n点击展开 ... public interface StudentAggregate { void addStudent(Student student); void removeStudent(Student student); StudentIterator getStudentIterator(); } 定义具体的容器类，重写所有的方法\n点击展开 ... public class StudentAggregateImpl implements StudentAggregate { private List\u0026lt;Student\u0026gt; list = new ArrayList\u0026lt;Student\u0026gt;(); // 学生列表 @Override public void addStudent(Student student) { this.list.add(student); } @Override public void removeStudent(Student student) { this.list.remove(student); } @Override public StudentIterator getStudentIterator() { return new StudentIteratorImpl(list); } } 优点：\n它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。 缺点：\n增加了类的个数，这在一定程度上增加了系统的复杂性。\n8.4 使用场景 # 当需要为聚合对象提供多种遍历方式时。 当需要为遍历不同的聚合结构提供一个统一的接口时。 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。 8.5 JDK源码解析 # 迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。\n点击展开 ... List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); //list.iterator()方法返回的肯定是Iterator接口的子实现类对象 while (iterator.hasNext()) { System.out.println(iterator.next()); } 看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明\nList：抽象聚合类 ArrayList：具体的聚合类 Iterator：抽象迭代器 list.iterator()：返回的是实现了 Iterator 接口的具体迭代器对象 具体的来看看 ArrayList的代码实现\n点击展开 ... public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // 下一个要返回元素的索引 int lastRet = -1; // 上一个返回元素的索引 int expectedModCount = modCount; Itr() {} //判断是否还有元素 public boolean hasNext() { return cursor != size; } //获取下一个元素 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } ... } 这部分代码还是比较简单，大致就是在 iterator 方法中返回了一个实例化的 Iterator 对象。Itr是一个内部类，它实现了 Iterator 接口并重写了其中的抽象方法。\n注意：\n当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现java.util.Iterable并实现其中的iterator()方法使其返回一个 java.util.Iterator 的实现类就可以了。\n9 访问者模式 # 9.1 概述 # 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。\n9.2 结构 # 访问者模式包含以下主要角色:\n抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。 抽象元素（Element）角色：定义了一个接受访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。 9.3 案例实现 # 给宠物喂食：现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。\n访问者角色：给宠物喂食的人 具体访问者角色：主人、其他人 抽象元素角色：动物抽象类 具体元素角色：宠物狗、宠物猫 结构对象角色：主人家 类图如下：\n代码如下：\n创建抽象访问者接口\n点击展开 ... public interface Person { void feed(Cat cat); void feed(Dog dog); } 创建不同的具体访问者角色（主人和其他人），都需要实现 Person接口\n点击展开 ... public class Owner implements Person { @Override public void feed(Cat cat) { System.out.println(\u0026#34;主人喂食猫\u0026#34;); } @Override public void feed(Dog dog) { System.out.println(\u0026#34;主人喂食狗\u0026#34;); } } public class Someone implements Person { @Override public void feed(Cat cat) { System.out.println(\u0026#34;其他人喂食猫\u0026#34;); } @Override public void feed(Dog dog) { System.out.println(\u0026#34;其他人喂食狗\u0026#34;); } } 定义抽象节点 \u0026ndash; 宠物\n点击展开 ... public interface Animal { void accept(Person person); } 定义实现Animal接口的 具体节点（元素）\n点击展开 ... public class Dog implements Animal { @Override public void accept(Person person) { person.feed(this); System.out.println(\u0026#34;好好吃，汪汪汪！！！\u0026#34;); } } public class Cat implements Animal { @Override public void accept(Person person) { person.feed(this); System.out.println(\u0026#34;好好吃，喵喵喵！！！\u0026#34;); } } 定义对象结构，此案例中就是主人的家\n点击展开 ... public class Home { private List\u0026lt;Animal\u0026gt; nodeList = new ArrayList\u0026lt;Animal\u0026gt;(); public void action(Person person) { for (Animal node : nodeList) { node.accept(person); } } //添加操作 public void add(Animal animal) { nodeList.add(animal); } } 测试类\n点击展开 ... public class Client { public static void main(String[] args) { Home home = new Home(); home.add(new Dog()); home.add(new Cat()); Owner owner = new Owner(); home.action(owner); Someone someone = new Someone(); home.action(someone); } } 优点：\n扩展性好\n在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\n复用性好\n通过访问者来定义整个对象结构通用的功能，从而提高复用程度。\n分离无关行为\n通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。\n缺点：\n对象结构变化很困难\n在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。\n违反了依赖倒置原则\n访问者模式依赖了具体类，而没有依赖抽象类。\n9.4 使用场景 # 对象结构相对稳定，但其操作算法经常变化的程序。\n对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。\n9.5 扩展 # 访问者模式用到了一种双分派的技术。\n9.5.1 分派 # 变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 Map map = new HashMap() ，map变量的静态类型是 Map ，实际类型是 HashMap 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。\n静态分派(Static Dispatch) 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。\n动态分派(Dynamic Dispatch) 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。\n9.5.2 分派动态分派 # 通过方法的重写支持动态分派。\n点击展开 ... public class Animal { public void execute() { System.out.println(\u0026#34;Animal\u0026#34;); } } public class Dog extends Animal { @Override public void execute() { System.out.println(\u0026#34;dog\u0026#34;); } } public class Cat extends Animal { @Override public void execute() { System.out.println(\u0026#34;cat\u0026#34;); } } public class Client { public static void main(String[] args) { Animal a = new Dog(); a.execute(); Animal a1 = new Cat(); a1.execute(); } } 上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。\nJava编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。\n9.5.3 静态分派： # 通过方法重载支持静态分派。\n点击展开 ... public class Animal { } public class Dog extends Animal { } public class Cat extends Animal { } public class Execute { public void execute(Animal a) { System.out.println(\u0026#34;Animal\u0026#34;); } public void execute(Dog d) { System.out.println(\u0026#34;dog\u0026#34;); } public void execute(Cat c) { System.out.println(\u0026#34;cat\u0026#34;); } } public class Client { public static void main(String[] args) { Animal a = new Animal(); Animal a1 = new Dog(); Animal a2 = new Cat(); Execute exe = new Execute(); exe.execute(a); exe.execute(a1); exe.execute(a2); } } 运行结果：\n这个结果可能出乎一些人的意料了，为什么呢？\n重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。\n9.5.4 双分派 # 所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。\n点击展开 ... public class Animal { public void accept(Execute exe) { exe.execute(this); } } public class Dog extends Animal { public void accept(Execute exe) { exe.execute(this); } } public class Cat extends Animal { public void accept(Execute exe) { exe.execute(this); } } public class Execute { public void execute(Animal a) { System.out.println(\u0026#34;animal\u0026#34;); } public void execute(Dog d) { System.out.println(\u0026#34;dog\u0026#34;); } public void execute(Cat c) { System.out.println(\u0026#34;cat\u0026#34;); } } public class Client { public static void main(String[] args) { Animal a = new Animal(); Animal d = new Dog(); Animal c = new Cat(); Execute exe = new Execute(); a.accept(exe); d.accept(exe); c.accept(exe); } } 在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也将自己this作为参数传递进去，这里就完成了第二次分派，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。\n说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。\n运行结果如下：\n双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。\n10 备忘录模式 # 10.1 概述 # 备忘录模式又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。\n备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。\n10.2 结构 # 备忘录模式的主要角色如下：\n发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 备忘录有两个等效的接口：\n窄接口：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。 宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。 10.3 案例实现 # 游戏挑战BOSS：游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。\n要实现上述案例，有两种方式：\n“白箱”备忘录模式 “黑箱”备忘录模式 10.3.1 “白箱”备忘录模式 # 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：\n代码如下：\n点击展开 ... //游戏角色类 public class GameRole { private int vit; //生命力 private int atk; //攻击力 private int def; //防御力 //初始化状态 public void initState() { this.vit = 100; this.atk = 100; this.def = 100; } //战斗 public void fight() { this.vit = 0; this.atk = 0; this.def = 0; } //保存角色状态 public RoleStateMemento saveState() { return new RoleStateMemento(vit, atk, def); } //回复角色状态 public void recoverState(RoleStateMemento roleStateMemento) { this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); } public void stateDisplay() { System.out.println(\u0026#34;角色生命力：\u0026#34; + vit); System.out.println(\u0026#34;角色攻击力：\u0026#34; + atk); System.out.println(\u0026#34;角色防御力：\u0026#34; + def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } //游戏状态存储类(备忘录类) public class RoleStateMemento { private int vit; private int atk; private int def; public RoleStateMemento(int vit, int atk, int def) { this.vit = vit; this.atk = atk; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } //角色状态管理者类 public class RoleStateCaretaker { private RoleStateMemento roleStateMemento; public RoleStateMemento getRoleStateMemento() { return roleStateMemento; } public void setRoleStateMemento(RoleStateMemento roleStateMemento) { this.roleStateMemento = roleStateMemento; } } //测试类 public class Client { public static void main(String[] args) { System.out.println(\u0026#34;------------大战Boss前------------\u0026#34;); //大战Boss前 GameRole gameRole = new GameRole(); gameRole.initState(); gameRole.stateDisplay(); //保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setRoleStateMemento(gameRole.saveState()); System.out.println(\u0026#34;------------大战Boss后------------\u0026#34;); //大战Boss时，损耗严重 gameRole.fight(); gameRole.stateDisplay(); System.out.println(\u0026#34;------------恢复之前状态------------\u0026#34;); //恢复之前状态 gameRole.recoverState(roleStateCaretaker.getRoleStateMemento()); gameRole.stateDisplay(); } } 分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。\n10.3.2 “黑箱”备忘录模式 # 备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类。\n将 RoleStateMemento 设为 GameRole 的内部类，从而将 RoleStateMemento 对象封装在 GameRole 里面；在外面提供一个标识接口 Memento 给 RoleStateCaretaker 及其他对象使用。这样 GameRole 类看到的是 RoleStateMemento 所有的接口，而RoleStateCaretaker 及其他对象看到的仅仅是标识接口 Memento 所暴露出来的接口，从而维护了封装型。类图如下：\n代码如下：\n窄接口Memento，这是一个标识接口，因此没有定义出任何的方法\n点击展开 ... public interface Memento { } 定义发起人类 GameRole，并在内部定义备忘录内部类 RoleStateMemento（该内部类设置为私有的）\n点击展开 ... /游戏角色类 public class GameRole { private int vit; //生命力 private int atk; //攻击力 private int def; //防御力 //初始化状态 public void initState() { this.vit = 100; this.atk = 100; this.def = 100; } //战斗 public void fight() { this.vit = 0; this.atk = 0; this.def = 0; } //保存角色状态 public Memento saveState() { return new RoleStateMemento(vit, atk, def); } //回复角色状态 public void recoverState(Memento memento) { RoleStateMemento roleStateMemento = (RoleStateMemento) memento; this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); } public void stateDisplay() { System.out.println(\u0026#34;角色生命力：\u0026#34; + vit); System.out.println(\u0026#34;角色攻击力：\u0026#34; + atk); System.out.println(\u0026#34;角色防御力：\u0026#34; + def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } private class RoleStateMemento implements Memento { private int vit; private int atk; private int def; public RoleStateMemento(int vit, int atk, int def) { this.vit = vit; this.atk = atk; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } } 负责人角色类 RoleStateCaretaker 能够得到的备忘录对象是以 Memento 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容\n点击展开 ... //角色状态管理者类 public class RoleStateCaretaker { private Memento memento; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } 客户端测试类\n点击展开 ... public class Client { public static void main(String[] args) { System.out.println(\u0026#34;------------大战Boss前------------\u0026#34;); //大战Boss前 GameRole gameRole = new GameRole(); gameRole.initState(); gameRole.stateDisplay(); //保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setMemento(gameRole.saveState()); System.out.println(\u0026#34;------------大战Boss后------------\u0026#34;); //大战Boss时，损耗严重 gameRole.fight(); gameRole.stateDisplay(); System.out.println(\u0026#34;------------恢复之前状态------------\u0026#34;); //恢复之前状态 gameRole.recoverState(roleStateCaretaker.getMemento()); gameRole.stateDisplay(); } } 优点：\n提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 缺点：\n资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 10.4 使用场景 # 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。\n需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。\n11 解释器模式 # 11.1 概述 # 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。\n点击展开 ... //用于两个整数相加 public static int add(int a,int b){ return a + b; } //用于两个整数相加 public static int add(int a,int b,int c){ return a + b + c; } //用于n个整数相加 public static int add(Integer ... arr) { int sum = 0; for (Integer i : arr) { sum += i; } return sum; } 上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。\n显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。\n在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。\n解释器就是要解析出来语句的含义。但是如何描述规则呢？\n文法（语法）规则：\n文法是用于描述语言的语法结构的形式规则。\nexpression ::= value | plus | minus plus ::= expression ‘+’ expression minus ::= expression ‘-’ expression value ::= integer 注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。\n上面规则描述为 ：\n表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。\n抽象语法树：\n在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。\n用树形来表示符合文法规则的句子。\n11.2 结构 # 解释器模式包含以下主要角色。\n抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。\n终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。\n非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。\n环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。\n客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。\n11.3 案例实现 # 设计实现加减法的软件\n代码如下：\n点击展开 ... //抽象角色AbstractExpression public abstract class AbstractExpression { public abstract int interpret(Context context); } //终结符表达式角色 public class Value extends AbstractExpression { private int value; public Value(int value) { this.value = value; } @Override public int interpret(Context context) { return value; } @Override public String toString() { return new Integer(value).toString(); } } //非终结符表达式角色 加法表达式 public class Plus extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public Plus(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret(Context context) { return left.interpret(context) + right.interpret(context); } @Override public String toString() { return \u0026#34;(\u0026#34; + left.toString() + \u0026#34; + \u0026#34; + right.toString() + \u0026#34;)\u0026#34;; } } ///非终结符表达式角色 减法表达式 public class Minus extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public Minus(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret(Context context) { return left.interpret(context) - right.interpret(context); } @Override public String toString() { return \u0026#34;(\u0026#34; + left.toString() + \u0026#34; - \u0026#34; + right.toString() + \u0026#34;)\u0026#34;; } } //终结符表达式角色 变量表达式 public class Variable extends AbstractExpression { private String name; public Variable(String name) { this.name = name; } @Override public int interpret(Context ctx) { return ctx.getValue(this); } @Override public String toString() { return name; } } //环境类 public class Context { private Map\u0026lt;Variable, Integer\u0026gt; map = new HashMap\u0026lt;Variable, Integer\u0026gt;(); public void assign(Variable var, Integer value) { map.put(var, value); } public int getValue(Variable var) { Integer value = map.get(var); return value; } } //测试类 public class Client { public static void main(String[] args) { Context context = new Context(); Variable a = new Variable(\u0026#34;a\u0026#34;); Variable b = new Variable(\u0026#34;b\u0026#34;); Variable c = new Variable(\u0026#34;c\u0026#34;); Variable d = new Variable(\u0026#34;d\u0026#34;); Variable e = new Variable(\u0026#34;e\u0026#34;); //Value v = new Value(1); context.assign(a, 1); context.assign(b, 2); context.assign(c, 3); context.assign(d, 4); context.assign(e, 5); AbstractExpression expression = new Minus(new Plus(new Plus(new Plus(a, b), c), d), e); System.out.println(expression + \u0026#34;= \u0026#34; + expression.interpret(context)); } } 优点：\n易于改变和扩展文法。\n由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。\n实现文法较为容易。\n在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。\n增加新的解释表达式较为方便。\n如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 \u0026ldquo;开闭原则\u0026rdquo;。\n缺点：\n对于复杂文法难以维护。\n在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。\n执行效率较低。\n由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。\n11.4 使用场景 # 当语言的文法较为简单，且执行效率不是关键问题时。\n当问题重复出现，且可以用一种简单的语言来进行表达时。\n当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。\n"},{"id":29,"href":"/notes/mybatisplus/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/","title":"条件查询","section":"MyBatisPlus","content":" 1 比较符号 # 符号 意义 ge 大于 gt 大于等于 le 小于 eq 等于 nq 不等于 le 小于 @Test public void testSelect() { QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.ge(\u0026#34;age\u0026#34;, 28); List\u0026lt;User\u0026gt; users = userMapper.selectList(queryWrapper); System.out.println(users); } @Test public void testSelectOne() { QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // seletOne返回的是一条实体记录，当出现多条时会报错 User user = userMapper.selectOne(queryWrapper); System.out.println(user); } 2 模糊查询 # 符号 意义 like %xx% likeLeft %xx rightLeft xx% selectMaps返回Map集合列表\n@Test public void testSelectMaps() { QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper .like(\u0026#34;name\u0026#34;, \u0026#34;e\u0026#34;) .likeRight(\u0026#34;email\u0026#34;, \u0026#34;t\u0026#34;); List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; maps = userMapper.selectMaps(queryWrapper);//返回值是Map列表 maps.forEach(System.out::println); } 3 升降序 # 符号 意义 orderByAsc 升序 orderByDesc 降序 @Test public void testSelectListOrderBy() { QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.orderByDesc(\u0026#34;id\u0026#34;); List\u0026lt;User\u0026gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); } "},{"id":30,"href":"/notes/jvm/%E6%96%B9%E6%B3%95%E5%8C%BA/","title":"方法区","section":"JVM","content":" 方法区 # 方法区是所有 Java 虚拟机线程共享的区域，它存储和类结构相关的信息，如成员变量、方法数据、成员方法和构造器方法的代码部分，以及类的构造器和运行时常量池等。方法区在虚拟机启动时被创建，如果内存不足，方法区也会跑出 OutOfMemoryError。\nJVM 1.8前后方法区的区别 # JVM 1.8 之前 和 JVM 1.8 的方法区实现不一样，JVM 1.8 之前是 PermGem（永久代），1.8 是 Metaspace（元空间），如下图：\n永久代内存溢出报错：java.lang.OutOfMemoryError: PermGen space\n永久代最大空间设置参数：-XX:MaxPermSize=8m\n元空间内存溢出报错：java.lang.OutOfMemoryError: Metaspace\n元空间最大空间设置参数：-XX:MaxMetaspaceSize=8m\n运行时常量池 # **常量池：**就是一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等信息。\n**运行时常量池：**常量池是在 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。\n关于运行时常量池必知必会： # 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池并返回 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则将此对象复制一份放入串池并返回 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder（1.8） 和编译期优化 String s1 = \u0026#34;a\u0026#34;; String s2 = \u0026#34;b\u0026#34;; String s3 = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34;; String s4 = s1 + s2; String s5 = \u0026#34;ab\u0026#34;; String s6 = s4.intern(); System.out.println(s3 == s4); System.out.println(s3 == s5); System.out.println(s3 == s6); String x2 = new String(\u0026#34;c\u0026#34;) + new String(\u0026#34;d\u0026#34;); String x1 = \u0026#34;cd\u0026#34;; x2.intern(); // 交换 x2.intern() 和 String x1 = \u0026#34;cd\u0026#34; 位置后 // java 1.6 和 java 1.8 分别又是什么结果？ System.out.println(x1 == x2); // 结果： false true true false // 位置互换后结果 String x2 = new String(\u0026#34;c\u0026#34;) + new String(\u0026#34;d\u0026#34;); x2.intern(); String x1 = \u0026#34;cd\u0026#34;; java 1.6: false java 1.8: true StringTable 位置 # 如下图，1.6 及 1.6 之前，StringTable 在常量池中，1.6 之后，StringTable 放在 Heap 中。\n**\n为什么 1.6 之后将 StringTable 放入 Heap 中？ # 因为永久代内存不足，而且永久代只有触发 FullGC 时候才会执行他的垃圾回收，但是 FullGC 只有等到整个老年代的空间不足才会触发，回收时间会很晚，间接的导致stringtable的回收效率并不高，所以 1.6 之后的 JVM 厂商对此作了优化，将其已到 Heap 中，只要触发 **GC 就会进行垃圾回收。StringTable 也会垃圾回收的。\nStringTable 调优 # 通过调整桶个数来优化 StringTable 效率\nStringTable 底层是以哈希表的方式存储数据的，所以通过调整桶个数，来减少每个桶上的链表长度，就可以优化其效率。\n-Xmx10m 设置堆内存空间 -XX:+PrintStringTableStatistics 打印字符串表的统计信息，可以看到串池中字符串实例的个数，包括占用大小信息 -XX:+PrintGCDetails -verbose:gc 打印垃圾回收的详细信息，如次数、时间 -XX:StringTableSize=1009 调整 StringTable 桶个数 考虑将字符串对象入池\n如果字符串对象量大且有较多重复的字符串对象，可以考虑将其入池，那样能节省不少空间。\n"},{"id":31,"href":"/notes/redis/redis-hash/","title":"Redis Hash","section":"Redis","content":" Hash 哈希 # 常用命令 # hset \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt;：给 集合中的 赋值\nhget \u0026lt;key1\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt;：从 key1 中取出 value\nhmet \u0026lt;key1\u0026gt; \u0026lt;field1\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;field2\u0026gt; \u0026lt;value2\u0026gt;：批量设置 hash 的值\nhexists \u0026lt;key1\u0026gt; \u0026lt;field\u0026gt;：判断 key1 中是否有 field 存在\nhkeys \u0026lt;key\u0026gt;：列出 hash 集合中的所有 field\nhvals \u0026lt;key\u0026gt;：列出 hash 集合中的所有 value\nhincrby \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;increment\u0026gt;：为 field 上的值加上 increment\nhsetnx \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt;：同 hset，前提 field 不存在才能成功\n数据结构 # Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。\n"},{"id":32,"href":"/notes/mybatisplus/%E5%B0%81%E8%A3%85service%E4%BD%BF%E7%94%A8/","title":"封装service使用","section":"MyBatisPlus","content":" 1 创建service # public interface UserService extends IService\u0026lt;User\u0026gt; { } 2 创建service实现类 # @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements UserService { } 3 底层封装了注入Mapper过程 # 4 方法调用测试 # @SpringBootTest class TestApplicationTests { //注入service @Autowired private UserService userService; //查询表所有数据 @Test public void findAll() { List\u0026lt;User\u0026gt; userList = userService.list(); for (User user:userList) { System.out.println(user); } } } "},{"id":33,"href":"/notes/jvm/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/","title":"直接内存","section":"JVM","content":" 直接内存 # 不属于 Java 虚拟机内存，是操作系统内存。\n常见于 NIO 操作时， 用于缓冲内存 分配回收成本比较高，但读写性能高 不受 JVM 内存回收管理 直接内存既然不受 JVM 虚拟机管理和垃圾回收，那么它会不会被正确回收？底层又是如何实现的？ # 直接内存是通过主动调用 Unsafe 的 freeMenory 方法来释放内存的。\n分配和回收原理 # 使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用它的 freeMemory 方法 ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接內存 JVM 调优相关问题 # JVM 调优时一般会增加参数 -XX: +DisableExplicitGC 来禁用显式的垃圾回收，即 System.gc() ，但这主动调用触发的是 Full GC ，比较影响性能，因为不仅回收新生代，也会回收老年代，会使程序暂停时间比较长。所以为了防止一些程序员不小心在程序中写的 System.gc()，所以就加上 -XX: +DisableExplicitGC 。但这就会影响直接内存了，如果加上 -XX: +DisableExplicitGC 的话，直接内存就只有等到真正的垃圾回收的时候才会被清理，这就造成直接内存占用较大，长时间得不到释放。\n解决方案：\n直接内存的回收可以不用 Java 的垃圾回收，可以用 Unsafe 的 freeMenory 方法来释放内存。示例如下：\npublic class Main { static int _1Gb = 1024 * 1024 * 1024; public static void main(String[] args) throws IOException { Unsafe unsafe = Unsafe.getUnsafe(); //分配内存 long base = unsafe.allocateMemory(_1Gb); unsafe.setMemory(base, _1Gb, (byte) 0); System.in.read(); //释放内存 unsafe.freeMemory(base); System.in.read(); } } "},{"id":34,"href":"/notes/redis/redis-zset/","title":"Redis Zset","section":"Redis","content":" Redis Zset 有序集合（sorted set） # 常用命令 # zadd \u0026lt;key\u0026gt; \u0026lt;score1\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;score2\u0026gt; \u0026lt;value2\u0026gt;： 将一个或者多个 value 和 score 加入到 key 中\nzrange \u0026lt;key\u0026gt; \u0026lt;start\u0026gt; \u0026lt;stop\u0026gt; [withscores]：返回下标在 和 之间的元素，加 withscores 则返回 score\nzrangebyscore \u0026lt;key\u0026gt; \u0026lt;min\u0026gt; \u0026lt;max\u0026gt; [withscores] [limit offset count]：返回 score 在 和 之间的\nzrevrangebyscore \u0026lt;key\u0026gt; \u0026lt;max\u0026gt; \u0026lt;min\u0026gt; [withscores] [limit offset count]：逆序返回 score 在 和 之间的\nzincrby \u0026lt;key\u0026gt; \u0026lt;increment\u0026gt; \u0026lt;value\u0026gt;：为元素的 score 加上 增量\nzrem \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;：删除该集合下指定值的元素\nzcount \u0026lt;key\u0026gt; \u0026lt;min\u0026gt; \u0026lt;max\u0026gt;：统计该集合分数区间内的元素个数\nzrank \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;：返回该值在集合中的排名，从 0 开始\n数据结构 # SortedSet (zset) 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map(String， Double)，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。\nzset 底层使用了两个数据结构\nhash： hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯 —性，可以通过元素 value 找到相应的 score值。\n跳跃表：跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。\n"},{"id":35,"href":"/notes/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","title":"垃圾回收","section":"JVM","content":" 垃圾回收 # 如何判断对象可以回收？ # 引用计数法 # 给对象添加一个引用计数器，每当有一个地方引用它，计数器值就加一；相反的，当引用失效的时候，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 弊端： 循环引用，如下图，哪怕两个对象都没有被引用，也不会被回收，引用计数器不为0.\n可达性分析算法 # Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。 扫描堆中的对象，看是否能够沿着 GC Root 为起点的引用链找到该对象，找不到则表示可以回收。\nJava语言中，可以作为GC Roots的对象包括以下几种\n虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。 四种引用 # 强引用\n只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收\n软引用\n发生垃圾回收后又发现内存不够，这时候就会去回收仅有软引用的对象。（软引用自身也是一种引用对象，如果在创建软引用时给分配了一个引用队列，一旦其引用的对象都被回收时，软引用对象自身就会进入引用队列。）\n弱引用\n只要发生垃圾回收 (Full GC) ，不管内存够不够，都会去回收仅有弱引用的对象。（弱引用同上，软硬引用的回收可以通过引用队列来遍历然后回收）\n虚引用\n必须配合引用队列使用（软硬引用不是必须），主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存\n终结器引用\n必须配合引用队列使用（软硬引用不是必须）。无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。\n垃圾回收算法 # 标记清除 # 优点：速度快\n缺点：容易产生较多的内存碎片\n标记整理 # 缺点：效率较低\n优点：避免了内存碎片\n复制 # 缺点：占用双倍内存空间\n优点：不会产生内存碎片\n分代回收 # 对象首先分配在伊甸园区域 新生代不足时会触发 minor gc，伊甸园和from中存活的对象会使用 copy 复制到幸存区 to 中，存活对象年龄 +1 ，并交换 from 和 to minor gc 会引发 stop the world，并暂停其他用户线程，等待垃圾回收结束后，其他线程才会运行（因为 gc 会涉及到很多对象地址的变更，不暂停线程的话，容易引起程序崩溃） 当寿命超过阈值时，会晋升到老年代，最大寿命为 15 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍然不足，那么出发 full fc，这时 STW 时间更长 相关参数 # 含义 参数 堆初始大小 -Xms 堆最大大小 -Xmx 或 -XX:MaxHeapSize=size 新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 幸存区比例(动态) -XX:InitialSurvivorRatio=ratio 和-XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC "},{"id":36,"href":"/notes/redis/redis-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/","title":"Redis 发布与订阅","section":"Redis","content":" 发布与订阅 # 发布订阅命令行实现 # 打开两个终端，一个作为发布者，一个作为订阅者\n订阅者终端订阅 # 订阅者终端订阅 subscribe channel1 发布者客户端给 channel1 发布消息 # 给 channel1 发布消息，其中返回的 1 是订阅者数量 publish channel1 hello 订阅方收到消息 "},{"id":37,"href":"/notes/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","title":"垃圾回收器","section":"JVM","content":" 1. 串行垃圾回收器 # 单线程的垃圾回收器\n堆内存较小，适合个人电脑\n参数设置 # -XX:+UserSerialGC = Serial + SerialOld ：打开串行垃圾回收器\nSerial : 工作在新生代，才用的是复制算法 SerialOld : 工作在老年代，采用的是标记+整理算法 2. 吞吐量优先 # 多线程垃圾回收器 堆内存较大，多核 cpu\n尽可能让单位时间内，STW 的时间最短\n参数设置 # -XX:+UseParallelGC：1.8 默认开启，新生代垃圾回收器，复制算法\n-XX:+UseParallelOldGC：1.8 默认开启，老年代，标记+整理，两个开任意一个，另一个也会自动开启\n-XX:+UseAdaptiveSizePolicy ：采用自适应调整大小\n-XX:GCTimeRatio=ratio ：采用自适应调整大小时的参数，公式为1/(1+ratio)\n-XX:MaxGCPauseMillis=ms ：采用自适应调整大小时的参数，默认值 200 ms\n-XX:ParallelGCThreads=n ：控制线程数 n\n3. 响应时间优先 # 多线程垃圾回收器\n堆内存较大，多核 CPU\n尽可能让单次 STW 的时间最短\n参数设置 # -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld\n-XX:+UseConcMarkSweepGC ：基于标记清除的，并发，即用户线程和垃圾回收线程是并发执行，工作在老年代，并发失败时会退化成 SeriaOld\n-XX:+UseParNewGC ：工作在新生代，基于复制算法的垃圾回收器，与-XX:+UseConcMarkSweepGC 是一对\n-XX:ParallelGCThreads=n：并行线程数，一般与 CPU 核数相同\n-XX:ConcGCThreads=threads ：并发线程数，一般设置为并行线程数的 1/4\n-XX:CMSInitiatingOccupancyFraction=percent ：为了预留空间给浮动垃圾，当老年代垃圾达到指定百分比的时候就执行垃圾回收，默认值 65\n-XX:+CMSScavengeBeforeRemark ：在重新标记前，对新生代做一次垃圾回收\n"},{"id":38,"href":"/notes/redis/redis-jedis/","title":"Redis Jedis","section":"Redis","content":" Redis Jedis # 连接测试 # 连接前需要去配置文件中修改两个参数，并需要确定 Redis 所在主机防火墙是否关闭。如果直接本机连接，则无需修改这些参数。\n配置文件修改 # mac 中配置文件地址 （brew 安装）：\nvi /opt/homebrew/etc/redis.conf 注释该条命令，否则绑定本机，只有本机能够连接：\n# 原始 bind 127.0.0.1 # 修改后 # bind 127.0.0.1 将 protected-mode 参数值设置为 no\n# 原始 protected-mode yes # 修改后 protected-mode no 检查防火墙是否关闭 # 检查防火墙状态 systemctl status firewalld 关闭防火墙 systemctl stop firewalld 代码测试连接 # public void testConnect() { Jedis jedis = new Jedis(\u0026#34;127.0.0.1\u0026#34;, 6379); String value = jedis.ping(); // 测试连接是否成功 System.out.println( value ); } 模拟验证码发送 # 需求： # 输入手机号，发送随机生成的 6 位数字码，2 分钟有效。 输入验证码，点击验证，返回成功或失败。 每个手机号每天只能输入三次。 public class VerifyCode { public static void main(String[] args) { verifyCode(\u0026#34;17729989359\u0026#34;); checkCode(\u0026#34;17729989359\u0026#34;, \u0026#34;872775\u0026#34;); } // 输入验证码，点击验证，返回成功或失败 public static void checkCode(String phone, String code) { // 连接 redis Jedis jedis = new Jedis(\u0026#34;127.0.0.1\u0026#34;, 6379); String codeKey = \u0026#34;VerifyCode\u0026#34; + phone + \u0026#34;:code\u0026#34;; String redisCode = jedis.get(codeKey); System.out.println(redisCode); // 判断 if (code.equals(redisCode)) { System.out.println(\u0026#34;成功！\u0026#34;); } else { System.out.println(\u0026#34;失败！\u0026#34;); } jedis.close(); } // 每个手机号每天只能输入三次 public static void verifyCode(String phone) { // 连接 redis Jedis jedis = new Jedis(\u0026#34;127.0.0.1\u0026#34;, 6379); // 拼接key // 手机发送次数 Key String countKey = \u0026#34;VerifyCode\u0026#34; + phone + \u0026#34;:count\u0026#34;; // 验证码 Key String codeKey = \u0026#34;VerifyCode\u0026#34; + phone + \u0026#34;:code\u0026#34;; // 每个手机号每天只能发送三次 String count = jedis.get(countKey); if (count == null) { // 说明第一次申请验证码，次数一天有效 jedis.setex(countKey, 24*60*60, \u0026#34;1\u0026#34;); } else if (Integer.parseInt(count) \u0026lt;= 2) { // 说明小于两次 jedis.incr(countKey); } else { System.out.println(\u0026#34;发送次数已经超过三次！\u0026#34;); jedis.close(); return; } // 获取验证码 String code = getCode(); jedis.setex(codeKey, 120, code); } // 输入手机号，发送随机生成的 6 位数字码，2 分钟有效。 public static String getCode() { String code = \u0026#34;\u0026#34;; Random random = new Random(); for (int i = 0; i \u0026lt; 6; i++) { int n = random.nextInt(10); code += n; } return code; } } "},{"id":39,"href":"/notes/redis/springboot-%E6%95%B4%E5%90%88-redis/","title":"Spring Boot 整合 Redis","section":"Redis","content":" SpringBoot 整合 Redis # 在 SpringBoot2.x 之后，原来使用的 jedis 被替换成了 lettuce。\njedis 和 leetuce 的区别\njedis：采用的直连，多个线程操作的话是不安全的，如果想要避免不安全，那就使用 jedis pool 连接池，这更像 BIO lettuce：采用 netty， 实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像 Nio 模式 创建 SpringBoot 项目 # New Project # 配置 Redis 连接相关信息 # 在 application.yml 中配置 Redis 相关的连接信息，具体如下：\nspring: redis: host: 127.0.0.1 port: 6379 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间 检查 Maven 依赖 # 当 redis 进行 Jackson 序列化时需要 Jackson 依赖。连接池的具体作用谷歌如下：\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。 这项技术能明显提高对数据库操作的性能。\n\u0026lt;!--redis依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--common-pool--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Jackson依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 连接测试 # @SpringBootTest class DemoApplicationTests { @Autowired RedisTemplate redisTemplate; @Test void testRedis() { redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;); System.out.println(redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;)); } } 测试结果如下：\n从 IDE 结果来看没有任何问题的，但要是去终端看的话，会有些问题：\n问题：如上乱码，key 明明为 name，但是在内部却成了 \\xac\\xed\\x00\\x05t\\x00\\x04name? # 主要原因是 SpringDataRedis 可以接受任何类型的变量，无论 name 和 value 传的是什么都会将其转为为 Object，然后将其转为 Redis 可以处理的字节。所以穿进去的 name 和 value 都被当成 Java 对象了，然后 Redis 利用 JDK 序列化工具对其进行处理。\n查看 RedisTemplate 源码可以发现，以下默认都为 null：\n@Nullable private RedisSerializer keySerializer = null; @Nullable private RedisSerializer valueSerializer = null; @Nullable private RedisSerializer hashKeySerializer = null; @Nullable private RedisSerializer hashValueSerializer = null; 当这些类型的序列化都为空时，默认会使用 JDK 的序列化工具 JdkSerializationRedisSerializer ，源码如下：\nExpand ... public void afterPropertiesSet() { super.afterPropertiesSet(); boolean defaultUsed = false; // 设置 defaultSerializer 为 JdkSerializationRedisSerializer if (this.defaultSerializer == null) { this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader()); } // 将所有 null 的序列化都 设置为 defaultSerializer if (this.enableDefaultSerializer) { if (this.keySerializer == null) { this.keySerializer = this.defaultSerializer; defaultUsed = true; } if (this.valueSerializer == null) { this.valueSerializer = this.defaultSerializer; defaultUsed = true; } if (this.hashKeySerializer == null) { this.hashKeySerializer = this.defaultSerializer; defaultUsed = true; } if (this.hashValueSerializer == null) { this.hashValueSerializer = this.defaultSerializer; defaultUsed = true; } } if (this.enableDefaultSerializer \u0026amp;\u0026amp; defaultUsed) { Assert.notNull(this.defaultSerializer, \u0026#34;default serializer null and not all serializers initialized\u0026#34;); } if (this.scriptExecutor == null) { this.scriptExecutor = new DefaultScriptExecutor(this); } this.initialized = true; } 所以得出一个结论：之所以乱码是因为 SpringDataRedis 将一切都当成 Object 对象，然后默认利用 JDK 的序列化工具将其序列化就导致乱码问题，所以解决乱码问题就是要解决序列化问题。\n序列化方案 # 方案一 # 将 key 用 string 序列化 将 value 用 json 序列化 具体代码如下：\nExpand ... package com.example.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializer; @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory){ // 创建RedisTemplate对象 RedisTemplate\u0026lt;String, Object\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; } } 然后还需修改一下注入类型，这时 value 也可以是 pojo 对象，能够实现自动序列化和反序列化：\n@Autowired RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; 测试结果：\n可以看到多了一串 \u0026quot;@class\\\u0026quot;:\\\u0026quot;com.example.pojo.User\\\u0026quot; 这主要是用来反序列化的。但若是每条存入的数据都会多一条这个内容，这样会浪费存储空间，所以产生方案二。\n方案二 # Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了自定义RedisTemplate的过程：\n@Autowired StringRedisTemplate stringRedisTemplate; private static final ObjectMapper mapper = new ObjectMapper(); @Test void testStringUser() throws JsonProcessingException { User user = new User(\u0026#34;Bob\u0026#34;, 21); // 序列化 String json = mapper.writeValueAsString(user); // 存值 stringRedisTemplate.opsForValue().set(\u0026#34;user1\u0026#34;, json); // 取值 String user_json = stringRedisTemplate.opsForValue().get(\u0026#34;user1\u0026#34;); // 反序列化 User user1 = mapper.readValue(user_json, User.class); System.out.println(user1); } 注意 json 工具的使用：\n// 实例化 private static final ObjectMapper mapper = new ObjectMapper(); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化 User user1 = mapper.readValue(user_json, User.class); 总结 # RedisTemplate 的两种序列化实践方案：\n方案一：\n自定义 RedisTemplate 修改 value 的序列化器为 GenericJackson2JsonRedisSerializer 修改 key 的序列化器为 RedisSerializer.string() 方案二：\n使用 StringRedisTemplate 写入 Redis 时，手动把对象序列化为 JSON 读取 Redis 时，手动把读取到的 JSON 反序列化为对象 "},{"id":40,"href":"/notes/redis/redis-%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/","title":"Redis 事务和锁机制","section":"Redis","content":" Redis 事务和锁机制 # Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\nRedis事务的主要作用就是串联多个命令防止别的命令插队。\nmulti、exec、discard # 从输入 multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 exec 后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过 discard 来放弃组队。\n案例 # 组队成功，提交成功\n组队阶段报错，提交失败\n组队成功，提交有成功有失败情况\n事务的错误处理 # 组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。\n如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。\n"},{"id":41,"href":"/daily/ad/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%88%812022%E5%B9%B4%E7%9A%84%E7%94%9F%E6%97%A5%E7%9A%84%E5%B0%8F%E8%AE%BA%E6%96%87/","title":"关于阿刁2022年的生日的小论文","section":"我和阿刁","content":" 关于阿刁2022年的生日的小论文 # 其他话先不说吧，祝阿刁生日快乐，阿刁又漂亮了一岁！\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE --- 千言万语，也不如陪阿刁身边真真切切的过个生日！但该有的仪式感，还是得有。\n虽然我是在你生日的时候才将这篇小论文写完，但不代表我是这时候才开始的，早在这之前，我就开始在想写些什么，该怎么写呢？就开头而言，对我来说是个非常难的事，我不知道怎么起头，就像和你才开始交往一样，那个开始，开始的好难，难散步、难聊天、难约会、难拥抱\u0026hellip;\u0026hellip; 我又延伸的想了想，我们好像共同走过了不少困难的时光，一定程度上也可以说是这些困难的日子成就了我们今天的感情基础！\n疫情这几年挺难的，对大家来说都挺难，对我们异地恋的情侣们来说，也真的是超难！若不是这该死的疫情，我现在会在淮南？但若和以前之前那段时间相比的话，这些难真的不算啥。\n就疫情开始前来说，那段时间我们能走在一起就难。我们在一起本就敏感、容易猜忌，那段时间，我们才开始，彼此正是建立信任和了解的阶段，这时候恰好又出现了疫情，对刚开始的我们来说真的很难。很感激那时候的你和我，冒着重重困难和危险出来和我见面，虽然只有几个小时的见面时间，但确实是我们如今感情坚实基础的很大的一部分。\n还有那彼此陪伴的考研、见家长等，这些一切，都很难。除此之外，还有现在的异地，虽然都很困难，但是没有哪一个困难没在告诉我们，只要克服了这个困难就是美好，就像小时候听过的那些大道理一样，但也确实就和那些大道理一样，只要走过了这些困难，就是美好。美好的未来，美好的你我组成的家庭，想象至此，憧憬万千\u0026hellip;\u0026hellip;\n今年我们两的生日都过的挺难的，没能陪着彼此过，但这后面会补上的我知道。我很珍惜每一个彼此陪伴的日子，能有彼此陪伴的生日，我更是珍惜，身边那么多感情的例子，无一不在用事实说明，现在的社会，两个人能合适的在一起，真的很难，同时也凸显出，我们能这么好的在一起，也真的是很难得的一段感情吧，所以我很珍惜，很珍惜每一个和你在一起的日子，经历愈多，感情愈深！这也是我为什么一直想和阿刁有个仅有彼此陪伴的旅游的原因！\n难归难，但难的结果是美好的，我们从一起在学校干饭的日子，走到现在一起在合肥干火锅、干烧烤的日子，再到以后一起做饭的日子，当然，阿刁可以不做，让我做饭给阿刁吃我也是非常愿意的。对我来说，重要的是彼此的陪伴，至于生活中的那些琐事，如果有了你的陪伴，我也觉得是非常非常有意义的事！\n我们彼此信任、了解也谦让，让这一切困难又显得是比较无力的。你总说你是个没耐心、焦躁的人，但我一直很庆幸，你对我们的感情有耐心、不焦躁，谢谢宝贝！也谢谢宝贝选择我、相信我、给我时间，我相信我也不会让阿刁失望的。\n道阻且长，行则将至；行而不辍，未来可期！\n"},{"id":42,"href":"/daily/ad/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%88%81%E7%9A%842021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"关于阿刁的2021年度总结","section":"我和阿刁","content":" 关于阿刁的2021年度总结 # 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE --- 今天大年初一，年终总结昨天太忙忘记写了，首先给阿刁道个歉！\n一回忆过去，我就刹不住车，因为和你经历太多了，虽然你懒不愿出远门旅游啥的，但是丝毫不影响，每次回忆过去的起点都是从高中开始，一回忆就陷进去了，忘了时间，想了很久，刚刚愣是看过去的聊天记录看了将近半个小时。才想起来，我是要写 2021 年的年终总结呀\u0026hellip;\u0026hellip;\n站在 2022 年的开始，看过去的 2021 年\u0026hellip;\u0026hellip; # 把时间倒退到 2021的开始，我们上半年开学前见了彼此的家人，然后一起去上学，一起准备考研复试，一起准备毕业论文，一起胡吃海喝，一起去给各自的牙齿做根管治疗，一起去操场跑步，陪你去教资面试，一起陪老弟中考，带老弟来我们的学校体验大学生活，一起教老弟学会了骑自行车，带着老弟一起吃海底捞\u0026hellip;\u0026hellip;\n以上的这些，都还是上半年的，想起来是一幅幅画面在脑海，我都想配个音乐剪个视频了，奈何很多仅有回忆，没有拍照留存。\n上半年，我真的是太幸福了，这并不是说我下半年过的不好（我这该死的求生欲），因为上半年每天都能见到你，去你宿舍下面找你，抱抱你。校内“异地”（仁苑与信苑）让我感觉很是不爽，那时候我经常想，如果要是我在潘东宿舍，你在你那栋楼的对面楼层，那样的话我可以坐在阳台敲代码，边敲代码，边看对面宿舍的你，简直太棒了。\n不论是考研还是复试，因为和你在一起，总感觉一点不苦，都是甜的。一起去图书馆，复习一半和你一起出来买吃的去草坪边晒太阳边吃起来了，还有那一起干饭一起买烤鸭吃的时光，简直太美了，回忆起来真的是刹不住车，你知道我本来也就是一个爱回忆的人。\n还记得那时我们一起教老弟学自行车，你拍照片给你室友了，你室友说我们这看起来太有爱了，就妥妥是一家人了。那条路，我每次从那走都会记得那段教老弟学自行车的日子。\n还有一起去治牙，我吓唬你疼，你夸张说换一嘴牙。还有一起跑步等等好多，我不敢再一件件回忆了，我怕你骂我说：“又不是不在一起了，在那怀念过去，你再回忆的话你一个人慢慢回忆”。🙄 2022 年，地位又低了好几成的我，还是停止回忆吧！\n说一下 21 年 “四个最” 吧，“第一最”不全发生在上半年，后“三个最”都发生在下半年。\n最最最让我开心的事莫过于见你的家人并得到了承认，最初见的是奶奶，那时你对我的维护，让我特别感动！然后是见哥哥姐姐，待我贼好！再后来是大姑父和大姑姥，他们对我好，还帮我在叔叔阿姨那说好话！后来是叔叔，叔叔也非常非常好，买好多好多小龙虾带我吃，做臭豆腐给我吃，还带我到昭庆寺玩！最后见的是阿姨，也做好多好多好吃的让我吃，还做好多让我带着，还偷偷塞我压岁钱！宝贝的家人都对我好好！从最初的认为我不好看，家暴，到现在承认我，这巨大的落差，是2021年最最最让我开心的事了！\n最最最让我惊喜的事情莫过于我在课堂上收到你给我发的信息了，那时我正在想你，很想很想你，恰好你就发信息给我，说你来我学校了，来看我，觉得像做梦一样，想像窜天炮一样从教室窜一下飞到南站去接你。你的命令和理智让我等到了下课，小电驴拧的贼快去找你，见你那一刻，眼泪都要流出来了。这是最让我惊喜并开心的事了吧！\n最最最伤心的事就是我开学的当天你在学校难受我去找你，然后被你狠狠熊回来了！\n最最最失望的事应该就是你骗我的那次了！\n下半年你我都挺忙，异地之苦，让我时常回忆上半年你在学校的日子！三千多亩地的地，走到哪里都有和你在一起的回忆；二百多万平的校园，怎么也装不下对你的想念。还好不是那么远，不然真的让我难受坏了！\n站在 2022 年的开始，说一下 2022 年\u0026hellip;\u0026hellip; # 希望我们两家人都身体依旧健健康康，这是最主要的，身体是革命的本钱，所以我把这个放在最开始说！\n关于 money 的探索，这里我就不说了，我不想做一个说了很多却做不到的人，但我不会停止探索！\n然后关于我们之间，我想我们两能够一起出去旅个游，你要是不想跑太远的话咱可以就在安徽周边走走闹闹，虽然我们的感情已经很好很好了，但是我还是想和你一起旅游，人生第一次旅游我就在想，如果身边的不是潘东和文明，是你该多好呀（文明潘东看到肯定想打我）！这是我 2022 年的想实现的第二个愿望！\n还有希望我能少惹你生气，希望能多多的去找你，花点钱没事，开心最重要呀！\n希望 2022 你在学术上更进一步，我在技术上更进一步！\n宝贝，现在正在和你开着视频，认真的看着你，真的很幸福，看你扣指甲油，涂卸甲油，真的很幸福！以后在一起，我帮你卸！你真是个可爱的大宝贝儿，不管做啥都觉的很可爱！\n2022 愿彼此家人健康，感情稳定，学业有成！\n"},{"id":43,"href":"/daily/ad/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%88%81%E7%9A%842022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"关于阿刁的2022年度总结","section":"我和阿刁","content":" 关于阿刁的2022年度总结 # 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE --- 和去年的年度总结一样，开始即道歉，本来是准备抓住 2022 的最后一天来写的，但是最后一天事情确实是太多了，忙不过来有点，所以只能 Sorry 了，在初一来完成这份年终总结！\n坐在书桌前，看了下去年写的年度总结，感觉时间过的好快呀！坐在书桌前也有好一段时间了，本该早早就已开始写的，但也只是坐在书桌前，并没有开始，距离“开始”二字来说，总觉得还差些火候。就回忆而言吧，2022 年在我脑海中涌现的画面，远比2021 年少的多的多，尽管 2021 年距离现在更远，我想这大概是异地的原因吧，2022 整年我们都是异地，2021 就不同了，仅仅半年！异地的交流都是通过视频，虽说可以见面，但总归是少了很多感受，不然我也不至于开始到现在还没开始。\n但是如果朝着回忆这个方向来作文章的话，貌似有些跑题，但转念一想，总结也就是对 过去 进行客观和主观的评价，必然需要回忆！虽说在关于 2022 年的回忆中涌现的不如 2021 多，但于我而言仍有很多让我想起来就很舒服踏实的回忆！\n站在 2023 年的开始，看过去的 2022 年\u0026hellip;\u0026hellip; # 2022 年发生了不少的大事，于祖国而言，有二十大的胜利召开、防疫政策优化、冬奥会等；但于你对于我而言，每一件都是大事！\n2022年我们一起在元宵节给叔叔过生日；我们冒着被感染的风险去彼此城市的学校找对方；我们一起攀爬情侣峰；我们和我爸妈以及老弟一起去万佛湖；我们一起带着老弟去玩水，我们三一起“承包”温泉泳池游泳；我们暑假一起教会老弟骑电动车；我们一起去天桥、罍街、步行街干饭摄影；我们“去过”合柴，那个地方海非常出片；我帮你成功抢9价并陪着你去打针；我们一起发现一家非常好吃的火锅店并乘坐摩天轮；我们一起去天鹅湖摄影，你还在天鹅湖广场和和一位牵了狗的大妈一起跳广场舞；我们一起去了李鸿章故居；我们一起骑美团、青桔、哈罗等；还有 2022 年末给你做饭送饭并照顾你的那段日子等！真的好幸运、好感激、好爱你！\n记得去年上半年开学你见我后不久是漫长的封控期，导致我们很久很久都没有见面，我真的很害怕封控，封控+异地对于情侣而言真的很无力，那段时间我真的非常害怕和你有矛盾，但何其幸运，虽然异地，但我们从未缺席过彼此的每一天！\n我好喜欢，真的好喜欢我骑车你坐我后面；好喜欢和你在外面走路，然后逗你不骑车，一直走；我希望合肥一直有青桔、美团以及哈罗，因为它们承载了你我太多太多的回忆，你可以像个小乖乖一样蹲在车前面，也可以抱着我坐在后面，如果不是车太多的话，我实在是舍不得用两只手骑车，因为我想用另一只手来牵着你！\n我好幸运，幸运有这一段矛盾不过夜的感情，无论我们多大的矛盾，也无论多晚，我们不会将矛盾留到第二天；也幸运有一段无论什么行动都会向彼此汇报的感情，每次彼此出去或者做什么事我们都会像彼此来汇报时间、地点、人物，可以看出来我们都很珍惜这段感情，我们也都很信任很重视彼此，有你真好！\n我还记得 2022 年初去学校前的那一天晚上，我在你家，在你的书桌旁边，接到医院电话后，你耐心陪我，看我难受你着急心疼哭了，安慰我并冷静的分析给我听，如果没有你陪我，那段时间确实挺难受的，虽然后来我再也没提过那茬子的事，但不代表我忘记，我一直都有记在心里面，你是知道我的，不擅表达，但不代表不擅行动。就像你做指甲一样，每一次出去你说做指甲都没做，但是每一次我都有记在心里，也就同 2022 年的倒数第三天一样，我陪着你一起找美甲店，尽管时间很长，我毫无怨言，虽然有过调侃，但也仅仅是调侃！\n虽然你很喜欢网购，这是你的小爱好嘛，而且你买的也不是非常贵的东西，再说，我非常喜欢看你拿快递开心激动的样子，尤其是陪你一起拿快递，尤其幸福，你该节省的地方也非常节省，仍然记得当时帮你抢到9价后再带你去打针，你坚持我们一起骑电动车哈哈，说到这我又想起来打九价的那个路口我们一起在“大宝面馆”吃了一碗牛肉面，当时挺冷，吃完真的很暖和！\n记得年底去合肥陪你租了一间小公寓，环境我不是很满意，我正在考虑需要换个住的地方不，因为我知道你喜欢舒适整洁的房间环境，但是那地方卫生、垃圾什么的真的挺差的，当时你请假出来和我吃晚饭一起去看了下，然后就毫不犹豫的拉着我去买拖把啥的，等上楼了你一直在帮忙清理，还让我歇着，告诉你，那时我贼感动，我发现阿刁和我想象的并不一样！\n在金地国际城的小公寓住将近半个月，每天吃面吃老乡鸡，晚上一般到了六点左右吃饭，吃晚饭就刷手机聊天或者看电视，那段日子，虽然阳着，但是阳的很踏实，每天虽然需要做饭、洗碗，虽然阳着很累很难受，但真的很美好，我又想起来金大地英伦联邦了，那时候在那边你好不容易想起来要和我一起跑步，然后却淋成了落汤鸡哈哈；在国际城这边，比较遗憾的是临搬走才发现楼下一家面馆非常好吃，还有就是酷伯尔隔壁的隔壁杨梅罐头非常便宜，阿刁喜欢吃我下的青菜汤面，阿刁还喜欢吃老乡鸡的竹笋蒸鸡翅还有小炒肉，阿刁喜欢喝我正在喝的水，如果人不需要吃喝拉撒阿刁真的可以一天到晚都在床上躺着（但是我不嫌弃）！为了让日常生活丰富一点，多一点运动量，晚上硬是哄你下来买好吃的才愿意和我一起下楼哈哈，还非要走电梯，然后多走100米你都要和我嘟嘟嘴半天哈哈哈，写这段我是边写边笑，真是太可爱了！\n你经常喜欢问我，等以后结婚了，我还会这样一直对你好吗？我好多时候都喜欢逗你，说不会这样对你好，我心里面知道我会一直这样对你好的，你应该也知道！记得我们刚开始在一起的时候你就这样问过我，当时我没有给你任何肯定的回答，因为那时候你也不够了解我，并且在一起是时间也不够长，没有足够长时间的观测数据，说再好听的话都会显得无力，其实你心里也该也知道，从我们刚刚开始恋爱到现在，从来没有变过！\n2022 我们已经一起走过去了，你让我说一些你的缺点，我实在说不出来，因为你太 Perfect 了，如果非要我说的话，那我就站在客观的角度来说一句： 对大宝哥脾气稍微好一点点嘛！ （这可不是我说的哈，是客观说的，客观的角度说的，不是我说的，我一直觉得你很温柔的😄）至此，关于 2022 年已经啰嗦了很多很多了，那么就着去年的愿望，再来看下实现的如何了吧，去年愿望归纳如下：\n双方家人身体健康\n家财万贯不如身体健康，总的来说我们彼此家人及彼此身体都还是倍儿棒的，虽然说我爸和奶奶 2022 年吃了点苦头，但身体还都是很健康的！\n关于个人收入\n上半年用你咸鱼做了些小生意，做的时间不长，收入近貌似3000～4000左右；随后在老师的推荐下去了中软，干了将近四个月，总时间是113天，收入14000+；下半年还接个项目 900+；奖学金12000；低保我就不算了！\n二人旅游\n这个可以说是 2022 的一大遗憾吧！我就不多说了\n总的来说，除掉第三点，其他都还算挺满意！\n站在 2023 年的开始，说一下 2023 年\u0026hellip;\u0026hellip; # 还是和去年一样，说一下 2023 年关于彼此的愿望吧！\n第一大愿望还是和去年的一样，以后每年也是一样不变，希望我们彼此家人身体健健康康！\n第二大愿望是希望我们彼此在学业上都顺意，除此之外，如果时间足够的话，希望自己能再有一段实习经历，希望能去好点的公司实习！\n第三大愿望有个前提条件，如果我们要是都能在今年落实工作的话，我非常非常极度极度希望我们能在一个城市！\n最后一大愿望是去年没有实现的愿望，就是想和你一起旅游，希望宝贝儿脚迈勤一点点啦！\n好奇妙呀，和去年一样，写至此，还是正在和你开着视频，真是太幸福了，希望年年如此！\n2023 愿彼此家人健康，感情稳定，学业有成，事业有成！\n"},{"id":44,"href":"/notes/bms/bms-%E7%AE%80%E4%BB%8B/","title":"Bms 简介","section":"BMS","content":" BMS 相关概念 # 什么是 BMS # BMS（Battery Management System）电池管理系统，由硬件和软件共同组成，主要实现以下功能：\n管理多节锂电池组成的电池包 实现电池充放电管理，如防过充、防亏电 信息监控，如续航里程、剩余电量等 锂电池分类 # 主要分为两类，三元锂和磷酸铁锂，它们在特性和电参数上有差异，所以BMS也会有相应的差异。哪怕同是三元锂电池，也不能直接套用，还是需要进行调参的。\nBMS 需要解决的问题 # 充放电保护，如过充、过放、过温保护等。 充放电信息监控，如剩余电量、里程计算等。 电池状态监控，如剩余电量SOC、电池健康度SOH等。 充放电均衡，如充或放电时、主动或被动均衡。 与充电桩对接。如充电协议、快充标准等。 锂电池需要考虑的特性：\n充放电曲线，如图1\n单节电池的电特性参数值\n电池个体差异，同一规格电池彼此静态参数有误差，动态参数也有误差\n不同电池个体老化速度不同步\n动力电池和非动力电池的区别，主要区别在于放电电流区别，即多长时间能把这么多电放出来，动力电池一般可以放的电流更大，一般电钻、电机等可以用动力电池。\n充放电曲线：\n常见电池充放电保护相关参数：\n/***************************** 电池保护相关参数 ***********************************/ // 三元锂电池(Ternary lithium battery)默认参数 #define TLB_OV_PROTECT\t4.20\t// 单体过压保护电压 #define TLB_OV_RELIEVE\t4.18\t// 单体过压恢复电压 #define TLB_UV_PROTECT\t3.10\t// 单体欠压保护电压 #define TLB_UV_RELIEVE\t3.15\t// 单体欠压恢复电压 #define TLB_SHUTDOWN_VOLTAGE\t3.08\t// 自动关机电压 #define TLB_BALANCE_VOLTAGE\t3.30\t// 均衡起始电压 // 磷酸铁锂电池(lithium iron phosphate battery)默认参数 #define LIPB_OV_PROTECT\t3.60\t// 单体过压保护电压 #define LIPB_OV_RELIEVE\t3.55\t// 单体过压恢复电压 #define LIPB_UV_PROTECT\t2.60\t// 单体欠压保护电压 #define LIPB_UV_RELIEVE\t2.65\t// 单体欠压恢复电压 #define LIPB_SHUTDOWN_VOLTAGE\t2.50 // 自动关机电压 #define LIPB_BALANCE_VOLTAGE\t3.00\t// 均衡起始电压 // 钛酸锂电池(Lithium titanate battery)默认参数 #define LTB_OV_PROTECT\t2.70\t// 单体过压保护电压 #define LTB_OV_RELIEVE\t2.65\t// 单体过压恢复电压 #define LTB_UV_PROTECT\t1.80\t// 单体欠压保护电压 #define LTB_UV_RELIEVE\t1.85\t// 单体欠压恢复电压 #define LTB_SHUTDOWN_VOLTAGE\t1.70\t// 自动关机电压 #define LTB_BALANCE_VOLTAGE\t2.30\t// 均衡起始电压 "},{"id":45,"href":"/notes/java/arraylist-%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99/","title":"Array List 扩容规则","section":"Java","content":" 掌握 ArrayList 的扩容相关机制 # 目标 # 掌握 ArrayList 的扩容机制 掌握 Iterator 的 fail-fast、fail-safe 机制 ArrayList 扩容机制 # new ArrayList() 会使用长度为零的数组 new ArrayList(int initialCapacity) 会使用指定容量的数组 public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) 会使用 c 的大小作为数组容量 add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍 addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量1.5倍, 实际元素个数) ArrayList 前 20 次扩容规律（底层用的是右移计算，如果口算 * 1.5 的话，则取整）：\n[0, 10, 15, 22, 33, 49, 73, 109, 163, 244, 366, 549, 823, 1234,1851, 2776, 4164, 6246, 9369, 14053, 21079] 相关问题 # 问：往数组中添加 100 个元素，会扩容成多大？ # 点击展开 ... [0, 10, 15, 22, 33, 49, 73, 109, 163, 244, 366, 549, 823, 1234,1851, 2776, 4164, 6246, 9369, 14053, 21079] 由上表可以看出，添加 100 个元素后，容量为 109\n什么情况下你会使用ArrayList？什么时候你会选择LinkedList？ # 点击展开 ... ArrayList 增删慢、查询快；LinkedList 增删快，查询慢。 上面回答是典型的错误，二者的查询是一样的时间复杂度，注意 查询 != 随机访问。\nArrayList 和 LinkedList 比较：\nArrayList\n基于数组，需要连续内存 随机访问快（指根据下标访问） 尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低 可以利用 cpu 缓存，局部性原理 LinkedList\n基于双向链表，无需连续内存 随机访问慢（要沿着链表遍历） 头尾插入删除性能高 占用内存多 两者补充： 两者在中间插入速度都比较慢，但是 ArrayList 中间插入速度要比 Linked 中间插入速度快。ArrayList 快在定位，慢在增删数据；LinkedList 慢在定位，快在增删数据。\n总结：\n随机访问元素比插入、删除元素更加频繁的时候，应该使用ArrayList。\n尾部插入、删除元素频繁的时候，应该使用ArrayList。\n中间插入、删除元素频繁的时候，应该使用ArrayList。\n头部插入、删除元素频繁的时候，应该使用LinkedList。\n问：ArrayList是如何扩容的？ # 点击展开 ... ArrayList扩容后的大小等于扩容前大小的1.5倍。\n可能会导致的问题：\n内存不足抛出OutOfMemoryError。 扩容的时候还需要对数组进行拷贝，这个也挺费时的。 解决方案：面对大量数据时，使用的时候要竭力避免扩容，提供一个初始估计容量参数，以免扩容对性能带来较大影响。\nArrayList的遍历有哪些方法？ # 点击展开 ... 普通for循环的方式。 增强for循环的方式。 迭代器的方式。 如何复制某个ArrayList到另一个ArrayList中去？ # 点击展开 ... 三种办法： 使用clone()方法，比如ArrayList newArray = oldArray.clone(); 使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject); 使用Collection的copy方法。 在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？ # 点击展开 ... 在 ArrayList 中增加或者是删除元素，要调用System.arraycopy这种效率很低的操作，如果遇到了需要频繁插入或者是删除的时候，你可以选择其他的Java集合，比如LinkedList。\n// 源码片段 public void add(int index, E element) { rangeCheckForAdd(index); // 检查索引是否合法 modCount++;\t// 记录修改次数 final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) // 检查是否需要扩容 elementData = grow(); // 从 index 开始，每个元素向后移动一位 System.arraycopy(elementData, index,\telementData, index + 1, s - index); // index 位置空出，空出位置等于 element elementData[index] = element; // size 加 1 size = s + 1; } fail-fast 和 fail-safe # fail-fast # ArrayList 中体现出 fail-fast 的地方主要在于 modCount 这个变量，该变量继承自 AbstractList 变量，官方解释如下：\nThe number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\nThis field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.\nUse of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\nmodCount 仅当影响结构时，值才会变化，比如修改某个位置元素的值，modCount 值不变，但要是 add 或者 remove 操作，modCount 值就会改变。另外，ArrayList 是 fail-fast 的典型代表，ArrayList 遍历的同时不能修改，负责会引起 ConcurrentModificationException 报错。\n那么是否有遍历的同时修改不会报错的方法呢？\nfail-safe # CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离，但是会牺牲其一致性。\n"},{"id":46,"href":"/notes/java/hashmap-%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","title":"Hash Map 相关学习总结","section":"Java","content":" HashMap 相关学习总结 # 相关问题 # 红黑树相关问题 # 关于底层数据结构，HashMap 的 JDK 1.7 和 JDK 1.8 有何不同？ # 点击展开 ... JDK 1.7 组成：数组 + 链表 JDK 1.8 组成：数组 + 链表/红黑树 为什么要用红黑树？ # 点击展开 ... 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况。 为何不一上来就树化？ # 点击展开 ... 刚刚开始时，链表长度都比较短，这时候链表的效率并不一定比树化后低，并且树化还会浪费存储。\n其次，hash 表的查找、更新的时间复杂度是 O(1) ，而红黑树的查找、更新的时间复杂度是 O(log2 n)，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表。\n树化阈值为何为 8？ # 点击展开 ... 主要是为在时间和空间上恰好达到平衡，8 是根据概率统计而寻找的值。\nhash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过8的链表出现概率是\n0.00000006（亿分之六），选择 8 就是为了让树化机率足够小。\n是不是一超过阈值就立马变为红黑树？是否要满足一些其他条件？ # 点击展开 ... 不是。\n需要同时满足以下条件\n数组容量大于等于64 链表长度大于8 红黑树什么时候会退化成链表？ # 点击展开 ... 主要有以下两种情况会退化成链表：\n情况1: 在扩容时如果拆分了树，树元素个数＜=6则会退化链表。 情况2: 删除树节点时，若 root，root.left，root.right，root.left.left 中有任一个为null，也会退化为链表。 索引相关问题 # 索引计算方法？ # 点击展开 ... 计算对象的 hashCode() 调用 HashMap 的 hash()方法进行二次哈希 \u0026amp; (capacity – 1) 得到索引 hashCode 都有了，为何还要提供 hash() 方法？ # 点击展开 ... 二次 hash() 是为了综合高位数据，让哈希分布更为均匀。 数组容量为何是 2 的 n 次幂？ # 点击展开 ... 计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模 扩容时重新计算索引效率更高： hash \u0026amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap 求模运算优化：\n97 % 16 可以写成 97 \u0026amp; （16 - 1） 97 % 64 可以写成 97 \u0026amp; （64 - 1） 按位与运算比求模运算效率高。 求模类似于除法运算，所耗费的CPU时钟周期比较长。\n前提：除数必须是 2 的 n 次方\nput 与 扩容 相关问题 # put 流程？ # 点击展开 ... HashMap 是懒惰创建数组的，首次使用才创建数组 计算索引（桶下标） 如果桶下标还没人占用，创建 Node 占位返回 如果桶下标已经有人占用 已经是 TreeNode 走红黑树的添加或更新逻辑 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，并且容量大于等于64，走树化逻辑 返回前检查容量是否超过阈值，一旦超过进行扩容 1.7 与 1.8 的区别\n链表插入节点时，1.7 是头插法，1.8 是尾插法 1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容 1.8 在扩容计算 Node 索引时，会优化 扩容（加载）因子为何默认是 0.75f ？ # 点击展开 ... 在空间占用与查询时间之间取得较好的权衡 大于这个值，空间节省了，但链表就会比较长影响性能 小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多 并发问题 # 多线程下操作 HashMap 会有什么问题？ # 点击展开 ... 多线程下操作 HashMap 主要有以下问题：\n扩容死链（1.7） 数据错乱（1.7、1.8） key 的设计要求 ？ # 点击展开 ... HashMap 的 key 可以为 null，但 Map 的其他实现则不然 作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的一定要是不可变值，如 String、int等 key 的 hashCode 应该有良好的散列性 如果 key 可变，例如修改了 age 会导致再次查询时查询不到\npublic class HashMapMutableKey { public static void main(String[] args) { HashMap\u0026lt;Student, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Student stu = new Student(\u0026#34;张三\u0026#34;, 18); map.put(stu, new Object()); System.out.println(map.get(stu)); stu.age = 19; System.out.println(map.get(stu)); // 查询为 空 } static class Student { String name; int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, age); } } } key 相关问题 # String 对象的 hashCode() 设计? # 点击展开 ... 目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特\n字符串中的每个字符都可以表现为一个数字，称为\n\\( S_i \\) ，其中 i 的范围是 0 ~ n - 1 散列公式为： \\[S_0∗31^{(n-1)}\u0026#43; S_1∗31^{(n-2)}\u0026#43; … S_i ∗ 31^{(n-1-i)}\u0026#43; …S_{(n-1)}∗31^0\\] 31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 \\[32 ∗h -h\\] 等同于：\n\\[2^5 ∗h -h\\] 等同于：\n\\[h≪5 -h\\] "},{"id":47,"href":"/notes/java/java-%E5%8F%8D%E5%B0%84/","title":"Java 反射","section":"Java","content":" Java 反射 # 将类的各个组成部分封装为其他对象，这就是反射机制。\n1 反射的一般步骤 # 获取类字节码 获取构造函数、成员变量或成员方法 执行或构造需要的业务 2 获取字节码的三种方式 # Class.forName(\u0026quot;全类名\u0026quot;)：多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：多用于参数的传递 对象.getClass()：多用于从对象获取字节码的方式 同一个字节码文件在一次程序运行过程中，只会被加载一次，不论通过哪种方式获取的 class 对象都是同一个。\n3 Class 对象的功能 # 如上图，针对 Java 代码在计算机中经历的三个阶段来说，对于 Class 类对象阶段，主要有以下三种对象：\nField Constructor Method 针对这三种对象，Class 分别提供 get*** 和 getDeclared*** 方法来获取，前者获取 public 的，后者获取所有被声明的。以下代码针对 get*** 给出代码演示和说明，getDeclared*** 类似。\n3.1 针对构造方法 # 获取 public 修饰的\n`Constructor getConstructors()`` ``Constructor getConstructor(类, 参数类型)` 获取全部类型\nConstructor getDeclaredConstructors() Constructor getDeclaredConstructor(类, 参数类型) 3.1.1 获取public修饰的有参构造函数并创建对象 # Class cls = Student.class; // 获取public修饰的有参构造函数并创建对象 Constructor constructor = cls.getConstructor(String.class, Integer.class); Student stu = (Student) constructor.newInstance(\u0026#34;张三\u0026#34;, 25); System.out.println(stu); // out: // Student{name=\u0026#39;张三\u0026#39;, age=25, a=\u0026#39;null\u0026#39;, b=\u0026#39;null\u0026#39;, c=\u0026#39;null\u0026#39;} 3.1.2 获取public修饰的有参构造函数并创建对象 # Class cls = Student.class; // 获取public修饰的无参构造函数并创建对象 Constructor constructor = cls.getConstructor(); Student stu = (Student) constructor.newInstance(); // 无参构造函数获取对象也可以直接写 // Student stu = (Student) cls.newInstance(); System.out.println(stu); // out: // Student{name=\u0026#39;null\u0026#39;, age=null, a=\u0026#39;null\u0026#39;, b=\u0026#39;null\u0026#39;, c=\u0026#39;null\u0026#39;} 3.1.4 获取public修饰的所有构造函数并创建对象 # Class cls = Student.class; // 获取public修饰的所有构造函数 Constructor[] constructors = cls.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } // out: // public cc.mhwy.domain.Student() // public cc.mhwy.domain.Student(java.lang.String,java.lang.Integer) 3.2 针对成员变量 # 获取 public 修饰的\nField[] getFields() Field getField(String name) 获取全部类型\nField[] getDeclaredFieds() Field getDeclaredField(String name) 3.2.1 获取public修饰的指定变量并写、读值 # Class cls = Student.class; Student stu = (Student) cls.newInstance(); // 利用无参构造函数获取对象 // 获取public修饰的指定变量并写、读值 Field a = cls.getField(\u0026#34;a\u0026#34;); a.set(stu, \u0026#34;测试\u0026#34;); // 注意第一个参数要绑定对象 System.out.println(stu); // 写值 System.out.println(a.get(stu)); // 读值 // out: // Student{name=\u0026#39;null\u0026#39;, age=null, a=\u0026#39;测试\u0026#39;, b=\u0026#39;null\u0026#39;, c=\u0026#39;null\u0026#39;} // 测试 3.2.2 暴力反射：获取私有变量或给私有变量写值 # Class cls = Student.class; Student stu = (Student) cls.newInstance(); // 利用无参构造函数获取对象 System.out.println(stu); // 暴力反射：获取私有变量或给私有变量写值 Field name = cls.getDeclaredField(\u0026#34;name\u0026#34;); name.setAccessible(true); // 必须忽略权限，否则读写私有变量会出错 name.set(stu, \u0026#34;李四\u0026#34;); System.out.println(stu); // out: // Student{name=\u0026#39;null\u0026#39;, age=null, a=\u0026#39;测试\u0026#39;, b=\u0026#39;null\u0026#39;, c=\u0026#39;null\u0026#39;} // Student{name=\u0026#39;李四\u0026#39;, age=null, a=\u0026#39;测试\u0026#39;, b=\u0026#39;null\u0026#39;, c=\u0026#39;null\u0026#39;} 3.2.2 获取public修饰的所有变量 # Class cls = Student.class; Student stu = (Student) cls.newInstance(); // 利用无参构造函数获取对象 // 获取public修饰的所有变量 Field[] fields = cls.getFields(); for (Field field : fields) { System.out.println(field); } // out: // public java.lang.String cc.mhwy.domain.Student.a // public java.lang.String cc.mhwy.domain.Student.b // public java.lang.String cc.mhwy.domain.Student.c 3.3 针对成员方法 # 获取 public 修饰的\nField[] getMethods() Field getMethod(String name) 获取 public 修饰的\nField[] getDeclaredMethods() （父类的也会获取到） Field getDeclaredMethod(String name) 3.3.1 获取public修饰无参方法调用 # Class cls = Student.class; Student stu = (Student) cls.newInstance(); // 利用无参构造函数获取对象 // 获取public修饰无参方法调用 Method play = cls.getMethod(\u0026#34;play\u0026#34;); play.invoke(stu); // out: // 在操场玩... 3.3.1 获取public修饰有参方法调用 # Class cls = Student.class; Student stu = (Student) cls.newInstance(); // 利用无参构造函数获取对象 // 获取public修饰有参方法调用 Method play = cls.getMethod(\u0026#34;play\u0026#34;, String.class, Integer.class); play.invoke(stu, \u0026#34;小明\u0026#34;, 20); // out: // 20岁的小明在操场玩... 3.4 获取类名 # String getName()\nSystem.out.println(cls.getName()); // out: // cc.mhwy.domain.Student "},{"id":48,"href":"/notes/leetcode/day001-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%95%B0%E7%BB%84/","title":"Day001 第一章数组","section":"代码随想录刷题","content":" 今天刷的题 # 二分查找\n搜索插入位置\n在排序数组中查找元素的第一个和最后一个位置\n移除元素\n刷题总结 # 二分查找： # 通过看卡哥视频，了解到主要分为两个边界：[m,n] 和 [m,n) ， 然后代码的时候要注意统一边界问题，右边界的更行规则要和while中的规则一致。\n搜索插入位置： # 没能变通过来，直接套用了二分的模型，但是最后返回不对，主要是因为 while 循环外的返回直接用了 mid ，这里应该是返回左边界，也就是 left。\n在排序数组中查找元素的第一个和最后一个位置： # 暴力解决了，但是效果不太好。尝试二分解决，但是没能弄出来。后来看题解才发现，二分还能那样用，这题重点记一下吧。\n总的思路是利用两次二分查找，第一次查找左边界（第一个大于等于 target 的数字），第二次查找右边界（第一个大于 target 的数字）。暂时还不是太了解，代码如下：\nclass Solution { public int[] searchRange(int[] nums, int target) { int leftIdx = binarySearch(nums, target, true); int rightIdx = binarySearch(nums, target, false) - 1; if (leftIdx \u0026lt;= rightIdx \u0026amp;\u0026amp; rightIdx \u0026lt; nums.length \u0026amp;\u0026amp; nums[leftIdx] == target \u0026amp;\u0026amp; nums[rightIdx] == target) { return new int[]{leftIdx, rightIdx}; } return new int[]{-1, -1}; } public int binarySearch(int[] nums, int target, boolean lower) { int left = 0, right = nums.length - 1, ans = nums.length; while (left \u0026lt;= right) { int mid = (left + right) / 2; // 不是很了解 if (nums[mid] \u0026gt; target || (lower \u0026amp;\u0026amp; nums[mid] \u0026gt;= target)) { right = mid - 1; ans = mid; } else { left = mid + 1; } } return ans; } } 以上代码总共有两点需要特别消化：\n第一点：\nif (leftIdx \u0026lt;= rightIdx \u0026amp;\u0026amp; rightIdx \u0026lt; nums.length \u0026amp;\u0026amp; nums[leftIdx] == target \u0026amp;\u0026amp; nums[rightIdx] == target) 第二点：\nif (nums[mid] \u0026gt; target || (lower \u0026amp;\u0026amp; nums[mid] \u0026gt;= target)) 移除元素： # 暴力做出来了，快慢指针也解决了。具体代码如下：\n// 暴力法 public int removeElement1(int[] nums, int val) { int valNum = 0; for (int i = 0; i \u0026lt; nums.length - valNum; i++) { if (nums[i] == val) { int j = i; while (j \u0026lt; nums.length - valNum - 1) { nums[j] = nums[++j]; } valNum++; i--; } } return nums.length - valNum; } // 双指针法 public int removeElement2(int[] nums, int val) { int i = 0, k = 0; while (i \u0026lt; nums.length) if (nums[i] != val) nums[k++] = nums[i++]; else i++; return k; } "},{"id":49,"href":"/notes/leetcode/day002-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%95%B0%E7%BB%84/","title":"Day002 第一章数组","section":"代码随想录刷题","content":" 今天刷的题 # 977. 有序数组的平方\n209. 长度最小的子数组\n59. 螺旋矩阵 II\n总结 # 有序数组的平方 # 开始没想通，以为和之前那题“移除元素”一样，必须要原地操作，不能开拓新的数组。这给我整不会了，然后看题解才发现，是要开辟新数组的，悟了。\n// 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 public int[] sortedSquares(int[] nums) { int index = nums.length-1; int[] res = new int[index+1]; int l = 0, r = nums.length-1; while (l \u0026lt;= r) { if (nums[l] * nums[l] \u0026gt; nums[r] * nums[r] ) res[index--] = nums[l] * nums[l++]; else res[index--] = nums[r] * nums[r--]; } return res; } 长度最小的字数组 # 上次做是一个月前，不会做，看了卡哥题解，通透了，这次做直接会了。本质上还是双指针，这里说快慢指针的话感觉更合适。代码如下：\n// 滑动窗口 public int minSubArrayLen(int target, int[] nums) { int i = 0, j = 0; // 快慢指针 int sum = 0; int res = 0; while (j \u0026lt; nums.length) { // 左边界不可能会超，只要保证右边界不超就好了 sum += nums[j]; while (sum \u0026gt;= target) { if ((j - i + 1) \u0026lt; res || res == 0) res = j - i + 1; sum -= nums[i++]; } j++; } return res; } 螺旋矩阵 # 不会，想不通。看了卡哥视频才会写的，写的还磕磕盼盼。主要问题是各种边界处理。如loop \u0026lt; n / 2 - offset 这里我当时写成了 loop \u0026lt;= n / 2 - offset；除此之外，还有就是第一个loop处的 i 我没用 start， 还用的是 i，这将导致第二次循环时不会递进，这里后来通过在循环初始处将 start 赋值给 i 和 j 解决了。以下是最终代码：\n// 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 public int[][] generateMatrix(int n) { int loop = 0; // 循环次数 int start = 0; // 起始位置 int offset = 1; // 偏移量 int[][] res = new int[n][n]; int i = 0, j = 0; int count = 1; // 要填充的值 while ( loop \u0026lt; n / 2 ){ j = start; i = start; while (j \u0026lt; n - offset) res[i][j++] = count++; while (i \u0026lt; n - offset) res[i++][j] = count++; while (j \u0026gt; start) res[i][j--] = count++; while (i \u0026gt; start) res[i--][j] = count++; start++; offset++; loop++; } if (n % 2 == 1) { res[n/2][n/2] = count; } return res; } "},{"id":50,"href":"/notes/leetcode/day003-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%93%BE%E8%A1%A8/","title":"Day003 第二章链表","section":"代码随想录刷题","content":" 今天刷的题 # 203. 移除链表元素 # 707. 设计链表 # 206. 反转链表 # 总结 # 移除元素 # 链表移除元素还是比较简单的，但涉及到一个头节点的处理，会很碍事的感觉，这里可以添加一个虚拟头节点，这样会很好用，可以编写代码统一处理。代码如下：\n// 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(-1, head); ListNode p = new ListNode(); p.next = head; while (p.next != null) { if (p.next.val == val) { p.next = p.next.next; // p.next 删除 } else { p = p.next; } } return dummy.next; } 设计链表 # 设计5个函数，分别是头部插入、尾部插入、索引插入、取值、删除，开始以为写不出来，慢慢的还写出来了，但是运行时间不是太快，只打败了一半的选手，估计哪个地方的算法有问题。代码如下：\nclass MyLinkedList { private int val; private MyLinkedList next; private int size; public int getSize() { return size; } public MyLinkedList() { size = 0; } public int get(int index) { int k = 0; int res = 0; // 检查 index 是否有效 if (index \u0026gt; size-1 || index \u0026lt; 0) { return -1; } MyLinkedList p = this; while (p.next != null) { if (k++ == index) { res = p.next.val; break; } p = p.next; } return res; } public void addAtHead(int val) { // 保存节点 MyLinkedList node = new MyLinkedList(); node.val = val; // 开始添加 node.next = this.next; this.next = node; size++; } public void addAtTail(int val) { MyLinkedList node = new MyLinkedList(); node.val = val; MyLinkedList p = this; while (p.next != null) { p = p.next; } p.next = node; size++; } public void addAtIndex(int index, int val) { if (index \u0026gt; size) return; if (index == size) { addAtTail(val); return; } if (index \u0026lt; 0) { addAtHead(val); } else { int k = 0; MyLinkedList p = this; MyLinkedList node = new MyLinkedList(); node.val = val; while (p.next != null) { if (k++ == index) { node.next = p.next; p.next = node; } p = p.next; } size++; } } public void deleteAtIndex(int index) { // 判断索引是否有效 if (index \u0026gt; size - 1 || index \u0026lt; 0) return; int k = 0; MyLinkedList p = this; while (p.next != null) { if (k++ == index) { p.next = p.next.next; size--; break; } p = p.next; } } } 反转链表 # 这题还是用虚拟头节点写的，用一个新的链表，起始第二题写出来了，这一题就很简单了，打败了100%选手，可能由于开辟了新的节点，占用的内存有点稍高。\nclass Solution { public ListNode reverseList(ListNode head) { ListNode dummy = new ListNode(-1, head); ListNode p = dummy; ListNode newNode = new ListNode(); while (p.next != null) { ListNode node = new ListNode(p.next.val); node.next = newNode.next; newNode.next = node; p = p.next; } return newNode.next; } } "},{"id":51,"href":"/notes/leetcode/day004-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%93%BE%E8%A1%A8/","title":"Day004 第二章链表","section":"代码随想录刷题","content":" 今天刷的题 # 24. 两两交换链表中的节点 # 19. 删除链表的倒数第 N 个结点 # 面试题 02.07. 链表相交 # 142. 环形链表 II # 总结 # 两两交换链表中的节点 # 这题还可以用递归，但是我没搞明白递归，递归回头要看一下。开始没画图，没做出来，指针题一定要画图，指针题一定要画图，指针题一定要画图！后来画图给整出来啦，第一题呀不是很难。代码如下：\npublic static ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(-1, head); ListNode p = dummy; while (p.next != null \u0026amp;\u0026amp; p.next.next != null) { ListNode q = p.next.next.next; p.next.next.next = p.next; p.next = p.next.next; p.next.next.next = q; p = p.next.next; } return dummy.next; } 删除链表的倒数第N个结点 # 没写出来，卡哥的方法很妙，用快慢指针，快慢指针中间间隔 n+1 位数，这样，快指针到链表最后，慢指针刚刚好到了要删除的数的前一位，具体写的代码如下：\npublic static ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummpy = new ListNode(-1, head); ListNode p = dummpy; // 快指针 ListNode q = dummpy; // 慢指针 while (n-- \u0026gt; 0) { p = p.next; } while (p.next != null) { p = p.next; q = q.next; } q.next = q.next.next; return dummpy.next; } 面试题 02.07. 链表相交： # 这题当时考研时候，在王道书上面写过类似的记得，但是具体忘记了。\npublic static ListNode getIntersectionNode(ListNode headA, ListNode headB) { int sizeA = 0, sizeB = 0; ListNode pa = new ListNode(-1, headA); ListNode pb = new ListNode(-1, headB); while (pa.next != null) { pa = pa.next; sizeA++; } while (pb.next != null) { pb = pb.next; sizeB++; } if (sizeB \u0026gt; sizeA) { int tempSize = sizeA; sizeA = sizeB; sizeB = tempSize; pa = new ListNode(-1, headB); pb = new ListNode(-1, headA); } else { // 要注意的地方，当时卡了一会儿 pa = new ListNode(-1, headA); pb = new ListNode(-1, headB); } int n = sizeA - sizeB ; while (n-- \u0026gt; 0) { pa = pa.next; } while (pa.next != pb.next || pa.next == null) { pa = pa.next; pb = pb.next; } return pa.next; } 环形链表 # 这题要不是看卡哥解释，我怎么也做不出来，太妙了这题，让我想到之前上学时候写的操场跑步数学题了，很相似，重点是分析的思路，分析出来了，也就好写了，但是我还是没处理好，这题我用了虚拟头节点，AC了。后来看卡哥题解，把虚拟头节点去掉，才写出来了。\npublic static ListNode detectCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast!= null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { ListNode index1 = head; ListNode index2 = fast; while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } "},{"id":52,"href":"/notes/leetcode/day006-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%93%88%E5%B8%8C%E8%A1%A8/","title":"Day006 第三章哈希表","section":"代码随想录刷题","content":" 今天刷的题 # 242. 有效的字母异位词\n349. 两个数组的交集\n202. 快乐数\n1. 两数之和\n总结 # 有效字母的异位词 # 相关哈希表的知识早就忘完了，今天刚刚刷哈希表章节的题目，感觉很是陌生难下手，看了卡哥的题解才自己写出来了。主要思想是开辟一个新数组，新数组的下标用来表示字母，新数组的元素值用来计数。具体代码如下：\npublic static boolean isAnagram(String s, String t) { int[] record = new int[26]; for (int i = 0; i \u0026lt; s.length(); i++) { record[s.charAt(i) - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; t.length(); i++) { record[t.charAt(i) - \u0026#39;a\u0026#39;]--; } for (int count : record){ if (count != 0) { return false; } } return true; } 两个数组的交集 # 这题我用了和上题一样的方法解的，因为我发现题目限制了数值，数值最大只有1000，最小为0，所以我还是开辟了一个1001长度的数组用来给第一个数组计数。遍历完第一个数组后遍历第二个数组，查看其位置是否大于0，如果大于0，则说明有交集，将其标记为-1，并用一个计数器，记录个数。然后初始化一个数组保存结果，并遍历任意一个数组，一旦发现为-1，将其存入数组。时间复杂度为 O(2m + n)，发现比卡哥的代码要快一点， 代码如下：\npublic static int[] intersection(int[] nums1, int[] nums2) { int[] record = new int[1001]; int k = 0; for (int num : nums1) { record[num]++; } for (int num : nums2) { if (record[num] \u0026gt; 0) { record[num] = -1; k++; } } int[] res = new int[k]; int index = 0; for (int num : nums2) { if (record[num] == -1) { res[index++] = num; record[num] = 1; } } return res; } 快乐数 # 不会，看了卡哥的题解。取余思想求平方和，哈希思想判断是否会无限循环，写的具体代码如下：\npublic static boolean isHappy(int n) { Set\u0026lt;Integer\u0026gt; nums = new HashSet\u0026lt;\u0026gt;(); int res = squreSum(n); while (!nums.contains(res)) { if (res == 1) { return true; } else { nums.add(res); } res = squreSum(res); } return false; } public static int squreSum(int n) { int res = 0; while (n != 0) { int temp = n % 10; res += temp * temp; n = (n - temp) / 10; } return res; } 两数之和 # 暴力方法写出来了，运行时间比较慢，看了卡哥题解，用哈希方法也写了一遍。具体代码分别如下：\n// 暴力法 public static int[] twoSum(int[] nums, int target) { int[] res = new int[2]; for (int i = 0; i \u0026lt; nums.length; i++) { int searchNum = target - nums[i]; for (int j = i+1; j \u0026lt; nums.length; j++) { if (searchNum == nums[j]) { res[0] = i; res[1] = j; break; } } if (res[0] + res[1] == target) { break; } } return res; } // 哈希法 public static int[] twoSum1(int[] nums, int target) { int[] res = new int[2]; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int temp = target - nums[i]; if (map.containsKey(temp)) { res[0] = i; res[1] = map.get(temp); break; } map.put(nums[i], i); } return res; } "},{"id":53,"href":"/notes/leetcode/day007-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%93%88%E5%B8%8C%E8%A1%A8/","title":"Day007 第三章哈希表","section":"代码随想录刷题","content":" 今天刷的题 # 454. 四数相加 II\n383. 赎金信\n15. 三数之和\n18. 四数之和\n总结 # 四数相加 # 稍微想了下，除掉暴力，丝毫没有思路，看了卡哥的题解，巧妙的将多重循环变成了双重循环，时间复杂度一下子降了好几个量级。代码如下：\nclass Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int temp; int res = 0; //统计两个数组中的元素之和，同时统计出现的次数，放入map for (int i : nums1) { for (int j : nums2) { temp = i + j; if (map.containsKey(temp)) { map.put(temp, map.get(temp) + 1); } else { map.put(temp, 1); } } } //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数 for (int i : nums3) { for (int j : nums4) { temp = i + j; if (map.containsKey(0 - temp)) { res += map.get(0 - temp); } } } return res; } } 赎金信 # 这题没什么好说的，和昨天的那一题很相似。\nclass Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] records = new int[26]; for (int i = 0; i \u0026lt; magazine.length(); i++) { records[magazine.charAt(i) - \u0026#39;a\u0026#39;] += 1; } for (int i = 0; i \u0026lt; ransomNote.length(); i++) { records[ransomNote.charAt(i) - \u0026#39;a\u0026#39;] -= 1; } for (int i = 0; i \u0026lt; records.length; i++) { if (records[i] \u0026lt; 0) { return false; } } return true; } } 三数之和 # 没整出来，看了题解然后自己才勉勉强强写出来，主要思想有两个：双重指针、去重！其中去重是第一次接触，也是才知道 nums[i] \u0026amp;\u0026amp; nums[i+1] 和 nums[i] \u0026amp;\u0026amp; nums[i-1] 去重的不同之处，代码如下：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; 0) { return res; } if (i\u0026gt;0 \u0026amp;\u0026amp; nums[i-1] == nums[i]) { continue; } int left = i + 1; int right = nums.length - 1; while (left \u0026lt; right) { int temp = nums[i] + nums[left] + nums[right]; if (temp \u0026gt; 0) { right--; } else if (temp \u0026lt; 0) { left++; } else { res.add(Arrays.asList(nums[i], nums[left], nums[right])); left++; right--; while(left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left-1]) left++; while(left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right+1]) right--; } } } return res; } } 四数之和 # 先做了三数之和，感觉四数之和没那么难了，自主做出来了，多了个 for 循环和 target 值，其他也没啥，处理好细节就好了，代码如下：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 注意，如果 num[0] 是负数的话，要另外考虑，所以多一个 nums[0] \u0026gt; 0 情况的考虑 if (nums[0] \u0026gt; 0 \u0026amp;\u0026amp; nums[0] \u0026gt; target) { return res; } for (int i = 0; i \u0026lt; nums.length; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) { // 去重 i continue; } for (int j = i+1; j \u0026lt; nums.length; j++) { if (j \u0026gt; i+1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) { // 去重 j continue; } int left = j + 1; int right = nums.length - 1; while (left \u0026lt; right) { int temp = nums[i] + nums[j] + nums[left] + nums[right]; if (temp \u0026gt; target) { right--; } else if (temp \u0026lt; target) { left++; } else { res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); left++; right--; while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left-1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right+1]) right--; } } } } return res; } } "},{"id":54,"href":"/notes/leetcode/day008-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Day008 第四章字符串","section":"代码随想录刷题","content":" 今天刷的题 # 344. 反转字符串\n541. 反转字符串 II\n剑指 Offer 05. 替换空格\n151. 反转字符串中的单词\n剑指 Offer 58 - II. 左旋转字符串\n总结 # 反转字符串 # 没啥可说的，反着 for 循环，然后记录即可。\nclass Solution { public void reverseString(char[] s) { int leftIndex = 0; int rightIndex = s.length-1; while (leftIndex \u0026lt; rightIndex) { char temp = s[leftIndex]; s[leftIndex++] = s[rightIndex]; s[rightIndex--] = temp; } } } 反转字符串|| # 这题没写出来，总结下主要思想，主要的思想方法有三个：\n寻找 firstK 和 secondK 的位置 切片，反转 start 到 firstK 的元素 加入 StringBuffer class Solution { public String reverseStr(String s, int k) { StringBuffer res = new StringBuffer(); int start = 0; int length = s.length(); while (start \u0026lt; length) { StringBuffer temp = new StringBuffer(); int firstK = (start + k \u0026gt; length) ? length : start + k; // 第一k 结束的位置 int secondK = (start + (2 * k) \u0026gt; length) ? length : start + (2 * k); // 第二k 结束位置 temp.append(s.substring(start, firstK)); res.append(temp.reverse()); // 如果 firstK \u0026gt; secondK ， 则这些元素已经添加过了，也就是最后的元素数量 \u0026gt; k ， 但是 \u0026lt; 2k if (firstK \u0026lt; secondK) { res.append(s.substring(firstK, secondK)); } start += (2 * k); } return res.toString(); } } 替换空格 # 没什么可说的，用一个 StringBuffer 再遍历一下解决。\nclass Solution { public String replaceSpace(String s) { StringBuffer res = new StringBuffer(); for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39; \u0026#39;) { res.append(\u0026#34;%20\u0026#34;); } else { res.append(s.charAt(i)); } } return res.toString(); } } 反转字符串中的单词 # 这道题卡了好久，好在写出来了，主要涉及好多没考虑到的细节耽误太多时间了。主要方法如下：\n设计一个 StartS 指针，去除字符串开始的空格部分，也就是找到字符串正式开始的下标； 设计两个指针 start 和 endIndex，记录从后遍历，每个单词的开始和结束位置 注意去除中间的多余的空格 具体代码如下：\nclass Solution { public String reverseWords(String s) { StringBuffer res = new StringBuffer(); int endIndex = s.length()-1; int startS = 0; while (startS \u0026lt;= endIndex \u0026amp;\u0026amp; s.charAt(startS) == \u0026#39; \u0026#39;) { startS++; } while (endIndex \u0026gt;= startS) { while (endIndex \u0026gt; startS \u0026amp;\u0026amp; s.charAt(endIndex) == \u0026#39; \u0026#39;) { endIndex--; } int start = endIndex - 1; while (start \u0026gt;= startS \u0026amp;\u0026amp; s.charAt(start) != \u0026#39; \u0026#39;) { start--; } res.append(s.substring(start+1, endIndex+1)); endIndex = start; if (start \u0026gt; startS) res.append(\u0026#39; \u0026#39;); } return res.toString(); } } 左旋转字符串 # 这一题前一天晚上就看了，没有思路，就看了题解，有一个取余的方法很是感兴趣。除此之外，还看到啦另一种方法，即先整体反转，再局部反转。\nclass Solution { public String reverseLeftWords(String s, int n) { int length = s.length(); StringBuffer res = new StringBuffer(); for (int i = n; i \u0026lt; length + n; i++) { res.append(s.charAt( (i + length) % length )); } return res.toString(); } } "},{"id":55,"href":"/notes/leetcode/day009-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Day009 第四章字符串","section":"代码随想录刷题","content":"今天的任务主要是复习双指针算法，以及了解 KMP 算法\n双指针\nKMP\n"},{"id":56,"href":"/notes/leetcode/day010-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","title":"Day010 第五章栈与队列","section":"代码随想录刷题","content":" 今天刷的题 # 学习栈和队列的理论知识 232.用栈实现队列 225.用队列实现栈 总结 # 题目之前做过，今天做挺快的，很快就刷完了，并且一次AC。\n用栈实现队列 # 这里主要用两个栈 stackIn 和 stackOut：\n正常 push，入 stackIn 取元素时，以及判空时，先检查 stackOut 是否为空，不空取元素，空的话将 stackIn 中的元素全部放入再返回 代码如下：\nclass MyQueue { Stack\u0026lt;Integer\u0026gt; stackIn = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Integer\u0026gt; stackOut = new Stack\u0026lt;\u0026gt;(); public MyQueue() { } public void push(int x) { stackIn.push(x); } public int pop() { if (stackOut.isEmpty()) { // 一个栈移到另一个栈 while (!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } } return stackOut.pop(); } public int peek() { if (stackOut.isEmpty()) { // 一个栈移到另一个栈 while (!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } } return stackOut.peek(); } public boolean empty() { if (stackOut.isEmpty()) { // 一个栈移到另一个栈 while (!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } } return stackOut.isEmpty(); } } 用队列实现栈 # 虽然题目说用两个队列，这里只用一个队列就可以了。这里添加元素什么的都正常，删除和查看 top 元素时，先取元素添加，执行 size - 1 次，这样下次取元素就是 top 元素了，具体如下：\nclass MyStack { Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;Integer\u0026gt;(); public MyStack() { } public void push(int x) { queue.offer(x); } public int pop() { for (int i = 0; i \u0026lt; queue.size() - 1; i++) { queue.offer(queue.poll()); } return queue.poll(); } public int top() { for (int i = 0; i \u0026lt; queue.size() - 1; i++) { queue.offer(queue.poll()); } int res = queue.peek(); queue.offer(queue.poll()); return res; } public boolean empty() { return queue.isEmpty(); } } "},{"id":57,"href":"/notes/leetcode/day011-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","title":"Day011 第五章栈与队列","section":"代码随想录刷题","content":" 今天刷的题 # 有效的括号 1047. 删除字符串中的所有相邻重复项 150. 逆波兰表达式求值 总结 # 目前所遇到的栈与队列相关的题目感觉还都是比较简单的。\n有效的括号 # 用一个栈，遍历所有括号，放入栈，同时，一旦发现栈顶的括号与当前放入的括号匹配，则立马出栈。代码如下：\nclass Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; characters = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { if (!characters.isEmpty()) { if (s.charAt(i) == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; characters.peek() == \u0026#39;[\u0026#39;) { characters.pop(); } else if (s.charAt(i) == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; characters.peek() == \u0026#39;(\u0026#39;) { characters.pop(); } else if (s.charAt(i) == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; characters.peek() == \u0026#39;{\u0026#39;) { characters.pop(); } else { characters.push(s.charAt(i)); } } else { characters.push(s.charAt(i)); } } return characters.isEmpty(); } } 删除字符串中的所有相邻重复项 # 和上一题思想差不多，都是入栈，入的同时观察栈顶元素是否与当前要入的元素相同，相同的话则立马出栈，代码如下：\nclass Solution { public String removeDuplicates(String s) { StringBuffer res = new StringBuffer(); for (int i = 0; i \u0026lt; s.length(); i++) { if (res.length() != 0 \u0026amp;\u0026amp; s.charAt(i) == res.charAt(res.length()-1)) { res.delete(res.length()-1, res.length()); } else { res.append(s.charAt(i)); } } return res.toString(); } } 逆波兰表达式求值 # 和前两题思想一样，大同小异。一样入栈，遍历字符串数组，一旦发现即将入栈的事运算符，则立马取出栈顶元素，让其与运算符后面的一个元素进行运算，运算结果存入栈中。代码如下：\nclass Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt; res = new Stack\u0026lt;\u0026gt;(); int temp = 0; for (int i = 0; i \u0026lt; tokens.length; i++) { if (tokens[i].equals(\u0026#34;+\u0026#34;)) { temp = res.pop() + res.pop(); res.push(temp); } else if (tokens[i].equals(\u0026#34;*\u0026#34;)) { temp = res.pop() * res.pop(); res.push(temp); } else if (tokens[i].equals(\u0026#34;/\u0026#34;)) { int num1 = res.pop(); int num2 = res.pop(); temp = num2 / num1; res.push(temp); } else if (tokens[i].equals(\u0026#34;-\u0026#34;)) { int num1 = res.pop(); int num2 = res.pop(); temp = num2 - num1; res.push(temp); } else { res.push(Integer.parseInt(tokens[i])); } } return res.pop(); } } "},{"id":58,"href":"/notes/leetcode/day013-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","title":"Day013 第五章栈与队列","section":"代码随想录刷题","content":" 今天刷的题 # 滑动窗口最大值\n前 K 个高频元素\n总结 # 两题都是属于困难级别的题目，也都没有做出来。并且理解的时候也还比较困难，需要点时间去消化。\n滑动窗口最大值 # 解题用的算法是单调队列，之前从没接触过，主要需要了解单调队列怎么去写，怎么去维护值的更新，哪些值需要去维护。\nclass Solution { public int[] maxSlidingWindow(int[] nums, int k) { int[] res = new int[nums.length - k + 1]; MonotoneQueue monotoneQueue = new MonotoneQueue(); for (int i = 0; i \u0026lt; k; i++) { monotoneQueue.push(nums[i]); } for (int i = k; i \u0026lt; nums.length; i++) { res[i-k] = monotoneQueue.front(); monotoneQueue.pop(nums[i-k]); monotoneQueue.push(nums[i]); } res[nums.length-k] = monotoneQueue.front(); return res; } } public class MonotoneQueue { private Deque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;\u0026gt;(); void pop(int value) { if (value == deque.getFirst()) { deque.pollFirst(); } } void push(int value) { while (!deque.isEmpty() \u0026amp;\u0026amp; deque.peekLast() \u0026lt; value) { deque.pollLast(); } deque.addLast(value); } int front() { return deque.peekFirst(); } } 前 K 个高频元素 # 暂时还不是很理解这题。后面还需要花时间来消化，为了让其比较完整，我这里先直接贴上卡哥的代码吧：\n/*Comparator接口说明: * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面 * 对于队列：排在前面意味着往队头靠 * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆）， * 从队头到队尾按从大到小排就是最大堆（大顶堆）---\u0026gt;队头元素相当于堆的根节点 * */ class Solution { //解法1：基于大顶堆实现 public int[] topKFrequent1(int[] nums, int k) { Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();//key为数组元素值,val为对应出现次数 for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数 //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((pair1, pair2)-\u0026gt;pair2[1]-pair1[1]); for(Map.Entry\u0026lt;Integer,Integer\u0026gt; entry:map.entrySet()){//大顶堆需要对所有元素进行排序 pq.add(new int[]{entry.getKey(),entry.getValue()}); } int[] ans = new int[k]; for(int i=0;i\u0026lt;k;i++){//依次从队头弹出k个,就是出现频率前k高的元素 ans[i] = pq.poll()[0]; } return ans; } //解法2：基于小顶堆实现 public int[] topKFrequent2(int[] nums, int k) { Map\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();//key为数组元素值,val为对应出现次数 for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数 //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((pair1,pair2)-\u0026gt;pair1[1]-pair2[1]); for(Map.Entry\u0026lt;Integer,Integer\u0026gt; entry:map.entrySet()){//小顶堆只需要维持k个元素有序 if(pq.size()\u0026lt;k){//小顶堆元素个数小于k个时直接加 pq.add(new int[]{entry.getKey(),entry.getValue()}); }else{ if(entry.getValue()\u0026gt;pq.peek()[1]){//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个) pq.poll();//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了 pq.add(new int[]{entry.getKey(),entry.getValue()}); } } } int[] ans = new int[k]; for(int i=k-1;i\u0026gt;=0;i--){//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多 ans[i] = pq.poll()[0]; } return ans; } } "},{"id":59,"href":"/notes/leetcode/day014-%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"Day014 第六章二叉树","section":"代码随想录刷题","content":" 今天刷的题 # 二叉树的前序遍历\n二叉树的后序遍历\n二叉树的中序遍历\n总结 # 今天的题不按照题来总结了，按照方法来总结，因为每一道题都有三种相同的解决方法。\n递归法 # 针对这三道题，递归方法来遍历解答比较统一，每个不同的仅有顺序。具体代码如下：\n// 前序遍历 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); preorder(root, res); return res; } public void preorder(TreeNode treeNode, List\u0026lt;Integer\u0026gt; res) { if (treeNode == null) return; res.add(treeNode.val); preorder(treeNode.left, res); preorder(treeNode.right, res); } } // 中序遍历 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); inorder(root, res); return res; } public void inorder(TreeNode treeNode, List\u0026lt;Integer\u0026gt; res) { if (treeNode == null) return; inorder(treeNode.left, res); res.add(treeNode.val); inorder(treeNode.right, res); } } // 后序遍历 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); postorder(root, res); return res; } public void postorder(TreeNode treeNode, List\u0026lt;Integer\u0026gt; res) { if (treeNode == null) return; postorder(treeNode.left, res); postorder(treeNode.right, res); res.add(treeNode.val); } } 迭代法 # 迭代法需要开辟一个栈，利用栈来遍历二叉树，前序遍历的入栈顺序是“右左“，后序遍历和前序遍历仅仅顺序不一样。中序遍历需要指针来做特别处理，因为前序遍历的处理顺序和访问顺序是一样的，但是中序遍历不一样，需要先一层一层的到达最底层，然后再来做处理，所以中序遍历需要做特别处理。\n// 前序遍历 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return res; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return res; } } // 中序遍历 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); if (root != null) stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node != null) { if (node.right != null) stack.push(node.right); stack.push(node); stack.push(null); if (node.left != null) stack.push(node.left); } else { node = stack.pop(); res.add(node.val); } } return res; } } // 后序遍历 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return res; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } Collections.reverse(res); return res; } } 统一迭代法 # 觉得比迭代法好使用也好理解，和递归的样，写法比较一致，没有什么需要特别考虑和处理的。\n// 前序遍历 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); if (root != null) stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node != null) { if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); stack.push(node); stack.push(null); } else { node = stack.pop(); res.add(node.val); } } return res; } } // 中序遍历 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); if (root != null) stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node != null) { if (node.right != null) stack.push(node.right); stack.push(node); stack.push(null); if (node.left != null) stack.push(node.left); } else { node = stack.pop(); res.add(node.val); } } return res; } } // 后序遍历 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); if (root != null) stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node != null) { stack.push(node); stack.push(null); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } else { node = stack.pop(); res.add(node.val); } } return res; } } "},{"id":60,"href":"/notes/leetcode/day015-%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"Day015 第六章二叉树","section":"代码随想录刷题","content":" 今天刷的题 # 102.二叉树的层序遍历 # 107.二叉树的层次遍历II # 226.翻转二叉树 # 101. 对称二叉树 # 总结 # 二叉树的层序遍历 # 最终要求返回的结果是嵌套的 List，外层 List 存放层，内层 List 存放数值，用一个计数器记录层数，然后再用递归方法来解决。具体代码如下：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; int levelNum = 0; levelOrderProcess(root, res, levelNum); return res; } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrderProcess(TreeNode node, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int levelNum) { levelNum++; // 表示层数 if (res.size() \u0026lt; levelNum) { // 让层数和 size 保持一致 List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); res.add(level); } res.get(levelNum-1).add(node.val); // 将值添加到对应的层级 if (node.left != null) levelOrderProcess(node.left, res, levelNum); // 向下递归 if (node.right != null) levelOrderProcess(node.right, res, levelNum); // 向下递归 return res; } } Collections.reverse(res);\n二叉树的层次遍历II # 具体思想同上，仅仅多一个 Collections.reverse(res);。\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrderBottom(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; int levelNum = 0; levelOrderProcess(root, res, levelNum); Collections.reverse(res); return res; } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrderProcess(TreeNode node, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int levelNum) { levelNum++; // 表示层数 if (res.size() \u0026lt; levelNum) { // 让层数和 size 保持一致 List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); res.add(level); } res.get(levelNum-1).add(node.val); // 将值添加到对应的层级 if (node.left != null) levelOrderProcess(node.left, res, levelNum); // 向下递归 if (node.right != null) levelOrderProcess(node.right, res, levelNum); // 向下递归 return res; } } 翻转二叉树 # 这道题很奇妙，前序遍历和后序遍历都可以，但是中序遍历就是不行，我不是很理解，为什么中序遍历不可以，卡哥说中序遍历的话，有些节点可能会交换两次。 递归三要素：\n返回值和参数：根节点，参数为节点；\n终止条件：节点为空；\n单层处理：交换节点;\nTreeNode temp = node.left; node.lefet = node.right; node.right = node.temp; invertTree(root.left); invertTree(root.right); 代码如下：\nclass Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return root; // 交换节点：前序遍历 // TreeNode cur = root.left; // root.left = root.right; // root.right = cur; invertTree(root.left); invertTree(root.right); // 交换节点：后序遍历 TreeNode cur = root.left; root.left = root.right; root.right = cur; return root; } } 对称二叉树 # 暂时还不是很理解，先根据递归三要素过一遍，二刷再着重理解，最近也比较忙。\n返回值和参数：返回值为布尔值，参数为节点\n终止条件：\n空：空有三种情况\n左空有空：true 左空右不空：false 左不空右空：false 不空：不空有两种情况：\n数值相等：true 数值不等：false 单层逻辑\n当为 true 时需要逻辑处理。这里我还是贴上卡哥的吧，因为我看卡哥的能理解，但是让我自己写的话我就是写不出来。\n此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。\n比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。 比较内测是否对称，传入左节点的右孩子，右节点的左孩子。 如果左右都对称就返回true ，有一侧不对称就返回false 。 代码如下：\nbool outside = compare(left-\u0026gt;left, right-\u0026gt;right); // 左子树：左、 右子树：右 bool inside = compare(left-\u0026gt;right, right-\u0026gt;left); // 左子树：右、 右子树：左 bool isSame = outside \u0026amp;\u0026amp; inside; // 左子树：中、 右子树：中（逻辑处理） return isSame; 如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。\npublic boolean isSymmetric1(TreeNode root) { return compare(root.left, root.right); } private boolean compare(TreeNode left, TreeNode right) { if (left == null \u0026amp;\u0026amp; right != null) { return false; } if (left != null \u0026amp;\u0026amp; right == null) { return false; } if (left == null \u0026amp;\u0026amp; right == null) { return true; } if (left.val != right.val) { return false; } // 比较外侧 boolean compareOutside = compare(left.left, right.right); // 比较内侧 boolean compareInside = compare(left.right, right.left); return compareOutside \u0026amp;\u0026amp; compareInside; } "},{"id":61,"href":"/notes/leetcode/day017-%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"Day017 第六章二叉树","section":"代码随想录刷题","content":" 今天刷的题 # 二叉树的最大深度 # 111.二叉树的最小深度 # 222. 完全二叉树的节点个数 # 总结 # 最近事比较多，打算把进度补上，不然压着好难受呀，但是事情确实又比较多。同时我发现一个问题，二叉树这一块，很多方法模版，递归、迭代、同一递归等等，但是都掌握的话时间又不够，到近期刷题感觉很乱。所以现在一刷我不求那么多，指掌握递归吧。\n二叉树的最大深度 # 用前序遍历和后序遍历都可以，中序遍历没有试过。\nclass solution { /** * 递归法 */ public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; } } 二叉树的最小深度 # 也是前序后序都可以，我也没做出来，卡哥的代码写的太精简了，忍不住想贴上来。\nclass Solution { /** * 递归法，相比求MaxDepth要复杂点 * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量 */ public int minDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) { return rightDepth + 1; } if (root.right == null) { return leftDepth + 1; } // 左右结点都不为null return Math.min(leftDepth, rightDepth) + 1; } } 完全二叉树的节点个数 # 同样也是没写出来，这里我暂时也只要求自己掌握递归的写法：\nclass Solution { // 通用递归解法 public int countNodes(TreeNode root) { if(root == null) return 0; // 这里相当于后序遍历 return countNodes(root.left) + countNodes(root.right) + 1; } } "},{"id":62,"href":"/notes/spring/nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","title":"Nacos 配置中心","section":"Spring","content":" 1. Nacos 作为配置中心步骤 # 1.1 引入依赖 # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bootstrap\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.2 创建一个 bootstrap.properties # spring.cloud.nacos.config.server-addr=127.0.0.1:8848 # nacos 服务地址 spring.application.name=gulimall-coupon # 应用名 1.3 添加配置中心数据集 # 给配置中心添加一个数据集（Data Id），默认是应用名.properties\n1.4 动态获取配置 # @RefreshScope：动态获取并刷新配置\n@Value(\u0026quot;${配置项名}\u0026quot;)：获取到配置\n如果配置中心和当前应用配置文件中都设置了相同的项，优先使用配置中心的配置。\n@RefreshScope\t// 动态获取并刷新配置 @RestController @RequestMapping(\u0026#34;coupon/coupon\u0026#34;) public class CouponController { @Autowired private CouponService couponService; @Value(\u0026#34;${coupon.user.name}\u0026#34;) // 获取到配置 private String username; @Value(\u0026#34;${coupon.user.age}\u0026#34;) private Integer age; ... } 2. 详细了解 # 2.1 命名空间 # 用于进行配置隔离，不用命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置区分隔离，例如开发环境和生产环境的资源隔离等。默认配置空间是 public。\n例子：\n2.1.1 场景一：基于环境隔离 # 如：开发、测试、生产分别创建配置空间：dev, test, prop。然后在bootstrap.properties添加如下行来切换对应的环境\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.application.name=gulimall-coupon spring.cloud.nacos.config.namespace=f72147a8-98c1-49d2-8449-aa02efb7745c # 添加对应的配置空间ID 2.1.2 场景二：基于微服务隔离 # 每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置。具体操作和基于环境隔离无异，只不过配置组织方式有区别。\n2.2 配置集 # 一组相关或者不相关的配置集合称为配置集。\n2.3 配置集 ID： # 类似文件名\n2.4 配置分组 # 默认所有配置集都属于：DEFAULT_GROUP，同一命名空间，不同分组的配置集ID可以相同。比如同一命名空间，同一配置集ID，但不同分组，一个用于618，一个用于双11。但注意，bootstrap.properties 文件中需要指明所对应的配置分组，如下：\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.application.name=gulimall-coupon spring.cloud.nacos.config.namespace=f72147a8-98c1-49d2-8449-aa02efb7745c # 指定命名空间，不指定默认 public spring.cloud.nacos.config.group=618 # 指定配置分组，不指定默认 DEFAULT_GROUP 3. 同时加载多个配置集 # 微服务中的任何配置文件都可以放在配置中心中（bootstrap.properties 除外），只需要在 bootstrap.properties 中说明加载配置中心的那些配置文件即可。可以使用 @Value 、@ConfigurationProperties 等来获取值。配置中心有的配置，优先使用配置中心的。\n比如和数据源有关的配置写在 datasource.yml 中，和 Mybatis 相关的配置写在 mybatis.yml 中等。\n示例：将 application.yml 中的配置搬到 Nacos # 将 datasource 相关搬到到 datasource.yml，mybatis 相关搬到 mybatis.yml，其他相关配置放 others.yml。如下：\n# datasource.yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/gulimall_sms username: root password: root # mybatis.yml mybatis-plus: mapper-locations: classpath:/mapper/**/*.xml global-config: db-config: id-type: auto # mybatis.yml spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 service: gulimall-coupon server: port: 7001 bootstrap.properties 中导入配置\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.application.name=gulimall-coupon spring.cloud.nacos.config.namespace=098fb942-16b7-431d-a65b-dc0d7db308df spring.cloud.nacos.config.group=prop # datasource.yml spring.cloud.nacos.config.extension-configs[0].data-id=datasource.yml spring.cloud.nacos.config.extension-configs[0].group=dev spring.cloud.nacos.config.extension-configs[0].refresh=true # mybatis.yml spring.cloud.nacos.config.extension-configs[1].data-id=mybatis.yml spring.cloud.nacos.config.extension-configs[1].group=dev spring.cloud.nacos.config.extension-configs[1].refresh=true # others.yml spring.cloud.nacos.config.extension-configs[2].data-id=others.yml spring.cloud.nacos.config.extension-configs[2].group=dev spring.cloud.nacos.config.extension-configs[2].refresh=true "},{"id":63,"href":"/notes/spring/open-feign-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B/","title":"Open Feign 远程调用示例","section":"Spring","content":"官方文档有个特别简单的快速入门示例： 官方示例，这里我就我的项目总结一般使用步骤。\n导入依赖 # \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 声明接口，并使用 # 注意使用注解@FeignClient(\u0026quot;gulimall-coupon\u0026quot;) # @FeignClient(\u0026#34;gulimall-coupon\u0026#34;) // 要调用的模块名 public interface CouponFeignService { @RequestMapping(\u0026#34;coupon/coupon/member/list\u0026#34;) // 这里是 controller 中方法的引用，但是值要换成全路径 public R memberCoupon(); } contrller 如下：\n@RestController @RequestMapping(\u0026#34;member/member\u0026#34;) public class MemberController { // 被调用的方法 @RequestMapping(\u0026#34;/coupons\u0026#34;) public R test() { return R.ok().put(\u0026#34;coupons\u0026#34;, couponFeignService.memberCoupon().get(\u0026#34;coupon\u0026#34;)); } } 调用接口 # @RestController @RequestMapping(\u0026#34;member/member\u0026#34;) public class MemberController { @Autowired CouponFeignService couponFeignService; @RequestMapping(\u0026#34;/coupons\u0026#34;) public R test() { return R.ok().put(\u0026#34;coupons\u0026#34;, couponFeignService.memberCoupon().get(\u0026#34;coupon\u0026#34;)); } } 开启远程接口调用 # @EnableFeignClients(basePackages = \u0026#34;com.atguigu.gulimall.member.feign\u0026#34;) // 开启远程接口调用 @MapperScan(\u0026#34;com/atguigu/gulimall/member/dao\u0026#34;) @SpringBootApplication @EnableDiscoveryClient public class GulimallMemberApplication { public static void main(String[] args) { SpringApplication.run(GulimallMemberApplication.class, args); } } "},{"id":64,"href":"/notes/spring/springboot-%E6%95%B4%E5%90%88-mybatis-plus/","title":"Spring Boot 整合 My Batis Plus","section":"Spring","content":" 导入依赖 # \u0026lt;!-- mybatis-plus 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置 # 配置注解数据源 # @MapperScan(\u0026#34;XXXX/XXXXX/XXXX/dao\u0026#34;) @SpringBootApplication public class XXXXXApplication { public static void main(String[] args) { SpringApplication.run(XXXXXApplication.class, args); } } 配置 yml 文件 # # mysql 连接 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/gulimall_wms username: root password: root # mybatis-plus 配置 mybatis-plus: mapper-locations: classpath:/mapper/**/*.xml\t# xml 映射文件 global-config: db-config: id-type: auto # 主键自增 "},{"id":65,"href":"/notes/swift/swiftui-%E5%B8%B8%E7%94%A8%E8%A7%86%E5%9B%BE-views/","title":"Swift Ui 常用视图 Views","section":"Swift","content":" SwiftUI 的常用视图 # 1 文本视图 # 1.1 文本 Text # Text(\u0026#34;文字\u0026#34;) 1.2 标签 Label # Label(\u0026#34;文字\u0026#34;, systemImage: \u0026#34;SF Symbols 图标名称\u0026#34;) 1.3 文本框 TextField # @State var input = \u0026#34;\u0026#34; var body: some View { TextField(\u0026#34;占位文字\u0026#34;, text: $input) } 1.4 安全文本框 SecureField # @State var input = \u0026#34;\u0026#34; var body: some View { SecureField(\u0026#34;占位文字\u0026#34;, text: $input) } 1.5 链接 Link # Link(\u0026#34;说明文字\u0026#34;, destination: URL(string: \u0026#34;https://baidu.com\u0026#34;)!) 1.6 文本编辑器 # @State var input = \u0026#34;\u0026#34; var body: some View { TextEditor(text: $input) } 2 排版视图 # 2.1 纵向排列 VStack # VStack { View() View() } 2.2 横向排列 HStack # HStack { View() View() } 2.3 重叠排列 ZStack # ZStack { View() View() } 2.4 成组 Group # 可以把 Group 成组视图当作是视图的文件夹，用其对视图进行归类，从而让代码变得更易读。\nVStack { Group { View() View() Group { View() View() } } 2.5 留白 Spacer # Spacer() 2.6 分割线 Divider # Divider() 2.7 空视图 EmptyView # EmptyView() # 3 绘图视图 # 3.1 图片及图标 Image # Image(\u0026#34;图片名称\u0026#34;) Image(systemName: \u0026#34;SF Symbols 名称\u0026#34;) 3.2 图形 Shape # Rectangle() RoundedRectangle(cornerRadius: 25, style: .continuous) Circle() Capsule() Ellipse() "},{"id":66,"href":"/notes/swift/swiftui-%E4%BF%A1%E6%81%AF%E8%A7%86%E5%9B%BE-views/","title":"Swift Ui 信息视图 Views","section":"Swift","content":" SwiftUI 信息视图 Views # 列表 List # List { FirstView() SecondView() } 观察上图，会发现高亮区域的每一个子视图中间都有一条横线，该分割线是 SwiftUI 列表的一部分，会由系统负责自动添加。列表的语法是 List { }，其中花括号区域放置子视图即可。我把上一篇文章中制作的子视图 CardView() 放置在列表中，结果如下图所示。子视图被从上至下罗列出来，中间还被添加了分割线。\n网格 Grid # let rule = [GridItem(.adaptive(minimum: 220))] var body: some View { LazyVGrid(columns: rule, spacing: 20) { } } 循环 ForEach # var targetDurations = [\u0026#34;15 分钟\u0026#34;, \u0026#34;30 分钟\u0026#34;, \u0026#34;1 小时\u0026#34;, \u0026#34;2 小时\u0026#34;,\u0026#34;3 小时\u0026#34;] var body: some View { VStack { ForEach(0..\u0026lt;targetDurations.count) { Text(self.targetDurations[$0]) } } } 成组框 GroupBox # GroupBox(label: Label(\u0026#34;创作简介\u0026#34;, systemImage: \u0026#34;pencil.tip\u0026#34;)) { } 成组框是 iOS 14 之后新增的一种视图类型，可以把它看作是 Apple 为我们提供好的预设排版方式，它适合呈现卡片型的信息。如下图 iOS 的健康应用中，就大幅使用了成组框视图。\n如下图所示，成组框的外观由两部分组成，分别是上面的标签和底部的内容。它的语法为 GroupBox(label: Label(\u0026quot;\u0026quot;, systemImage: \u0026quot;\u0026quot;)) { }，其中参数 label 指的是我们之前学习的图标和文字的混合视图，花括号 { } 中可以放置卡片下方的内容，内容可以是任意视图或其组合。\n表单 Form # Form { Section(header: Text(\u0026#34;每日目标\u0026#34;)){ } } 表单常被使用在应用的设置中，比如下图中 iOS 的系统设置、闹钟时间和音量的调整等，用到的都是 Form 视图。若你的表单视图仅具备一些按钮或文字说明，这些内容不需要跳转至其它位置，则表单视图可以单独使用。若你的表单具备如下图所示的层级选项，你可以将整个表单视图放在导航器视图 NavigationView 中，来为这些设置提供层级关系。\n表单视图的语法为 Form { }，你可以在花括号中放置任意子视图。为帮助我们整理表单中的内容，SwiftUI 还提供了帮助将内容转化为不同区块的 Section(header: ) 其中 header 参数后可以跟文本视图。\n在下图中，我将前几篇文章中学到的常用视图如文本，控制视图如开关和按钮，层级视图如导航器组合在一起，并通过信息视图组合在表单中。下图中的「每日目标，帮助与反馈」将表单中的区块说明，底部包含了一些按钮用于跳转至帮助文档。\n"},{"id":67,"href":"/notes/swift/swiftui-%E5%B1%82%E7%BA%A7%E8%A7%86%E5%9B%BE-views/","title":"Swift Ui 层级视图 Views","section":"Swift","content":" SwiftUI 层级视图 Views # 官方文档\nTabView { Text(\u0026#34;1.选项卡内容\u0026#34;) .tabItem { Image(systemName: \u0026#34;scroll\u0026#34;) Text(\u0026#34;Scroll\u0026#34;) } Text(\u0026#34;2.选项卡内容\u0026#34;) .tabItem { Image(systemName: \u0026#34;network\u0026#34;) Text(\u0026#34;Navigation\u0026#34;) } } ![](https://gitee.com/pp-tt/blogImage/raw/master/202202211646718.png) ### 滑动视图 ScrollView [官方文档](https://developer.apple.com/documentation/swiftui/scrollview) ```swift ScrollView(.vertical, showsIndicators: false) { } 导航器 NavigationView # 官方文档\nNavigationView { VStack { VStack(spacing: 30) { NavigationLink(destination: SomeView()) { Text(\u0026#34;点击跳转\u0026#34;) } } } .navigationBarTitle(\u0026#34;项目列表\u0026#34;, displayMode: .automatic)) .navigationBarItems( leading: Button(\u0026#34;左侧按钮\u0026#34;) { }, trailing: Button(\u0026#34;右侧按钮\u0026#34;) { } ) } **为导航器视图添加标题：**为导航器添加标题的语法是 .navigationBarTitle(\u0026quot;项目列表\u0026quot;, displayMode: .automatic))，可以理解为添加一个名为「项目列表」的标题，并自动设置标题的字体。若你需要如上图所示的加粗大字体，则可以将 displayMode 的参数设置为 .large，若你喜欢小字体，则可以设置为 .inline，若你希望将字体大小交由系统决定，可设置为 .automatic。\n**为导航器视图添加顶部按钮：**为导航器顶部添加按钮的语法是 .navigationBarItems(leading:, trailing) ，其中 leading: 代表向顶部左侧添加按钮，trailing: 代表向顶部右侧添加按钮。leading: 或 trailing: 的冒号后方需要添加按钮视图。\n**让导航器视图跳转至其它视图：**导航器视图最核心的用途是从现有视图跳转到另一个视图中，并自动提供从被跳转视图返回原视图的路径。其跳转的方式是一种特殊的链接，叫做 NavigationLink。比如代码 NavigationLink(destination: SomeView()) { Text(\u0026quot;点击跳转\u0026quot;) }，其目的是将现有的文字「点击跳转」设置为导航器跳转链接，用户点击后会跳转至目的地视图 SomeView()。\n长弹窗 Modal # @State var showModal = false var body: some View { Button(action: { showModal.toggle() }) { Text(\u0026#34;显示「长弹窗」\u0026#34;) }.sheet(isPresented: $showModal) { SomeView() } } 行动列表 ActionSheet # @State var showActionSheet = false var body: some View { Button(action: { showActionSheet.toggle() }) { Text(\u0026#34;显示「行动列表」\u0026#34;) } .actionSheet(isPresented: $showActionSheet) { ActionSheet(title: Text(\u0026#34;要执行什么操作？\u0026#34;), message: Text(\u0026#34;补充文字说明\u0026#34;), buttons: [ .default(Text(\u0026#34;添加至收藏夹\u0026#34;)) { }, .destructive(Text(\u0026#34;删除项目\u0026#34;)) { }, .cancel() ]) } } 行动列表 ActionSheet 的语法 ActionSheet(title: Text(\u0026quot;要执行什么操作？\u0026quot;), message: Text(\u0026quot;补充文字说明\u0026quot;) 中，title 参数指的是行动列表的标题文字，message 参数指的是让用户加深了解你询问问题的补充说明。ActionSheet 的显示也需要一个布尔值来告知真伪，这一点与长弹窗一致，不再赘述。\n对于行动列表来说，核心点在于我们可以为用户提供哪些选项按钮，用户点按后会发生什么。为此，Apple 给我们提供了三种按钮选择，分别是 .default 、.destructive、.cancel。其中 .default 指的是上图中蓝色的默认选项，用户点击后会发生某种改变；.destructive 指的是该选项可能造成严重后果，系统会使用红色显示来警示用户；取消 .cancel 是独立于选择之外的按钮，指的是不做出选择并关闭行动列表。\n知识回顾：用户此时也许还没准备好做出选择，此处的取消按钮是基于交互设计的考量。\n警告 Alert # @State var showAlert = false var body: some View { Button(action: { showAlert.toggle() }) { Text(\u0026#34;显示「允许用户选择的警告」\u0026#34;) } .alert(isPresented: $showAlert) { Alert(title: Text(\u0026#34;删除\u0026#34;), message: Text(\u0026#34;永久删除，确定要继续吗？\u0026#34;), primaryButton: .destructive(Text(\u0026#34;是\u0026#34;)), secondaryButton: .default(Text(\u0026#34;否\u0026#34;))) } } 警告除了可以提供选项，也可以单纯地告知用户某行为的后果。比如下图所示，执行某个指令的时间可能会非常长，在此期间需要用户耐心等待，便可以用到告知型警告。当你用到此类警告时，建议额外增加代码，让该警告在应用安装后只出现一次，出现太多次用户也会感到反感。\n"},{"id":68,"href":"/notes/swift/swiftui-%E6%8E%A7%E5%88%B6%E8%A7%86%E5%9B%BE-views/","title":"Swift Ui 控制视图 Views","section":"Swift","content":" SwiftUI 控制视图 Views # 开关 Toggle # @State var toggleValue = true var body: some View { Toggle(\u0026#34;自动登录\u0026#34;, isOn: $toggleValue) } 按钮 Button # Button(action: { // 此处放置你希望按钮做什么 }, label: { // 此处定制按钮外观 Text(\u0026#34;退出\u0026#34;) }) 选择器 Picker # @State var pickerValue = 0 var pickerOptions = [\u0026#34;步行\u0026#34;, \u0026#34;自行车\u0026#34;, \u0026#34;汽车\u0026#34;] var body: some View { Picker(\u0026#34;Picker\u0026#34;, selection: $pickerValue) { ForEach(0..\u0026lt;pickerOptions.count) { index in Text(pickerOptions[index]).tag(index) } }.pickerStyle(SegmentedPickerStyle()) } 滑动条 Slider # @State var sliderValue = 0.0 var body: some View { Slider(value: $sliderValue, in: -5...5, step: 0.1) } 梯度控制 Stepper # @State var stepperValue = 0 var body: some View { Stepper(\u0026#34;当前数值： \\(stepperValue)\u0026#34;, value: $stepperValue, in: -5...5) } 日期选择 DatePicker # @State var selectedDate = Date() var dateRange: ClosedRange\u0026lt;Date\u0026gt; { let min = Calendar.current.date(byAdding: .day, value: -100, to: Date())! let max = Calendar.current.date(byAdding: .day, value: 100, to: Date())! return min...max } var body: some View { DatePicker( selection: $selectedDate, in: dateRange, displayedComponents: [.hourAndMinute, .date], label: { Text(\u0026#34;截止日期\u0026#34;) }) } 长按菜单 Context Menu # Text(\u0026#34;长按呼出菜单\u0026#34;) .contextMenu { Button(\u0026#34;选项 A\u0026#34;) { } Button(\u0026#34;选项 B\u0026#34;) { } } 载入状态 ProgressView # ProgressView(value: progressValue) .progressViewStyle(CircularProgressViewStyle()) 地图 Map # import SwiftUI import MapKit @State var location = MKCoordinateRegion(center: .init(latitude: 39.9130, longitude: 116.3907), latitudinalMeters: 1000, longitudinalMeters: 1000) var body: some View { Map(coordinateRegion: $location) } 完整代码 # "},{"id":69,"href":"/notes/%E5%85%AB%E8%82%A1/jvm/","title":"Jvm","section":"Java八股","content":" 内存区域 # 运行时数据区域 # Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。\n线程私有的：\n程序计数器 虚拟机栈 本地方法栈 线程共享的：\n堆 方法区 直接内存 (非运行时数据区的一部分) 程序计数器 # 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\nJava 虚拟机栈 # 与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。\n本地方法栈 # 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。\n堆 # Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n方法区 # 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。\n方法区和永久代以及元空间是什么关系呢？ # 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。\n为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢? # 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。 方法区常用参数有哪些？ # JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：\n-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\n运行时常量池 # Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table) 。\n字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。\n字符串常量池 # 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n// 在堆中创建字符串对象”ab“ // 将字符串对象”ab“的引用保存在字符串常量池中 String aa = \u0026#34;ab\u0026#34;; // 直接返回字符串常量池中字符串对象”ab“的引用 String bb = \u0026#34;ab\u0026#34;; System.out.println(aa==bb);// true HotSpot 虚拟机中字符串常量池的实现是 src/hotspot/share/classfile/stringTable.cpp ,StringTable 本质上就是一个HashSet\u0026lt;String\u0026gt; ,容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置）。\nJDK 1.7 为什么要将字符串常量池移动到堆中？ # 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。\n直接内存 # 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。\n对象的创建 # Step1:类加载检查 # 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\nStep2:分配内存 # 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n内存分配的两种方式 （补充内容，需要掌握）：\n指针碰撞 ：\n适用场合 ：堆内存规整（即没有内存碎片）的情况下。 原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。 使用该分配方式的 GC 收集器：Serial, ParNew 空闲列表 ：\n适用场合 ： 堆内存不规整的情况下。 原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。 使用该分配方式的 GC 收集器：CMS 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\u0026quot;标记-清除\u0026quot;，还是\u0026quot;标记-整理\u0026quot;（也称作\u0026quot;标记-压缩\u0026quot;），值得注意的是，复制算法内存也是规整的。\nStep3:初始化零值 # 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\nStep4:设置对象头 # 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\nStep5:执行 init 方法 # 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，\u0026lt;init\u0026gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 \u0026lt;init\u0026gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\nJVM 垃圾回收详解 # 堆空间的基本结构 # 在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：\n新生代内存(Young Generation) 老生代(Old Generation) 永久代(Permanent Generation) 下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。\nJDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存 。\n内存分配和回收原则 # 对象优先在 Eden 区分配 # 大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。\n大对象直接进入老年代 # 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\n大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。\n长期存活的对象将进入老年代 # 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。\n大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-\u0026gt;Survivor 区后对象的初始年龄变为 1)。\n对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\nGC 分类 # 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\n部分收集 (Partial GC)： 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 整堆收集 (Full GC)：收集整个 Java 堆和方法区。 空间分配担保 # 空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。\n《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：\nJDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。\nJDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。\n死亡对象判断方法 # 引用计数法 # 给对象中添加一个引用计数器：\n每当有一个地方引用它，计数器就加 1； 当引用失效，计数器就减 1； 任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n可达性分析算法 # 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\n引用类型总结 # 1．强引用（StrongReference）\n以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n2．软引用（SoftReference）\n如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n3．弱引用（WeakReference）\n如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n4．虚引用（PhantomReference）\n\u0026ldquo;虚引用\u0026quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n虚引用主要用来跟踪对象被垃圾回收的活动。\n虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n如何判断一个常量是废弃常量？ # 假如在字符串常量池中存在字符串 \u0026ldquo;abc\u0026rdquo;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \u0026ldquo;abc\u0026rdquo; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\u0026ldquo;abc\u0026rdquo; 就会被系统清理出常量池了。\n如何判断一个类是无用的类 # 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾回收算法 # 标记清除 # 优点：速度快\n缺点：容易产生较多的内存碎片\n标记整理 # 缺点：效率较低\n优点：避免了内存碎片\n标记复制 # 缺点：占用双倍内存空间\n优点：不会产生内存碎片\n分代回收 # 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n垃圾收集器 # 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\n虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。\nSerial 收集器 # Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \u0026ldquo;Stop The World\u0026rdquo; ），直到它收集结束。\n新生代采用标记-复制算法，老年代采用标记-整理算法。\nParNew 收集器 # ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。\n新生代采用标记-复制算法，老年代采用标记-整理算法。\nParallel Scavenge 收集器 # Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 那么它有什么特别之处呢？\nParallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。\n新生代采用标记-复制算法，老年代采用标记-整理算法。\nSerial Old 收集器 # Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\nParallel Old 收集器 # Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\nCMS 收集器 # CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。\nCMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\nG1 收集器 # G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.\nZGC 收集器 # 与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。\n在 ZGC 中出现 Stop The World 的情况会更少！\n"},{"id":70,"href":"/notes/%E5%85%AB%E8%82%A1/redis/","title":"Redis","section":"Java八股","content":" 什么是 Redis？ # Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。\nRedis 为什么这么快？ # Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：\nRedis 基于内存，内存的访问速度是磁盘的上千倍； Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）； Redis 内置了多种优化过后的数据结构实现，性能非常高。 分布式缓存常见的技术选型方案有哪些？ # 分布式缓存的话，比较老牌同时也是使用的比较多的还是 Memcached 和 Redis。不过，现在基本没有看过还有项目使用 Memcached 来做缓存，都是直接用 Redis。\nMemcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。\n为什么要用 Redis/为什么要用缓存？ # 高性能\n假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\n这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\n高并发\n一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。\n3种常用的缓存读写策略详解 # Cache Aside Pattern（旁路缓存模式） # **Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。**Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\n写 ：\n先更新 db 然后直接删除 cache 。 读 :\n从 cache 中读取数据，读取到就直接返回 cache 中读取不到的话，就从 db 中读取数据返回 再把数据放到 cache 中。 在写数据的过程中，可以先删除 cache ，后更新 db 么？ # 那肯定是不行的！因为这样可能会造成 数据库（db）和缓存（Cache）数据不一致的问题。\nCache Aside Pattern 的缺陷？ # 缺陷 1：首次请求数据一定不在 cache 的问题\n解决办法：可以将热点数据可以提前放入 cache 中。\n缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。\n解决办法：\n数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。 可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。 Read/Write Through Pattern（读写穿透） # Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\n这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。\n写（Write Through）：\n先查 cache，cache 中不存在，直接更新 db。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。 读(Read Through)：\n从 cache 中读取数据，读取到就直接返回 。 读取不到的话，先从 db 加载，写入到 cache 后返回响应。 Write Behind Pattern（异步缓存写入） # Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\n但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\n很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\n"},{"id":71,"href":"/notes/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BB%93/stm32/","title":"Stm32","section":"嵌入式重点总结","content":" 中断系统 # 中断概念 # 中断 # 在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序， 处理完成后又返回原来被暂停的位置继续运行。\n中断优先级 # 当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源。\n中断嵌套 # 当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回\nSTM32中断 # STM32中断优先级非常多，几乎所有的模块都能申请中断。\n68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等。 使用NVIC（嵌套中断向量控制器）统一管理中断，每个中断通道拥有16个可编程优先级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。 NVIC中断优先级有优先级寄存器的4位（0～15，0优先级最高）决定，这四位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级。 抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断向量表中断号排队。 EXTI 外部中断 # EXTI 外部中断概念 # EXTI 可以监测指定 GPIO 口的电平信号，当其指定的 GPIO 产生电平变化时，EXTI将立即向 NVIC 发出中断申请，经过 NVIC 裁决后即可中断 CPU 主程序，使 CPU 执行 EXTI 对应的中断程序。外部中断是众多能产生中断的外设之一。\n触发方式 # 支持上升沿、下降沿、双边沿、软件触发。\n支持的 GPIO 口 # 支持所有 GPIO 口，但是相同的 Pin 不能同时触发中断。\n通道数 # 16 个 GPIO_Pin，外加 PVD 输出、RTC闹钟、USB唤醒、以太网唤醒\n触发响应方式 # 中断响应和事件响应，中断响应是正常流程，引脚变化触发中断；事件响应不会触发中断，而是触发别的外设操作，属于外设之间的联合工作。\n外部中断/事件控制器框图：\n整体结构图：\n其中 AFIO 为中断引脚选择模块，AFIO 主要用于引脚复用的选择和重定义，STM32中AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择。外部中断9~5会触发同一个中断函数，15～10也会触发同一中断函数。针对这两个中断函数，需要根据标志位来区分是哪个中断进来的。\n定时器 # 第一部分：固定一段时间执行一段程序\n第二部分：定时器输出比较，常见用途产生 PWM 波形，用于驱动电机\n第三部分：定时器输入捕获，可以实现测量方波频率\n第四部分：定时器编码器接口，可以方便的读取正交编码器的输出波形，可以应用编码器电机测速\nTIM 定时器 # 定时器对输入的时钟进行计数，并在计数值达到设定值时触发中断（最基本的功能）。 16 位计数器、预分频器、自动重装寄存器的时基单元，在 72MHz 计数时钟下可以实现最大 59.65s 的定时。 计数器（16 位）：即计数定时的一个寄存器，每来一个时钟，计数器+1 预分频器（16 位）：可以对计数器的时钟进行分频，让计数更加灵活 自动重装寄存器（16 位）：计数目标值，即计多少个时钟申请中断 具备定时中断、内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能 根据复杂度和应用场景分为高级定时器、通用定时器、基本定时器。 定时器类型 # 类型 编号 总线 功能 高级定时器 TIM1、TIM8 APB2 拥有通用定时器全部功能，额外具有重复计数器、死区生成、互补输出、刹车输入等功能。 通用定时器 TIM2、TIM3、TIM4、TIM5 APB1 拥有基本定时器全部功能，额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等 基本定时器 TIM6、TIM7 APB1 拥有定时中断、主模式触发DAC的功能 STM32F103CT86定时器资源：TIM1、TIM2、TIM3、TIM4。\n基本定时器 # 框图 ：\n如图，使用的是内部时钟，基本定时器不能连接外部时钟，连接的为内部时钟。 预分频器值（PSC）值和实际分频系数相差1。若PSC为 1 时，输出为 $$ 72M/2=36MHz $$ ；若PSC为 2 时，输出为 $$ 72M/3=24MHz $$ 。PSC 是 16 位的，故最大可以写65535，即 65536 分频系数。预分频器就是对输入的基准频率提前进行一个分频操作。 计数器也是16位，可以对分频后的记数时钟进行记数，计数时钟每来一个上升沿，计数器的值就+1，可以计数最大为65535。计数器会不断运行，计数到目标值时产生中断，这时就完成定时任务了。 自动重装寄存器即存储目标值的寄存器，也是16位，当计数器值自增到等于自动重装值时，也就是计时时间到了，这时候会产生一个中断信号。 主从触发模式是STM32定时器的特色，能让内部硬件在不受程序控制下实现自动运行，掌握主从触发模式，某些情景可以极大的减轻 CPU 的负担。（举例：使用DAC的时候可能会用其输出一段波形，所以需要每隔一段时间触发一次DAC，让它输出下一个电压点；正常思路的话是设置一个定时器产生中断，每隔一段时间在中断程序中调用代码手动触发一次DAC，然后DAC输出，但是这样会让程序处于频繁中断状态，会影响主程序和其他程序运行。定时器设计了主模式，可以把定时器的更新事件映射到TRGO，然后TRGO直接接到DAC触发转换引脚上，然后TRGO就会直接去触发DAC了，这样定时器就不需要再通过中断来触发DAC转换了。整个过程不需要软件参与，实现硬件自动化，这就是主模式的作用。） 通用定时器 # 框图：\n16位向上、向下、向上/向下自动装载计数器，支持向上、向下、中央对齐模式\n外部时钟模式2：TIMx_ETR \u0026raquo; ETR \u0026raquo; 极性选择、边沿检测和预分频器、ETRP、输入滤波 \u0026raquo; ETRF \u0026raquo; 时基单元\n除外部ETR可以提供时钟外，TRGI也可以提供时钟，从名字上看主要用作触发输入使用，可以触发定时器的从模式，同时TRGI也可以当作外部时钟使用，这里说明下 TRGI 当作外部时钟的输入使用，即外部时钟模式1。\nTRGI 输入信号，即外部时钟模式1的输入：\nETR 引脚信号\nITR 信号（来自其他定时器），由其他 TRGO 到 ITR，ITR0～ITR3分别来自其他4个定时器的 TRGO 输出。一般可以用作定时器级联\n从定时器 ITR0 (TS = 000) ITR1 (TS = 001) ITR2 (TS = 010) ITR3 (TS = 011) TIM2 TIM1 TIM8 TIM3 TIM4 TIM3 TIM1 TIM2 TIM5 TIM4 TIM4 TIM1 TIM2 TIM3 TIM8 TIM5 TIM2 TIM3 TIM4 TIM8 TI1F_ED，连接的为输入捕获的 CH1，后缀 ED 为边沿的意思\nTI1FP1\nTI2FP2\n下右：输出比较电路，4个通道（CH1～CH4），可以输出 PWM 波形驱动电机\n下左：输入捕获电路，4个通道（CH1～CH4），可以用于测输入方波频率等\n下中：捕获比较寄存器，是输入捕获和输出比较电路公用的寄存器，因为输入捕获和输出比较也不能同时使用\n定时中断基本结构图：\nCNT 为定时器中计数器的值，可以使用时钟计时，也可以使用时钟统计电平翻转次数。\n高级定时器 # 略\n输出比较和PWM # OC(Output Compare)输出比较 # 输出比较可以通过比较 CNT 与 CCR 寄存器值的关系来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形。 每个高级定时器和通用定时器都拥有 4 个输出比较通道。 高级定时器额外拥有死区生成和互补输出的功能。 PWM # PWM （Pulse Width Modulation）脉冲宽度调制。 在具有惯性的系统中通过对一些列脉冲宽度进行调制，来等效地获得所需要的模拟参量，常用于电机控速、LED亮度控制等领域。 PWM参数： 频率：$$ \\frac{1}{T_s}$$ ，$$T_s$$ 为高低电平变换周期的时间。 占空比：$$ \\frac{T_{ON}}{T_s} $$ ，$$T_{ON}$$ 为高低电平变换周期的时间，占空比 100%，则直接是高电平；占空比 0% 直接是低电平；占空比决定了 PWM 等效出来的模拟电压的大小，占空比越大，等效出来的模拟电压越趋近于高电平；占空比越小，等效出来的模拟电压越趋近于低电平。 **分辨率：**占空比变化步距，表现在占空比变化的精细程度。 输出比较通道（通用） # 输出模式控制器根据 CNT 和 CCR1 的值来确定输出 oc1ref 的高低电平，OC1M[2:0]可以配置输出模式控制器模式 ETRF 是定时器的一个小功能，不用了解 oc1ref可以映射到主模式控制器，单主要还是走下面的电路 CC1P 极性选择，值为0，信号往上走；值为1则极性反转 OC1 极 CH1 通道引脚，在引脚定义表里可以知道具体是哪个 GPIO 口 模式 描述 冻结 CNT=CCR时，REF保持为原状态，使用该模式时输出暂停，高低电平位置为暂停时候的状态不变 匹配时置有效电平 CNT=CCR时，REF置有效电平，可通俗理解为高电平 匹配时置无效电平 CNT=CCR时，REF置无效电平，可通俗理解为低电平 匹配时电平翻转 CNT=CCR时，REF电平翻转，可以输出频率可调，占空比始终为 50% 的 PWM 波形 强制为无效电平 CNT与CCR无效，REF强制为无效电平 强制为有效电平 CNT与CCR无效，REF强制为有效电平 PWM模式1 可以输出频率和占空比都可调的PWM波形。向上计数：CNT\u0026lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平；向下计数：CNT\u0026gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平 PWM模式2 可以输出频率和占空比都可调的PWM波形。向上计数：CNT\u0026lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平；向下计数：CNT\u0026gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平 PWM 频率： $$ Freq = \\frac{CK_PSC}{(PSC+1)\\cdot{(ARR+1)}} $$\nPWM 占空比：$$ Duty=\\frac{CCR}{ARR+1} $$\nPWM 分辨率：$$ Reso = \\frac{1}{ARR+1} $$\n例子：要求输出频率为 1KHz，分辨率为 1%，占空比可任意调节的 PWM 波形。\n舵机 # 根据 PWM 信号占空比来控制输出角度的装置 输入 PWM 信号要求，周期为 20 ms，高电平宽度为 0.5 ms ～ 2.5 ms Sg90 舵机 三根输入线：两个电源线，一根信号线 PWM 根据通过信号线控制舵机 输入脉冲信号宽度对应角度：(0.5ms, -90)、(1ms, -45)、(1.5ms, -0)、(2ms, 45)、(2.5ms, 90) 电机 # 直流电机将电能转为机械能，有两个电极，当电极正接时电极正转，反接时电机反转 电机属于大功率电器，GPIO 口无法直接驱动，需要配合电机驱动电路来操作 TB6612 双路 H 桥型直流电机驱动芯片，可以驱动两个电机并且控制其转速方向 IC(Input Capture)输入捕获 # 输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前 CNT 的值将被锁存在 CCR 中，可用于测量 PWM 波形的频率、占空比、脉冲间隔、电平持续时间等参数。 每个高级定时器和通用定时器都拥有4个输入捕获通道 可配置为 PWMI 模式，同时测量频率和占空比 可配合主从从发模式，实现硬件全自动测量 频率测量 # 测频法：在闸门时间 T 内，对上升沿计次，得到 N， 则频率 $$ f_x = \\frac{N}{T} $$，适合测量高频信号。\n测周法：两个上升沿内，以标准频率 $$f_c$$计次，得到 N，则频率 $$ f_x = \\frac{f_c}{N} $$，使用一个已知的标准频率$$f_c$$的计次时钟来驱动计数器，适合测量低频信号。\n中界频率：测频法和测周法误差相等的频率点 $$f_m=\\sqrt{\\frac{f_c}{T}}$$，用这个来判断什么时候使用测频法，什么时候使用测周法。当待测频率小于$$f_m$$，使用测周法，大于时使用测频法。\n输入捕获通道 # $$f_{DTS}$$ 是滤波器采样时钟来源，TI1 为滤波器输入，TI1F 为滤波后的信号 ICF 可以控制滤波器参数，以采样频率对输入信号进行采样，当连续 N 个值都为高电平，输出才为高电平，连续N个值都为低电平，输出才为低电平。如果信号出现高频抖动导致连续采样的 N 个值不全都一样那输出就不会变化，这样就可以达到滤波的效果。采样频率越低，采样个数N越大，滤波效果越好。 CC1P极性选择 ICPS配置分频器 CC1E使能输出或失能 主从触发模式 # 暂略\n编码器接口 # 编码器接口可以接收增量（正交）编码器的信号，根据编码器旋转产生的蒸饺信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度 每个高级定时器和通用定时器都拥有1个编码器接口 两个输入引脚借用了输入捕获通道1和通道2 不会使用时钟和时基单元初始化设置的计数方向，此时计数时钟和计数方向都处于编码器接口托管的状态 如何判断正反转 # 首先把 A 相和 B 相的所有边沿作为计数器的计数时钟，出现边沿信号时，就计数自增或自减，增或减的操作由另一相的状态来确定，当出现某个边沿时，判断另一相高低电平。具体如下图：\n"},{"id":72,"href":"/solution/environment/apple-m%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85-pyqt/","title":"Apple M系列芯片安装 Pyqt","section":"环境配置","content":" Apple-M系列芯片安装-Pyqt # 前提：安装好 Homebrew。\n终端命令如下（含详细注释）：\nbrew install pyqt5 # 安装 pyqt5，建议挂梯子 output: # 以下为部分输出结果可做参考 ... ==\u0026gt; Pouring node--17.4.0.arm64_monterey.bottle.tar.gz 🍺 /opt/homebrew/Cellar/node/17.4.0: 1,984 files, 44.5MB ==\u0026gt; Running `brew cleanup node`... Removing: /opt/homebrew/Cellar/node/17.2.0... (2,018 files, 44.4MB) Removing: /opt/homebrew/Cellar/node/17.3.1... (1,976 files, 44.4MB) Removing: /Users/xu/Library/Caches/Homebrew/node--17.3.1... (12MB) ==\u0026gt; Checking for dependents of upgraded formulae... ==\u0026gt; No broken dependents found! # 添加环境变量 echo \u0026#39;export PATH=\u0026#34;/opt/homebrew/Cellar/qt@5/5.15.2_1/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc echo \u0026#39;export PATH=\u0026#34;/opt/homebrew/Cellar/pyqt@5/5.15.6/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 将 /opt/homebrew/Cellar/pyqt@5/5.15.6/lib/python3.9/site-packages 里内容全部拷贝至 /Users/你的用户名/miniforge3/lib/python3.9/site-packages 文件夹下。 "},{"id":73,"href":"/solution/environment/docker-%E5%AE%89%E8%A3%85-redis-/","title":"Docker 安装 Redis","section":"环境配置","content":" 下载镜像文件 # docker pull redis 创建实例并启动 # 为防止挂载文件时将 redis.conf 当成目录处理，所以要提前创建好该文件，命令如下：\nmkdir -p /Users/xu/Documents/DockerConfig/redis/conf touch /Users/xu/Documents/DockerConfig/redis/conf/redis.conf 创建实例：\ndocker run -p 6379:6379 --name redis \\ -v /Users/xu/Documents/DockerConfig/redis/data:/data \\ -v /Users/xu/Documents/DockerConfig/redis/conf/redis.conf:/etc/redis/redis.conf \\ -d redis redis-server /etc/redis/redis.conf 使用 redis 镜像执行 redis-cli 命令连接 # docker exec -it redis redis-cli "},{"id":74,"href":"/solution/environment/hugo-%E4%B8%BB%E9%A2%98-hugo-book-%E4%B8%AD%E8%8B%B1%E6%96%87%E6%90%9C%E7%B4%A2%E9%85%8D%E7%BD%AE/","title":"Hugo 主题 Hugo Book 中英文搜索配置","section":"环境配置","content":" Hugo 主题 Hugo-book 中英文搜索配置 # 可以直接看解决方案修改即可，前提defaultContentLanguage = \u0026quot;zh\u0026quot;。因为修改的就是 zh.yaml 文件。\n存在的问题 # 主要问题是不能用英文搜索，这是存在问题时的配置文件：\nbaseURL = \u0026#39;https://pp-tt.github.io.git\u0026#39; title = \u0026#39;噗通\u0026#39; theme = \u0026#39;hugo-book\u0026#39; defaultContentLanguage = \u0026#34;zh\u0026#34; 配置文件中defaultContentLanguage 指向 zh，但是这导致一个问题，页面中可以搜索中文，但是搜索英文失败，比如搜索 Tensorflow 的时候，网页是没有任何显示的，但是 content 确确实实存在这些关键词文件。下面是搜索结果图：\n解决思路 # 先看一下themes/hugo-book/i18n/zh.yaml配置文件，主要看id: bookSearchConfig这项配置，文件具体内容如下：\n# zh.yaml 文件内容 - id: bookSearchConfig translation: | { encode: false, tokenize: function(str) { return str.replace(/[\\x00-\\x7F]/g, \u0026#39;\u0026#39;).split(\u0026#39;\u0026#39;); } } 回顾问题：当defaultContentLanguage = \u0026quot;zh\u0026quot;可以进行仅中文搜索，当defaultContentLanguage = \u0026quot;en\u0026quot;仅可以进行英文搜索，那么是否可以通过搜索修改\nzh.yaml将其变成中英文搜索呢？参考https://github.com/alex-shpak/hugo-book/issues/357中韩国大佬 yeonns 的做法，尝试了下解决了我的问题。\n解决方案 # 将 themes/hugo-book/i18n/zh.yaml 中的 id: bookSearchConfig 内容修改如下即可：\n- id: bookSearchConfig translation: | { split: \u0026#34; \u0026#34; } "},{"id":75,"href":"/solution/environment/iterm2-oh-my-zsh-%E9%85%8D%E7%BD%AE/","title":"I Term2 Oh My Zsh 配置","section":"环境配置","content":" iTerm2-Oh-My-Zsh-配置 # 配置 Oh My ZSH # 官网链接：http://ohmyz.sh/\n安装 # 安装命令如下：\nsh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 输出如下：\n配置主题 # 在 ~/.zshrc 文件中配置主题（注：原先的配置文件内容被转移到 .zshrc.pre-oh-my-zsh 文件中），配置如下：\nZSH_THEME=\u0026#34;agnoster\u0026#34; # 更多主题：https://github.com/ohmyzsh/ohmyzsh/wiki/Themes 卸载 Oh My ZSH # uninstall_oh_my_zsh 更新 # upgrade_oh_my_zsh 安装配置 iTerm2 # 链接：https://iterm2.com/\n刚刚装好字体会显示错误，需要安装对应字体。\n安装字体 # git clone https://github.com/pp-tt/fonts cd fonts ./install.sh cd .. rm -rf fonts 配置相关 # 配置 Theme 为 Dark\n配置 Colors\n配置字体\n安装插件 # cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git # 高亮 git clone https://github.com/zsh-users/zsh-autosuggestions.git\t# 自动补全 vi .zshrc # 配置文件修改如下 plugins=(git zsh-autosuggestions zsh-syntax-highlighting) "},{"id":76,"href":"/solution/environment/m1-%E8%8A%AF%E7%89%87-docker-%E5%AE%89%E8%A3%85-mysql5.7-/","title":"M1 芯片 Docker 安装 Mysql5.7","section":"环境配置","content":"此处是针对 Apple 芯片Mac来配置安装的，其它类型设备日后遇到再更新，并且其他 x86 架构安装配置也应该没有那么麻烦吧！\n获取镜像 # 修改为 x86 架构\ndocker pull --platform linux/x86_64 mysql:5.7 创建实例 # docker run -p 3306:3306 --name mysql -v /Users/xu/Documents/DockerConfig/mysql/log:/var/log/mysql -v /Users/xu/Documents/DockerConfig/mysql/data:/var/lib/mysql -v /Users/xu/Documents/DockerConfig/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d biarms/mysql:5.7 配置 Mysql # 添加 DockerConfig/mysql/conf/my.cnf 文件，配置如下，主要为了解决字符编码问题：\n[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] init_connect=\u0026#39;SET collation_connection = utf8_unicode_ci\u0026#39; init_connect=\u0026#39;SET NAMES utf8\u0026#39; character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve "},{"id":77,"href":"/solution/environment/mac-idea-%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%8D/","title":"MAC Idea 快捷键位","section":"环境配置","content":"Opt + Cmd + u : 类图\nCmd + o ：搜索查询类\nCmd + F12 ：列出方法定义\n"},{"id":78,"href":"/solution/environment/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"内网穿透","section":"环境配置","content":" 内网穿透 # 教程主要分为两部分，分别为服务端（公网服务器）部分和客户端（即需要穿透的设备）部分。\n官方文档\n服务端部署步骤 # 首先保证服务器6000～9000端口放行，然后下载程序。\n程序下载链接：https://github.com/fatedier/frp/releases 根据硬件配置选择对应的程序下载并解压，可先下载本地，后续再通过其他方法上传到服务器，或者直接wget。上传到终端后操作如下：\nmv frp_0.38.0_linux_amd64 frps # 修改文件夹名为frps，s表示服务端程序 cd frps rm -rf frpc* # 删除所有frpc开头的文件，即将客户端文件删除 ./frps -c ./frps.ini # 启动程序 根据服务器配置类型选择对应的版本下载并解压，命令如下图：\n至此，服务端部署完毕！\n客户端部署步骤 # 检查SSH # 我的机器系统是Ubuntu 20.04,首先检查是否安装openssh-server，连接待穿透主机，终端输入sshd，若提示无此相关程序，则键入如下命令安装：\nsudo apt install openssh-server\n获取程序 # 因为我的主机是x86架构，同我的云服务器一样，所以用的是和之前一样的程序包，只不过这次删除的是同服务端无关的所有软件了，这里我使用wget重新下载的一样的程序：\nsudo wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz 然后解压:\nsudo tar -zxvf frp_0.38.0_linux_amd64.tar.gz 整理程序 # 重命名文件夹为frpc，c代表客户端的意思，并删除所有frps开头的文件，即删除所有与客户端不相关的文件。这一步其实不操作也不影响，只是为了看起来舒服，如果后续设置开机自启动的话，这样路径比较清楚。\nsudo mv frp_0.38.0_linux_amd64 frpc cd frpc/ sudo rm -rf frps* 配置参数 # 配置相关参数（穿透22端口，实现远程ssh)，修改frpc.ini文件，修改如下：\n[common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 参数解释 :\n[common]段落填写的分别是服务器的地址和frp程序的端口，其中 x.x.x.x为云服务器ip地址，server_port值应该同服务端frps.ini文件中对应的值相同，即7000。\n[ssh]段落中对local_ip 为本地IP，即127.0.0.1。同理local_port为SSH的本连接端口，remote_port为远程映射端口，这里是将22端口映射到云服务器的6000端口，然后我们通过云服务器的IP地址+端口号(6000)来与内网中机器进行通信。\n注意[ssh]写法并不是固定的，只是一个标识，但是必须是唯一的。举个例子，如果我需要远程使用这台机器的Jupyter Notebook程序，那么我需要穿透，该程序端口默认为8888，一般运行后用浏览器打开https://127.0.0.1:8888/即可使用，那么穿透后，我在任何一台机器上输入该链接(https://服务器IP:映射端口号/)即可登录使用了，所以修改如下：\n[common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [jupyter] type = tcp local_ip = 127.0.0.1 local_port = 8888 remote_port = 6001\t至此，配置解释完毕。\n运行程序 # 键入如下命令运行客户端程序：\n./frpc -c ./frpc.ini 同时，会发现服务端已挂起的程序相比之前发生了变化： 现在就可以在任意一台机器上通过服务器IP地址+端口号(6000)来连接该设备了。\n不论是服务端还是客户端，为避免麻烦，都建议设置成开机自启动，这里不赘述。\n"},{"id":79,"href":"/solution/environment/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE/","title":"内网穿透的自启动设置","section":"环境配置","content":"实验机器：Ubuntu16、Ubuntu18\n整体步骤 # 编写 .service 文件，习惯以 name@用途/用户名.service 的格式命名 使用 systemctl daemon-reload 让系统服务被加载 使用 systemctl start [service文件名，不需要尾缀] 来启动 使用 systemctl enable name@用途/用户名.service 设置开启启动 总共就以上一个步骤，下面会一一记录，除此之外，以下总结一些常用命令（ 参考链接）：\n启动一个服务：systemctl start nginx.service 关闭一个服务：systemctl stop postfix.service 重启一个服务：systemctl restart nginx.service 显示一个服务的状态：systemctl status postfix.service 在开机时启用一个服务：systemctl enable nginx.service 在开机时禁用一个服务：systemctl disable nginx.service 查看服务是否开机启动：systemctl is-enabled nginx.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled\n编写 .service 文件 # 路径如下：\nvi /lib/systemd/system/frp@xu.service\n文件内容如下（注意修改 frp 程序路径）：\n[Unit] Description=Frp Client Service After=network.target syslog.target Wants=network.target [Service] Type=simple Restart=on-failure RestartSec=5s ExecStart=/bin/sh -c \u0026#39;/home/xu/frp/frpc -c /home/xu/frp/frpc.ini\u0026#39; [Install] WantedBy=multi-user.target 加载系统服务 # 使用 systemctl daemon-reload 让系统服务被加载\n启动 .service 文件 # 使用 systemctl start frp@xu 来启动。\n设置开机启动 # 使用 systemctl enable frp@xu.service 设置开启启动。\n"},{"id":80,"href":"/solution/problems/brew-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Brew 一些常用命令","section":"杂乱问题","content":" brew 的一些常用命令 # 安装卸载软件 # brew \u0026ndash;version 或者 brew -v 显示brew版本信息 brew install 安装指定软件 brew uninstall 卸载指定软件 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件 brew info 显示指定软件信息 brew reinstall 重新安装指定软件，先卸载后安装 brew install \u0026ndash;build-from-source 源码安装指定软件，可以给定指定参数 brew commands 列出所有可用命令 2、升级软件相关 # brew update 自动升级homebrew （从github下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade 升级指定的软件 brew pin 禁止指定软件升级 brew unpin 解锁禁止升级 brew upgrade \u0026ndash;all 升级所有的软件包，包括未清理干净的旧版本的包 brew edit 编辑软件，不会的情况下慎用 brew tap 列出本地资源仓库，其中 homebrew 是默认仓库，其它都是第三方仓库 brew tap \u0026lt;user/repo\u0026gt; 添加第三方仓库，命名的规则按照github来定的。 brew untap \u0026lt;user/repo\u0026gt; 删除仓库 brew deps 查看指定软件依赖于哪些软件 brew uses 查看指定软件被哪些软件所依赖 清理相关 # homebrew再升级软件时候不会清理相关的旧版本，在软件升级后我们可以使用如下命令清理\nbrew cleanup -n 列出需要清理的内容 brew cleanup 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew unistall 卸载指定软件 brew unistall \u0026ndash;force 彻底卸载指定软件，包括旧版本 "},{"id":81,"href":"/solution/problems/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Docker 常用命令","section":"杂乱问题","content":" docker 的一些常用命令 # 镜像： # 列出本机的所有 image 文件。 # $ docker image ls == docker images\n删除 image 文件 # $ docker image rm [imageName]\n拉取镜像 # $ docker image pull 组/名:版本号\n删除镜像 # $ docker rmi 镜像:版本号 == docker rmi id\n查看所有镜像id # $ docker images -q\n删除所有镜像 # $ docker rmi ‘docker images -q’\n容器： # 创建容器 -i 一直运行 -t为终端 /bin/bash 进入容器的初始化指令 # $ docker run -it —name 容器名 镜像名:版本号 /bin/bash\n查看正在运行的容器 # $ docker ps\n查看所有的容器 # $ docker ps -a\n创建后台运行的容器 # $ docker run -id —name 容器名 镜像名:版本号\n进入一个容器 # $ docker exec -it 容器名 /bin/bash\n停止/启动容器 # $ docker stop/start 容器名\n删除容器 # $ docker rm 容器名\n删除所有容器 # $ docker rm ‘docker ps -aq’\n查看容器信息 # $ docker inspect 容器名\n数据卷 # 挂载数据卷 # $ docker run -it —name 容器名 -v 宿主机绝对路径:容器绝对路径 镜像(:tag)\n目录必须绝对路径 如果目录不存在会自动创建 可以挂在多个数据卷 一个容器挂载多个数据卷 # $ docker run -it —name 容器名 -v 宿主机绝对路径:容器绝对路径 -v 宿主机绝对路径:容器绝对路径 镜像(:tag)\n创建数据卷容器 # $ docker run -it —name 容器名 -v /volume 镜像(:tag) 不设置：左边部分，会自动分配目录\n挂载到数据卷容器 # $ docker run -it —name 容器名 —volumes-from 数据卷容器名 镜像(:tag)\n容器—镜像 # 容器转镜像 # $ docker commit 容器名 镜像名：版本号\n镜像保存为压缩文件 # $ docker save -o 镜像名.tar 镜像名：版本\n加载压缩文件还原镜像 # $ docker load -i 镜像压缩文件\n生成镜像 # $ docker build -f Dockerfile路径 -t 镜像:版本 .\n设置容器自动启动 # docker update [容器名] --restart=always "},{"id":82,"href":"/solution/problems/git-github-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/","title":"Git Git Hub 相关命令整理","section":"杂乱问题","content":" Git-GitHub-相关命令整理 # Git # git config --global user.name 用户名\u0026amp;git config --global user.mail 邮箱：用于区分不同操作者的身份，知道本次操作是谁做的，与GitHub的登录账号无关。 git init：初始化本地仓库（新增.git文件夹，内容谨慎修改） git status：查看当前状态（git是按照行来维护文件的） git add 文件名：将文件提交到暂存区 git rm --cache 文件名：将暂存区文件删除 git commit -m 'message' 文件：将暂存区文件提交到本地库 git reflog：查看前7位版本号，分支指向 git log：查看详细信息，包括谁提交的，完整的版本号等 git reset --hard '版本号'：切换版本，本质是移动HEAD指针，.git/HEAD文件内容显示指向的分支，.git/refs/heads显示指向的分支版本。 git branch -v：查看分支 git branch 分支名：创建分支 git checkout 分支名：切换分支 git merge 分之名：合并指定分支到当前分支上，若出现冲突，\u0026lt;\u0026lt;\u0026lt; HEAD与===之间的内容表示当前分支内容，===与\u0026gt;\u0026gt;\u0026gt;***之间的内容表示指定分支内容。冲突处理步骤如下： 1. 修改冲突 2. 添加暂存区 3. git commit -m 'message'注意不用带文件名，因为这时为合并状态 GitHub # git psuh：将提交内容推送到库，项目团队人员可用，否则无法push，团队外成员需要先fork自己的GitHub git remote -v：查看当前所有别名 git remote add 别名 链接：起别名 git push 别名 master：本地master分支推送到远程仓库 git pull 别名 分支：拉取仓库（尽量随时让本地仓库保持最新状态） git clone 链接：无需登录账号，做了以下三件事： 拉取代码 初始化本地仓库 起好别名：origin ssh-keygen -t rsa -C 邮箱：ssh免密登陆，~/.ssh/目录下会出现id_rsa.pub和id_rsa，复制id_rsa.pub文件中内容填入GitHub即可。 常见问题 # 查看 git config --list 中的键值位置？ # git config --show-origin --get [键名] 操作演示：\ncredential.helper=osxkeychain init.defaultbranch=main user.name=xu user.email=zbx996@gmail.com 如上，可以通过下面命令查找： git config --show-origin --get credential.helper 返回： file:/Library/Developer/CommandLineTools/usr/share/git-core/gitconfig\tosxkeychain "},{"id":83,"href":"/solution/problems/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%AB%E7%9B%B2/","title":"面试题扫盲","section":"杂乱问题","content":" 计算机网络 # OSI 七层模型及其作用？ # 应用层：为计算机用户提供服务\n表示层：数据处理（编解码、加密解密、压缩解压缩）\n会话层：管理（建立、维护、重连）应用程序之间的会话\n传输层：为两台主机进程之间的通信提供通用的数据传输服务\n网络层：路由和寻址(決定数据在网络的游走路径）\n数据链路层：帧编码和误差纠正控制\n物理层：透明地传送比特流传输\nTCP/IP 四层体系分层结构？ # 应用层：为计算机用户提供服务 传输层：为两台主机进程之间的通信提供通用的数据传输服务 网络层：路由和寻址(決定数据在网络的游走路径） 网络接口层：透明地传送比特流传输 三次握手的过程？ # 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -\u0026gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认； 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –\u0026gt; 客户端,然后服务端进入 SYN_RECV 状态 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –\u0026gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成TCP三次握手。 为什么要三次握手? # 确定自己和对方的发送与接收都是正常的。\n解释一下四次挥手？ # 第一次挥手 ：客户端发送一个 FIN（SEQ=X） 标志的数据包-\u0026gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。 第二次挥手 ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-\u0026gt;客户端 。然后，此时服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。 第三次挥手 ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-\u0026gt;客户端请求关闭连接，然后，服务端进入LAST-ACK状态。 第四次挥手 ：客户端发送 ACK (SEQ=y+1)标志的数据包-\u0026gt;服务端并且进入TIME-WAIT状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。 为什么要四次挥手？ # TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。\nJava # 关于底层数据结构，HashMap 的 JDK 1.7 和 JDK 1.8 有何不同？ # JDK 1.7 组成：数组 + 链表\nJDK 1.8 组成：数组 + 链表/红黑树\nJDK1.8 中，HashMap 树化的条件？ # 需要同时满足以下条件：\n数组容量大于等于64 链表长度大于8 HashMap 的 push 流程？ # HashMap 是懒惰创建数组的，首次使用才创建数组\n计算索引（桶下标）\n如果桶下标还没人占用，创建 Node 占位返回\n如果桶下标已经有人占用\n已经是 TreeNode 走红黑树的添加或更新逻辑 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，并且容量大于等于64，走树化逻辑 返回前检查容量是否超过阈值，一旦超过进行扩容\nArrayList是如何扩容的？ # ArrayList扩容后的大小等于扩容前大小的1.5倍。\n可能会导致的问题：\n内存不足抛出OutOfMemoryError。 扩容的时候还需要对数组进行拷贝，这个也挺费时的。 解决方案：面对大量数据时，使用的时候要竭力避免扩容，提供一个初始估计容量参数，以免扩容对性能带来较大影响。\n代理和 CGLIB 动态代理对比 # JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。 静态代理和动态代理的对比 # 灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 设计模式 # 六大设计原则 # **开闭原则：**对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 **里氏代换原则：**任何基类可以出现的地方，子类一定可以出现。子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 **依赖倒转原则：**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 **接口隔离原则：**客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。 **迪米特法则：**如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 **合成复用原则：**尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 单例模式 # 饿汉式 # public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 懒汉式 # /** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为null if(instance == null) { instance = new Singleton(); } } } return instance; } } "}]